{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"sca",
				"ScaleY"
			],
			[
				"va",
				"value"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Helpers.h",
			"settings":
			{
				"buffer_size": 1032,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "//---------------------------------------------------------------------------\n\n\n\n#pragma hdrstop\n\n#include \"without_autocad.h\"\n#ifndef WITHOUT_AUTOCAD\n\n#include \"acadexport.h\"\n#include \"AcadExportThread.h\"\n#include <list.h>\n#include \"MickMacros.h\"\n#include \"ProgressFrm.h\"\n#include \"AcadExportObjects.h\"\n#include \"AutoCADExportForm.h\"\n#include \"AutoCADPrintForm.h\"\n#include \"Helpers.h\"\n\nusing namespace std;\n\n#define M_RESETROWPOS(t) iTop##t=iBottom##t\n//---------------------------------------------------------------------------\n\n#pragma package(smart_init)\n\n\nstruct barrierPointAsc : binary_function<TPoint, TPoint, bool> {\n    bool operator() (const TPoint &p1, const TPoint &p2) const {\n        return p1.x < p2.x;\n    }\n};\n\nvoid SetObjectColor(IAcadEntity *object, unsigned char R, unsigned char G, unsigned char B)\n{\n    AcadAcCmColor *color =  object->TrueColor;\n    color->SetRGB(R, G, B);\n    object->TrueColor = color;\n}\n\n__fastcall TAcadExport::TAcadExport(void) {\n    ScaleY = 6;\n    strAutoCADDir = ExtractFileDir(Application->ExeName) + \"\\\\AutoCAD\\\\\";\n\n    AutoCAD.SignLabelParser =  Helpers::SignLabelParser;\n\n    tabHeight = 2000;\n    tabOffsetRoadMark = 15000;\n    fTextSize = 0.25;\n    textOffset = tabHeight * (1 - fTextSize) / 2;\n    tabOffsetBarrier = tabOffsetRoadMark + tabHeight;\n\n    tableTop.Owner = &AutoCAD;\n    tableBottom.Owner = &AutoCAD;\n    tableGraphic.Owner = &AutoCAD;\n\n\n    tableTop.RepeatInterval = 100000;\n    tableTop.RepeatInterval = 100000;\n\n    tableBottom.HeaderWidth = 20000;\n    tableBottom.RepeatInterval = 100000;\n\n    tableGraphic.HeaderWidth = 20000;\n    tableGraphic.RepeatInterval = 20000;\n\n    tableTop.kBottomEmptyPadding = 0.2;\n    tableBottom.kBottomEmptyPadding = 0.2;\n    tableGraphic.kBottomEmptyPadding = 0.2;\n\n    tableTop.kPadding = 0.90;\n    tableBottom.kPadding = 0.90;\n    tableGraphic.kPadding = 0.90;\n\n    tableTop.AutoShrink = true;\n    tableGraphic.AutoShrink = true;\n    //tableTop.AutoShrinkOneLetterWidth = 2300;\n    tableBottom.AutoShrink = true;\n    //tableBottom.AutoShrinkOneLetterWidth = 2300;\n\n\n    OutInfoLog = 0;\n    fAuto6_13 = true;\n}\n\nvoid TAcadExport::ResetLastPoints()\n{\n    lPointBarrier = TPoint(0, tabOffsetBarrier);\n    fAlreadyDrawSignSpot = false;\n    fAlreadyDrawTube = false;\n    fDrawTable = false;\n    SlopeMax = 0, SlopeMin = 0, SlopeCur = 0, SlopeLastFase = 0;\n}\n\n__fastcall TAcadExport::~TAcadExport(void) {\n}\n\nAcadPolylinePtr TAcadExport::DrawPolyLine(vector<double> &points)\n{\n    AcadPolylinePtr pl;\n    if (points.size() >= 4) {\n        pl = AutoCAD.DrawPolyLine(points, 2);\n    }\n    return pl;\n}\n\nAcadPolylinePtr  TAcadExport::DrawPolyPoints(TExtPolyline *Poly, bool fUseCodes, bool fLockGaps,\n        void(*lineEditFunction)(AcadPolylinePtr&, void* data), void* data)\n{\n    vector<double> points, range;\n    vector<int> codes;\n    AcadPolylinePtr pl;\n\n    if (Poly->Count < 2) {\n        return pl;\n    }\n\n    for (int i = 0; i < Poly->Count; ++i) {\n        points.push_back(Poly->Points[i].x);\n        points.push_back(-ScaleY * Poly->Points[i].y);\n        codes.push_back(Poly->Codes[i].Visible());\n    }\n\n    int iLast = 0;\n    if (fUseCodes) {\n        if (Poly->Count >= 2 && codes[0]) {\n            range.push_back(*points.begin());\n            range.push_back(*(points.begin() + 1));\n            range.push_back(*(points.end() - 2));\n            range.push_back(*(points.end() - 1));\n            pl = DrawPolyLine(range);\n            if (lineEditFunction) {\n                lineEditFunction(pl, data);\n            }\n        }\n        for (int i = 1; i < codes.size(); i++) {\n            if (!codes[i]) {\n                if ( i - iLast > 1 ) {\n                    range = vector<double>(\n                                points.begin() + 2 * iLast,\n                                points.begin() + 2 * i);\n                    pl = DrawPolyLine(range);\n                    if (lineEditFunction) {\n                        lineEditFunction(pl, data);\n                    }\n                }\n                iLast = i;\n            }\n        }\n        if (codes[codes.size() - 1]) {\n            range = vector<double>(\n                        points.begin() + 2 * iLast,\n                        points.end());\n            if (codes[0]) {\n                range.push_back(points[0]);\n                range.push_back(points[1]);\n            }\n            pl = DrawPolyLine(range);\n            if (lineEditFunction) {\n                lineEditFunction(pl, data);\n            }\n        }\n    } else {\n        if (fLockGaps && Poly->Count > 2) {\n            points.push_back(Poly->Points[0].x);\n            points.push_back(-ScaleY * Poly->Points[0].y);\n        }\n        pl = DrawPolyLine(points);\n        if (lineEditFunction) {\n            lineEditFunction(pl, data);\n        }\n    }\n    return pl;\n}\n\nbool __fastcall TAcadExport::BindToCurrentDocument(TRoad *road)\n{\n    curRoad = road;\n    AutoCAD.RunAutoCAD();\n    AutoCAD.BindToActiveDocument();\n    return true;\n}\n\nvoid TAcadExport::Print()\n{\n    FAutoCADPrint->helper = &AutoCAD;\n    if (curRoad) {\n        FAutoCADPrint->ePos = curRoad->LMax;\n        FAutoCADPrint->sPos = curRoad->LMin;\n    }\n    FAutoCADPrint->ShowModal();\n}\n\nbool __fastcall TAcadExport::AddDocument()\n{\n    try {\n        AutoCAD.ResetBlocksCollection();\n        AutoCAD.AddDocument(strAutoCADDir + \"SignsDef.dwt\");\n        AutoCAD.SendCommand(WideString(\"CLAYER 0\\n\"));\n        AutoCAD.ActiveDocument->ActiveSpace = acModelSpace;\n        AutoCAD.CheckExistingBlocks();\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::OpenDocument(AnsiString name)\n{\n    static length;\n    length = name.Length();\n    if (length > 2) {\n        if (name[1] == '.' && (name[2] == '/') || (name[2] == '\\\\')) {\n            name = ExtractFileDir(Application->ExeName) + name.SubString(2, length - 1);\n        }\n    } else {\n        return false;\n    }\n    try {\n        AutoCAD.ResetBlocksCollection();\n        if (ExtractFileExt(name) == \".dwt\") {\n            AutoCAD.AddDocument(name);\n        } else {\n            AutoCAD.OpenDocument(name);\n        }\n        AutoCAD.SendCommand(WideString(\"CLAYER 0\\n\"));\n        AutoCAD.ActiveDocument->ActiveSpace = acModelSpace;\n        AutoCAD.CheckExistingBlocks();\n        BUILDER_INFO(\"Успешно открыл документ и пересчитал блоки\");\n    } catch (...) {\n        BUILDER_ERROR(\"Возникла непредвиденая ошибка при открытии документа!\");\n        return false;\n    }\n    return true;\n}\n\n\nbool __fastcall TAcadExport::BindActiveDocument()\n{\n    AutoCAD.ResetBlocksCollection();\n    if ( AutoCAD.BindToActiveDocument() ) { // function return false on error\n        AutoCAD.SendCommand(WideString(\"CLAYER 0\\n\"));\n        AutoCAD.ActiveDocument->ActiveSpace = acModelSpace;\n        AutoCAD.CheckExistingBlocks();\n        return true;\n    }\n    return false;\n}\n\nvoid __fastcall TAcadExport::hideApplication()\n{\n    //AutoCAD.ActiveDocument->SendCommand(WideString(\"_.zoom _e\\n\"));\n    AutoCAD.Application->Visible = 0;\n}\n\nvoid __fastcall TAcadExport::showApplication()\n{\n    //AutoCAD.ActiveDocument->SendCommand(WideString(\"_.zoom _e\\n\"));\n    AutoCAD.Application->Visible = -1;\n}\n\nbool __fastcall TAcadExport::BeginDocument(TRoad *road) {\n    try {\n        curRoad = road;\n\n        ResetLastPoints();\n        rectmap.clear();\n\n        AutoCAD.RunAutoCAD();\n        AutoCAD.DisableAutoSave();\n        /*iAutoSavefInterval = AutoCAD.Application->Preferences->OpenSave->AutoSaveInterval;\n        AutoCAD.ActiveDocument->SendCommand(WideString(\"SAVETIME 0\\n\")); */\n\n        strSignsAbsent = \"\";\n        strMarkAbsent = \"\";\n\n        /*разметка таблица*/\n        tableTop.TableWidth = road->LMax;\n        tableTop.FillGapsBegin = road->LMin;\n\n        tableBottom.TableWidth = road->LMax;\n        tableBottom.FillGapsBegin = road->LMin;\n\n        tableGraphic.TableWidth = road->LMax;\n        tableGraphic.FillGapsBegin = road->LMin;\n        /**/\n\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::AddLayer(AnsiString l_name)\n{\n    IAcadLayers *layers = 0;\n    try {\n        layers = AutoCAD.ActiveDocument->get_Layers();\n    } catch (...) {\n        BUILDER_ERROR(\"Не смог получить доступ к слоям\");\n        return false;\n    }\n    if (!layers)\n        return false;\n    try {\n        IAcadLayer * layer_ptr = layers->Add(WideString(l_name).c_bstr());\n    } catch (...) {\n        BUILDER_ERROR(\"Не удалось добавить слой \" << l_name.c_str());\n    }\n    AutoCAD.SendCommand(WideString(\"CLAYER \" + l_name + \"\\n\"));\n\n    return true;\n}\n\n\nbool __fastcall TAcadExport::DrawTables(bool fWithRuler)\n{\n    int i;\n\n    if (!fDrawMap) { // режим карты отключен\n        if (tableTop.RowsCount)tableTop.DrawTable();\n        if (tableTop.drawHeaders) {\n            tableTop.DrawHeaderText(iTopSidewalks, \"Тротуары слева\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iProfileTop, \"Продольный профиль\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iTopCurves, \"Элементы дороги в плане\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iTopSlopes, \"Элементы дороги в\\nпродольном профиле\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iTopMoundH, \"Высота насыпи слева\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iTopBarriers, \"Дорожные ограждение и\\nнаправляющие устр-ва слева\", HeaderTextHeight);\n            tableTop.DrawHeaderText(iTop0, \"осевая линия\", HeaderTextHeight);\n            for (i = 0; i < iTopAxeCount; i++) {\n                tableTop.DrawHeaderText(iTopAxe - i, IntToStr(i + 1) + \"-я от осевой\", HeaderTextHeight);\n            }\n        }\n        if (tableBottom.RowsCount) tableBottom.DrawTable();\n        if (tableBottom.drawHeaders) {\n            tableBottom.DrawHeaderText(iBottomSidewalks, \"Тротуары справа\", HeaderTextHeight);\n            tableBottom.DrawHeaderText(iBottomSurface, \"Тип покрытия\", HeaderTextHeight);\n            tableBottom.DrawHeaderText(iBottomMoundH, \"Высота насыпи справа\", HeaderTextHeight);\n            tableBottom.DrawHeaderText(iBottomBarriers, \"Дорожные ограждение и\\nнаправляющие устр-ва справа\", HeaderTextHeight);\n            tableBottom.DrawHeaderText(iBottom0, \"осевая линия\", HeaderTextHeight);\n            if (~iBottomArtifacts) {\n                tableBottom.DrawHeaderText(iBottomArtifacts, \"Искусственные сооружения СЛЕВА\", HeaderTextHeight);\n                tableBottom.DrawHeaderText(iBottomArtifacts + 1, \"Искусственные сооружения СПРАВА\", HeaderTextHeight);\n            }\n            tableBottom.DrawHeaderText(iBottomCurves, \"Элементы дороги в плане\", HeaderTextHeight);\n            tableBottom.DrawHeaderText(iBottomSlopes, \"Элементы дороги в\\nпродольном профиле\", HeaderTextHeight);\n\n            for (i = 0; i < iBottomAxeCount; i++) {\n                tableBottom.DrawHeaderText(iBottomAxe + i, IntToStr(i + 1) + \"-я от осевой\", HeaderTextHeight);\n            }\n        }\n\n        if (tableGraphic.RowsCount) tableGraphic.DrawTable();\n    }\n\n    IAcadSummaryInfoPtr si = AutoCAD.ActiveDocument->SummaryInfo;\n    si->set_Comments(WideString(IntToStr((int)tableTop.TableHeight + iRulerHeight)\n                                + \"\\r\\n\" + IntToStr((int)tableBottom.TableHeight)\n                                + \"\\r\\n\" + IntToStr((int) - tableBottom.LeftTop.y)\n                                + \"\\r\\n\" + IntToStr((int)tableBottom.FillGapsBegin)\n                                + \"\\r\\n\" + IntToStr((int)tableBottom.TableWidth)\n                                + \"\\r\\n\" + IntToStr((int)iStep)\n                                + \"\\r\\n# высота верхней таблицы\"\n                                + \"\\r\\n# высота нижней таблицы\"\n                                + \"\\r\\n# растояние от центра до низа верхней таблицы\"\n                                + \"\\r\\n# начало дороги\"\n                                + \"\\r\\n# конец дороги\"\n                                + \"\\r\\n# шаг\"\n                               ));\n    si->set_Keywords(WideString(strInfoTemplate));\n\n    TReplaceFlags rf;\n    rf << rfReplaceAll;\n    si->set_Title(WideString(StringReplace(RoadName, \".\", \" \", rf)));\n\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportTables(TFAutoCADExport *form)\n{\n    fAuto6_13 = form->ExportAuto6_13;\n    fLeftValueOnly6_13 = form->ExportLeftValueOnly6_13;\n\n    RCenter = form->RCenter;\n    int iTopAddRowsCount = 0;\n    int iBottomAddRowsCount = 0;\n    iTopAxeCount = iBottomAxeCount = 0;\n    iRulerHeight = form->ExportRuler ? form->RowHeight : 0;\n\n    M_RESETROWPOS(AxeCount) = 0;\n\n    M_RESETROWPOS(RoadCover) = M_RESETROWPOS(0) = M_RESETROWPOS(Slopes) =\n                                   M_RESETROWPOS(Curves) = M_RESETROWPOS(Barriers) = M_RESETROWPOS(MoundH) =\n                                           M_RESETROWPOS(Axe) = M_RESETROWPOS(Sidewalks) = M_RESETROWPOS(AddRow) = -1;\n\n    iBottomArtifacts = iProfileTop = iGraphic = -1 ;\n\n    tableTop.drawHeaders = form->ExportMakeHeader;\n    tableBottom.drawHeaders = form->ExportMakeHeader;\n\n    int count = 0, i;\n\n    HeaderTextHeight = form->HeaderTextHeight;\n    strInfoTemplate = form->EditInfoTemplate;\n    strProjectBarrierPrefix = form->EditProjectBarrierPrefix;\n\n    tableTop.RowHeight = form->RowHeight;\n    tableTop.HeaderWidth = form->ExportMakeHeader ? form->HeaderWidth : 0;\n    tableTop.AutoShrinkOneLetterWidth = form->AutoShrinkOneLetterWidth;\n\n\n\n    tableBottom.AutoShrinkOneLetterWidth = form->AutoShrinkOneLetterWidth;\n    tableBottom.RowHeight = form->RowHeight;\n    tableBottom.HeaderWidth = form->ExportMakeHeader ? form->HeaderWidth : 0;\n\n\n\n    tableGraphic.AutoShrinkOneLetterWidth = form->AutoShrinkOneLetterWidth;\n    tableGraphic.RowHeight = form->GrphRowHeight;\n    tableGraphic.HeaderWidth = form->ExportMakeHeader ? form->HeaderWidth : 0;\n\n\n    fBottomAddRowsWithoutData = fTopAddRowsWithoutData = form->ExportTopAddRowsWithoutData;\n    fShowAttachmentComments = form->ExportShowAttachmentComments;\n    fDrawMap = form->ExportDrawMap;\n\n    iMinBarrierSegmentLength = form->MinBarrierSegmentLength;\n    iProfileHatchScale = form->ProfileHatchScale;\n    iSidewalsHatchScale = form->SidewalksHatchScale;\n    iFillHatchScale = form->TableHatchScale;\n    strSidewalksHatch = form->EditSidewalksHatch;\n    strProfileHatch = form->EditProfileHatch;\n    tableTop.EmptyFill = form->EditTableHatch;\n    tableTop.EmptyFillScale = iFillHatchScale;\n    tableBottom.EmptyFill = form->EditTableHatch;\n    tableBottom.EmptyFillScale = iFillHatchScale;\n    tableGraphic.EmptyFill = form->EditTableHatch;\n    tableGraphic.EmptyFillScale = iFillHatchScale;\n    fFillProfile = !strProfileHatch.IsEmpty();\n\n    iStart = form->ExportSection ? 100 * form->Start : -1;\n    iEnd = form->ExportSection ? 100 * form->End : -1;\n\n    if (~iStart) {\n        tableBottom.FillGapsBegin = iStart;\n        tableTop.FillGapsBegin = iStart;\n    }\n\n    UnderTextYOffset = form->UnderTextYOffset;\n    UnderTextHeight = form->UnderTextHeight;\n    UnderTextYOffset = UnderTextHeight * 0.75;\n\n    AutoCAD.strLostBlocks = \"\";\n    lessForVerticalLabels = form->UseVerticalTextIfLess;\n\n    tableTop.lessForVerticalLabels = lessForVerticalLabels * 100;\n    tableBottom.lessForVerticalLabels = lessForVerticalLabels * 100;\n    tableGraphic.lessForVerticalLabels = lessForVerticalLabels * 100;\n\n    smallGridMarkHeight = form->SmallGridMarkHeight;\n\n    ScaleY = (float)form->ScaleY / 100;\n    ScaleYBlock = (float)form->ScaleYBlock / 100;\n    if (ScaleYBlock <= 0) ScaleYBlock = ScaleY;\n\n    profileHeight = form->RowHeight;\n\n    NotExistColor = form->NotExistsColor;\n\n    iTopAddRowsCount = ExportTopAddRows(form->EditTopAddRows, true);\n    form->setTopAddRowsCount(iTopAddRowsCount);\n\n    count += (~(iTopSidewalks = form->getTopRow(\"тротуары\"))) ? 1 : 0;\n    count += (~(iTopMoundH = form->getTopRow(\"высоты насыпи\"))) ? 1 : 0;\n    count += (~(iTopBarriers = form->getTopRow(\"дорожные ограждения и направляющие устр-ва\"))) ? 1 : 0;\n    count += (~(iTop0 = form->getTopRow(\"разметка осевая\"))) ? 1 : 0;\n    count += (~(iTopAxe = form->getTopRow(\"разметка от осевой\"))) ? 1 : 0;\n\n    if (~iTopAxe) {\n        iTopAxeCount = iMarkLinesTop ? iMarkLinesTop : form->TableRowLinesTop;\n        count += iTopAxeCount - 1;\n        iTopAxe += iTopAxeCount - 1;\n    }\n    count += (~(iProfileTop = form->getTopRow(\"продольный профиль\"))) ? 1 : 0;\n    count += (~(iTopCurves = form->getTopRow(\"кривые в плане\"))) ? 1 : 0;\n    count += (~(iTopSlopes = form->getTopRow(\"продольные уклоны\"))) ? 1 : 0;\n    count += (~(iTopRoadCover = form->getTopRow(\"тип покрытия\"))) ? 1 : 0;\n    count += (~(iTopAddRow = form->getTopRow(\"дополнительные строки\"))) ? iTopAddRowsCount : 0;\n\n    tableTop.RowsCount = count;\n\n    tableTop.LeftTop = AutoCADPoint(0, tableTop.TableHeight + form->RCenter + iRulerHeight);\n\n    tableTop.FillGaps[-1] = false;\n    if (iTopMoundH >= 0)tableTop.FillGaps[iTopMoundH] = false;\n    if (iTopBarriers >= 0)tableTop.FillGaps[iTopBarriers] = true;\n    if (iTop0 >= 0)tableTop.FillGaps[iTop0] = true;\n    if (iTopCurves >= 0)tableTop.FillGaps[iTopCurves] = false;\n    if (iTopSlopes >= 0)tableTop.FillGaps[iTopSlopes] = false;\n    if (iTopSidewalks >= 0)tableTop.FillGaps[iTopSidewalks] = true;\n\n    for (i = 0; i < iTopAxeCount; i++) {\n        tableTop.FillGaps[iTopAxe - i] = true;\n    }\n\n    if (!~iTopAddRow) {\n        for (i = iTopAddRow; i < iTopAddRow + iTopAddRowsCount; i++) {\n            tableTop.FillGaps[i] = true;\n        }\n    }\n\n    count = 0;\n\n    iBottomAddRowsCount = ExportBottomAddRows(form->EditTopAddRows, true);\n    form->setBottomAddRowsCount(iBottomAddRowsCount);\n\n    count += (~(iBottomSidewalks = form->getBottomRow(\"тротуары\"))) ? 1 : 0;\n    count += (~(iBottomMoundH = form->getBottomRow(\"высоты насыпи\"))) ? 1 : 0;\n    count += (~(iBottomBarriers = form->getBottomRow(\"дорожные ограждения и направляющие устр-ва\"))) ? 1 : 0;\n    count += (~(iBottom0 = form->getBottomRow(\"разметка осевая\"))) ? 1 : 0;\n    count += (~(iBottomAxe = form->getBottomRow(\"разметка от осевой\"))) ? 1 : 0;\n\n    if (~iBottomAxe) {\n        iBottomAxeCount = iMarkLinesBottom ? iMarkLinesBottom : form->TableRowLinesBottom;\n        count += iBottomAxeCount - 1;\n    }\n    count += (~(iBottomCurves = form->getBottomRow(\"кривые в плане\"))) ? 1 : 0;\n    count += (~(iBottomSurface = form->getBottomRow(\"тип покрытия\"))) ? 1 : 0;\n    count += (~(iBottomSlopes = form->getBottomRow(\"продольные уклоны\"))) ? 1 : 0;\n    count += (~(iBottomArtifacts = form->getBottomRow(\"искусственные сооружения\"))) ? 2 : 0; //две строки на искусс.сооруж.\n    count += (~(iBottomAddRow = form->getBottomRow(\"дополнительные строки\"))) ? iBottomAddRowsCount : 0;\n    tableBottom.RowsCount  = count;\n\n    tableBottom.RowsCount = maxBottomCountGraphic = tableBottom.RowsCount;\n    /*if(form->ExportGraphic) {\n    tableBottom.RowsCount = maxBottomCountGraphic + ExportGraphic(form->EditTopAddRows,true);\n    }else{\n    tableBottom.RowsCount = maxBottomCountGraphic;\n    }*/\n\n    tableBottom.FillGaps[-1] = false;\n    if (iBottomMoundH >= 0)tableBottom.FillGaps[iBottomMoundH] = false;\n    if (iBottomBarriers >= 0)tableBottom.FillGaps[iBottomBarriers] = true;\n    if (iBottom0 >= 0)tableBottom.FillGaps[iBottom0] = true;\n    if (iBottomCurves >= 0)tableBottom.FillGaps[iBottomCurves] = false;\n    if (iBottomSlopes >= 0)tableBottom.FillGaps[iBottomSlopes] = false;\n    if (iBottomSidewalks >= 0)tableBottom.FillGaps[iBottomSidewalks] = true;\n\n\n    tableBottom.LeftTop = AutoCADPoint(0, -form->RCenter);\n\n\n    for (i = 0; i < iBottomAxeCount; i++) {\n        tableBottom.FillGaps[iBottomAxe + i] = true;\n    }\n\n    for (i = iBottomAddRow; i < iBottomAddRowsCount + iBottomAddRow; i++) {\n        tableBottom.FillGaps[i] = true;\n    }\n\n    tableGraphic.RowsCount =  ExportGraphic(form->EditTopAddRows, true);\n    tableGraphic.LeftTop = AutoCADPoint(0, -form->RCenter - tableBottom.TableHeight);\n\n    iStep = form->Step;\n    return true;\n}\n\nbool __fastcall TAcadExport::FindPlacement(drect &r, char dir, bool store, TRoadObject *obj) {\n    map<drect, TRoadObject*>::iterator it = rectmap.find(r);\n    while (it != rectmap.end()) {\n        if (dir == 'L') {\n            long double dx = r.x1 - it->first.x0 + 1;\n            r.x1 -= dx;\n            r.x0 -= dx;\n        }\n        else if (dir == 'R') {\n            long double dx = it->first.x1 - r.x0 + 1;\n            r.x1 += dx;\n            r.x0 += dx;\n        }\n        else if (dir == 'D') {\n            long double dy = r.y1 - it->first.y0 + 1;\n            r.y1 -= dy;\n            r.y0 -= dy;\n        }\n        else if (dir == 'U') {\n            drect t = it->first;\n            long double dy = it->first.y1 - r.y0 + 1;\n            r.y1 += dy;\n            r.y0 += dy;\n        } else\n            return false;\n        it = rectmap.find(r);\n    }\n    if (store)\n        rectmap[r] = obj;\n    return true;\n}\n\n\nvoid __fastcall TAcadExport::SetLayerOrder(AnsiString LayerName, AnsiString order)\n{\n    AutoCAD.ActiveDocument->SendCommand(WideString(\"(setq ss (ssget \\\"x\\\" (list (cons 8 \\\"\" + LayerName + \"\\\"))))\\n\"));\n    AutoCAD.ActiveDocument->SendCommand(WideString(\"(command \\\"_draworder\\\" ss \\\"\\\" \\\"\" + order + \"\\\")\\n\"));\n}\n\nvoid __fastcall TAcadExport::EndDocument() {\n    rectmap.clear();\n    //AutoCAD.ActiveDocument->SendCommand(WideString(\"SAVETIME \" + IntToStr(iAutoSaveInterval) + \"\\n\"));\n    //AutoCAD.Application->ZoomAll();\n    SetLayerOrder(\"RoadMark\", \"_back\");\n    SetLayerOrder(\"Borders\", \"_back\");\n    SetLayerOrder(\"RoadSidewalks\", \"_back\");\n    SetLayerOrder(\"RoadPlan\", \"_back\");\n    SetLayerOrder(\"RoadTrafficLights\", \"_front\");\n    SetLayerOrder(\"RoadMetrics\", \"_back\");\n\n    AutoCAD.ActiveDocument->SendCommand(WideString(\"_.zoom _e\\n\"));\n\n    AnsiString strMessage = \"\";\n    if (!strSignsAbsent.IsEmpty() || !AutoCAD.strLostBlocks.IsEmpty()) {\n        strMessage += \"-=-=-=-=-=-=-=-=-\\nСледующие знаки отсутствуют:\" + strSignsAbsent;\n        strMessage += AutoCAD.strLostBlocks;\n        strMessage += \"\\n-=-=-=-=-=-=-=-=-\\n\";\n    }\n    if (!strMarkAbsent.IsEmpty()) {\n        strMessage += \"-=-=-=-=-=-=-=-=-\\nНе определены типы линий для:\" + strMarkAbsent + \"\\nсмотри табл. Classifier\\nClass_id = 55\";\n        strMessage += \"\\n-=-=-=-=-=-=-=-=-\\n\";\n    }\n    if (!strMessage.IsEmpty()) ShowMessage(strMessage);\n\n    if (fAlreadyDrawSignSpot) {\n        SignSpot1->Delete();\n        SignSpot1_m->Delete();\n        SignSpot2->Delete();\n    }\n    if (fAlreadyDrawTube) {\n        Tube->Delete();\n    }\n    AutoCAD.EnableAutoSave();\n}\n\nbool _fastcall TAcadExport::ExportProfil(TExtPolyline *Poly) {\n    if (fDrawMap) return true; // в редиме карты ничего не рисуем\n\n    int i, count;\n    double *points;\n    double maxDegree = (float)2.0f / 180.0f * 3.14f;\n\n    count = Poly->Count;\n    points = new double[(Poly->Count + 1) * 2];\n\n    TPoint p1, p2, p3;\n\n    list<TPoint> pts;\n    int step = 50;\n    for (i = 0; i < count; i += step) {\n        points[2 * i] = Poly->Points[i].x;\n        points[2 * i + 1] = Poly->Points[i].y + tableTop.LeftTop.y - tableTop.RowOffsetY(iProfileTop); // - tableTop.RowHeight;\n        pts.push_back(TPoint(points[2 * i], points[2 * i + 1]));\n    }\n\n    points[2 * count] = Poly->Points[0].x;\n    points[2 * count + 1] = Poly->Points[0].y;\n\n    float angle;\n    int size = pts.size();\n\n    list<TPoint>::iterator it1, it2, it3, it;\n\n    delete[] points;\n\n    size = pts.size();\n    points = new double[size * 2 + 4];\n    for (i = 0, it = pts.begin(); it != pts.end(); ++it, ++i) {\n        points[2 * i] = it->x;\n        points[2 * i + 1] = it->y;\n    }\n    points[size * 2] = points[size * 2 - 2];\n    points[size * 2 + 1] = tableTop.LeftTop.y - tableTop.RowOffsetY(iProfileTop) - tableTop.RowHeight;\n    points[size * 2 + 2] = points[0];\n    points[size * 2 + 3] = points[size * 2 + 1];\n\n    AcadPolylinePtr plines[1];\n\n    plines[0] = AutoCAD.DrawPolyLine(&points[0], size + 2, 2);\n\n    if (fFillProfile) {\n        AcadHatchPtr hatch;\n        hatch = AutoCAD.FillArea((IDispatch**)plines, 1, 0, strProfileHatch);\n        hatch->PatternScale = iProfileHatchScale;\n    }\n\n    delete[] points;\n    return plines[0];\n}\n\nbool __fastcall TAcadExport::ExportRoadMetric(TExtPolyline *Poly, TMetricsKind kind, bool fEnd) {\n    //if (kind==mkBrovka)\n    //   Poly->Count\n    //   Poly->Points[i].X -- координата по ширине\n    //   Poly->Points[i].L -- координата по длине\n    //   Poly->Codes[i]&1  Код видимости до i-той точки 1 - видимый, 0 - невидимый\n    //   Координаты целые в сантиметрах!\n    if (fEnd) {\n        if (smallGridMarkHeight != 0 && !fDrawMap) {\n            int step = 10000;\n            for (int i = (curRoad->LMin / step) * step; i < curRoad->LMax; i += step) {\n                AcadLinePtr line = AutoCAD.DrawLine(i, -smallGridMarkHeight / 2, i, smallGridMarkHeight / 2);\n                line->color = 8;\n                line->set_Lineweight(acLnWt030);\n            }\n        }\n        return true;\n    }\n    switch (kind) {\n    case mkBrovka:\n        DrawPolyPoints(Poly);\n        break;\n    case mkKromka:\n        DrawPolyPoints(Poly);\n        break;\n    case mkDivPart:\n        DrawPolyPoints(Poly, false, false);\n        break;\n    case mkSafeZone:\n        DrawPolyPoints(Poly, false, true);\n        break;\n    default:\n        BUILDER_INFO(\"Неизвестный тип метрики: \" << kind);\n        DrawPolyPoints(Poly);\n    }\n\n    return true;\n}\n\n\nbool __fastcall TAcadExport::ExportAttach(TExtPolyline *Poly, TRoadAttach *a, bool fEnd) {\n\n    if (fEnd) {\n        return true;\n    }\n\n    // ищем минимальную и максимальную точку по Y у примыкания\n    int maxY = abs(Poly->Points[0].y);\n    int minY = abs(Poly->Points[0].y);\n    int iLast, i;\n    TPoint pMax = Poly->Points[0], pMin = Poly->Points[0];\n    for (i = 1; i < Poly->Count; ++i) {\n        if (abs(Poly->Points[i].y) > maxY ) {\n            maxY = abs(Poly->Points[i].y);\n            pMax = Poly->Points[i];\n        }\n        if (abs(Poly->Points[i].y) < minY ) {\n            minY = abs(Poly->Points[i].y);\n            pMin = Poly->Points[i];\n        }\n    }\n\n    // вывод комментария\n    if (fShowAttachmentComments) {\n        vector<AnsiString> strings;\n        AnsiString str = a->Comment;\n        str = StringReplace(str, \"\\\\n\", \"\\n\", TReplaceFlags() << rfReplaceAll);\n        for (iLast = 1, i = 1; i < str.Length(); ++i) {\n            if (str[i] == '\\n') {\n                strings.push_back(str.SubString(iLast, i - iLast));\n                iLast = i + 1;\n            }\n        }\n        strings.push_back(str.SubString(iLast, i - iLast + 1));\n\n        for (i = 1; i <= strings.size(); ++i) {\n            if (pMax.y > 0) {\n                if (!strings[i - 1].IsEmpty()) {\n                    AutoCAD.DrawText(strings[i - 1],\n                                     UnderTextHeight,\n                                     acAlignmentTopCenter,\n                                     a->L,\n                                     -ScaleY * (pMax.y) - i * UnderTextYOffset - (i - 1)*UnderTextHeight);\n                }\n            } else {\n                if (!strings[i - 1].IsEmpty()) {\n                    AutoCAD.DrawText(strings[i - 1], UnderTextHeight, acAlignmentBottomCenter ,\n                                     a->L, -ScaleY * (pMax.y) + (strings.size() - i)*UnderTextYOffset + (strings.size() - i + 1)*UnderTextHeight);\n                }\n            }\n        }\n    }\n\n\n    // вывод названия примыкания\n\n    if (a->Name != \"\") {\n        AutoCAD.DrawText(a->Name,\n                         UnderTextHeight,\n                         acAlignmentMiddleLeft,\n                         pMin.x + (pMax.x - pMin.x) / 2,\n                         -ScaleY * (pMin.y + (pMax.y - pMin.y) / 2),\n                         Helpers::GetAngle2(pMin, pMax, ScaleY)\n                        );\n    }\n\n    DrawPolyPoints(Poly);\n\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportSigns(TExtPolyline* Poly,  TRoadSign** signs, int count, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n\n    if (~iStart) {\n        if (Poly->Points[0].x < iStart) return true;\n    }\n    if (~iEnd) {\n        if (Poly->Points[0].x > iEnd) return true;\n    }\n    if (count == 0) {\n        return true;\n    }\n\n    double scale = ScaleYBlock * 50;\n    int signSpotOffset = 19;\n\n    /// создавать новый объект signspot сильно нарпяжно, так что создадим его один раз\n    /// а потом будем все время копировать\n    if (!fAlreadyDrawSignSpot) {\n        SignsPositions.clear(); // так как процедура совершается, как правило в\n        // начале, то почистим список позиций знаков\n        SignSpot1 = AutoCAD.DrawBlock(\"signspot\", 0, 0, 0, scale);\n        if (!AutoCAD.SetPropertyPoint(SignSpot1, \"pHand\", AutoCADPoint(0, 0)))\n            return false;\n\n        SignSpot1_m = AutoCAD.DrawBlock(\"signspot_m\", 0, 0, 0, scale);\n        if (!AutoCAD.SetPropertyPoint(SignSpot1_m, \"pHand\", AutoCADPoint(0, 0)))\n            return false;\n\n        SignSpot2 = AutoCAD.DrawBlock(\"signspot2\", 0, 0, 0, scale);\n        if (!AutoCAD.SetPropertyPoint(SignSpot2, \"pHand\", AutoCADPoint(0, 0)))\n            return false;\n\n        fAlreadyDrawSignSpot = true;\n    }\n\n    // парные знаки\n    AnsiString signsPair[][2] = {\n        {\"5.19.1\", \"5.19.2\"},\n        {\"5.16\", \"5.16\"},\n        {\"5.17\", \"5.17\"},\n        {\"5.21\", \"5.22\"}\n    };\n    int signsPairCount = sizeof(signsPair) / sizeof(signsPair[0]);\n    vector<TRoadSign*> direct;\n    vector<TRoadSign*> undirect;\n    vector<TRoadSign*> onRoad;\n    vector<TRoadSign*> onAttachment;\n\n    if (count >= 2) {\n        // разбиваем на группы: знаки на примыканиях и знаки на главной дороге\n        for (int i = 0; i < count; ++i) {\n            TRoadSign *s = signs[i];\n            if (s->OnAttach && s->OnAttach != saRoad) {\n                onAttachment.push_back(s);\n            } else {\n                onRoad.push_back(s);\n            }\n        }\n\n        if (onAttachment.size() == 0 || onRoad.size() == 0) {\n            // все знаки либо на примыканиях, либо на главной дороге\n            // можно ничего не делать\n            bool fAllOnRoad = onRoad.size() > 0;\n            // разбиваем на группы по направлениям\n            if (onRoad.size() > 0) {\n                for (int i = 0; i < onRoad.size(); ++i) {\n                    TRoadSign* s = onRoad[i];\n                    switch (s->Direction) {\n                    case roUnDirect:\n                        undirect.push_back(s);\n                        break;\n                    default:\n                        direct.push_back(s);\n                    }\n                }\n            } else {\n                for (int i = 0; i < onAttachment.size(); ++i) {\n                    TRoadSign* s = onAttachment[i];\n                    switch (s->OnAttach) {\n                    case saOut:\n                        switch (s->Direction) {\n                        case roUnDirect:\n                            direct.push_back(s);\n                            break;\n                        default:\n                            undirect.push_back(s);\n                        }\n                        break;\n                    default:\n                        switch (s->Direction) {\n                        case roUnDirect:\n                            undirect.push_back(s);\n                            break;\n                        default:\n                            direct.push_back(s);\n                        }\n                    }\n                }\n            }\n            // ищем парные знаки и переносим их из обратного в прямое направление\n            bool wasPair = false;\n            for (int i = 0; i < direct.size(); ++i) {\n                TRoadSign* s = direct[i];\n                for (int j = 0; j < signsPairCount; ++j) {\n                    if (s->OldTitle == signsPair[j][0]) {\n                        for (int k = 0; k < undirect.size(); ++k) {\n                            TRoadSign* s2 = undirect[k];\n                            if (s2->OldTitle == signsPair[j][1]) {\n                                direct.push_back(s2);\n                                undirect.erase(undirect.begin() + k);\n                                --k;\n                                wasPair = true;\n                            }\n                        }\n                    } else if (s->OldTitle == signsPair[j][1]) {\n                        for (int k = 0; k < undirect.size(); ++k) {\n                            TRoadSign* s2 = undirect[k];\n                            if (s2->OldTitle == signsPair[j][0]) {\n                                direct.push_back(s2);\n                                undirect.erase(undirect.begin() + k);\n                                --k;\n                                wasPair = true;\n                            }\n                        }\n                    }\n                }\n            }\n            if (wasPair && direct.size() == 2 && undirect.size() == 1) {\n                // комбинация парные знаки и один в противоположном направленнии\n                // подклеиваем пару к противоположному направлению\n                undirect.push_back(direct[0]);\n                undirect.push_back(direct[1]);\n                direct.clear();\n                sort(undirect.begin(), undirect.end(), Helpers::compareSigns);\n                signs = undirect.begin();\n            } else if (direct.size() == 0 || undirect.size() == 0) {\n                // если все знаки в одном нарпавлении\n                if (direct.size() > 0) {\n                    sort(direct.begin(), direct.end(), Helpers::compareSigns);\n                    signs = direct.begin();\n                }\n                if (undirect.size() > 0) {\n                    sort(undirect.begin(), undirect.end(), Helpers::compareSigns);\n                    signs = undirect.begin();\n                }\n            } else {\n                // остальные случаи сводим к предыдущим двум\n                ExportSigns(Poly, direct.begin(), direct.size(), fEnd);\n                ExportSigns(Poly, undirect.begin(), undirect.size(), fEnd);\n                return true;\n            }\n        } else {\n            // выводим каждую группу отдельно\n            ExportSigns(Poly, onAttachment.begin(), onAttachment.size(), fEnd);\n            ExportSigns(Poly, onRoad.begin(), onRoad.size(), fEnd);\n            return true;\n        }\n    }\n\n    double yoffset = 20;\n    bool ffind, fOnAttachment = false;\n    int i;\n    AnsiString strings[4];\n    AcadBlockPtr block;\n    AcadBlockReferencePtr signspot = SignSpot1;\n    double rotation = 0, rotationHandle = 0;\n\n    switch (signs[0]->OnAttach) {\n    case saIn:\n    case saOut:\n        signSpotOffset = 10;\n        break;\n    }\n\n    if (true) {\n        // настраиваем корректный поворот знаков\n        switch (signs[0]->Direction) {\n        case roDirect:\n            switch (signs[0]->Placement) {\n            case spRight:\n                switch (signs[0]->OnAttach) {\n                case saIn:\n                    rotationHandle = -M_PI / 2;\n                    rotation = M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                case saOut:\n                    rotationHandle = -M_PI / 2;\n                    rotation = -M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                default:\n                    rotationHandle = -M_PI / 2;\n                    signspot = SignSpot1;\n                }\n                break;\n            case spBetween:\n            case spUp:\n            case spLeft:\n                switch (signs[0]->OnAttach) {\n                case saIn:\n                    rotationHandle = M_PI / 2;\n                    rotation = M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                case saOut:\n                    rotationHandle = M_PI / 2;\n                    rotation = -M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                default:\n                    rotationHandle = M_PI / 2;\n                    rotation = 0;\n                    signspot = SignSpot1_m;\n                }\n                break;\n            default:\n                BUILDER_ERROR(\"Не могу определить угол поворота знака \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x);\n            }\n            break;\n        case roUnDirect:\n            switch (signs[0]->Placement) {\n            case spRight:\n                switch (signs[0]->OnAttach) {\n                case saIn:\n                    rotationHandle = M_PI / 2;\n                    rotation = M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                case saOut:\n                    rotationHandle = M_PI / 2;\n                    rotation = -M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                default:\n                    rotationHandle = M_PI / 2;\n                    signspot = SignSpot1;\n                }\n                break;\n            case spBetween:\n            case spUp:\n            case spLeft:\n                switch (signs[0]->OnAttach) {\n                case saIn:\n                    rotationHandle = -M_PI / 2;\n                    rotation = M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                case saOut:\n                    rotationHandle = -M_PI / 2;\n                    rotation = -M_PI / 2;\n                    signspot = SignSpot2;\n                    fOnAttachment = true;\n                    break;\n                default:\n                    rotationHandle = -M_PI / 2;\n                    rotation = 0;\n                    signspot = SignSpot1_m;\n                }\n                break;\n            default:\n                BUILDER_ERROR(\"Не могу определить угол поворота знака \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x);\n            }\n            break;\n        }\n\n\n\n        switch (signs[0]->Placement) {\n        case spBetween:\n        case spUp:\n            switch (signs[0]->OnAttach) {\n            case saIn:\n            case saOut:\n                break;\n            default:\n                rotationHandle *= -1;\n                if (signs[0]->Placement == spUp) {\n                    signspot = SignSpot2;\n                    rotationHandle -= M_PI / 2;\n                    rotation += M_PI / 2;\n                    signSpotOffset = 9;\n                } else {\n                    signspot = SignSpot1;\n                }\n                break;\n            }\n        }\n    }\n\n    if (fDrawMap) {\n        if (Poly->Count == 2) {\n            double angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n\n            rotationHandle += angle;\n            //rotation += angle;\n\n            switch (signs[0]->Direction) {\n            case roUnDirect:\n                //rotation += M_PI;\n                switch (signs[0]->Placement) {\n                case spRight:\n                    rotationHandle += M_PI;\n                    break;\n                }\n                break;\n            case roDirect:\n                switch (signs[0]->Placement) {\n                case spLeft:\n                    rotationHandle -= M_PI;\n                    break;\n                }\n                break;\n            }\n\n            switch (signs[0]->OnAttach) {\n            case saIn:\n                //rotation -= M_PI_2;\n                rotationHandle -= M_PI_2;\n                break;\n            case saOut:\n                switch (signs[0]->Direction) {\n                case roUnDirect:\n                    //rotation += M_PI_2;\n                    //rotationHandle += M_PI_2;\n                    break;\n                }\n\n                break;\n            }\n\n            switch (signs[0]->Placement) {\n            case spUp:\n                //rotationHandle -= M_PI_2;\n                break;\n            }\n        }\n    }\n\n    AnsiString sEmpty = \"\";\n\n    try {\n        if (count == 1) {\n            try {\n                DrawSign(\n                    signs[0]->OldTitle + (signs[0]->ViewKind == 0 ? sEmpty : AnsiString(\".\" + IntToStr(signs[0]->ViewKind))),\n                    signs[0]->Label,\n                    AutoCADPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y),\n                    signs[0]->L,\n                    signSpotOffset,\n                    0,\n                    rotation,\n                    rotationHandle,\n                    scale,\n                    fOnAttachment,\n                    signspot,\n                    signs[0]->Placement == spUp);\n            } catch (...) {\n                if (!strSignsAbsent.Pos(signs[0]->OldTitle))strSignsAbsent += \"\\n\" + signs[0]->OldTitle;\n            }\n        } else {\n            vector<WideString> blockNames;\n            vector<WideString> labels;\n            for (int i = 0; i < count; ++i) {\n                blockNames.push_back(signs[i]->OldTitle + (signs[i]->ViewKind == 0 ? sEmpty : AnsiString(\".\" + IntToStr(signs[i]->ViewKind))));\n                labels.push_back(signs[i]->Label);\n            }\n            block = AutoCAD.MakeCombineBlock(blockNames, labels);\n            if (block.IsBound()) {\n                DrawSign(block->Name,\n                         \"\",\n                         AutoCADPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y),\n                         signs[0]->L,\n                         signSpotOffset,\n                         0,\n                         rotation,\n                         rotationHandle,\n                         scale,\n                         fOnAttachment,\n                         signspot,\n                         signs[0]->Placement == spUp);\n            }\n        }\n    } catch (...) {\n        BUILDER_ERROR(\"Ошибка вывода знака: \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x );\n        return false;\n    }\n    return true;\n}\n\n// возвращает кол-во знаков лежащих\n// около позиции pos, в пределах radius\nint TAcadExport::findSignSuperposition(TPoint pos, int radius)\n{\n    int counter = 0;\n    for (vector<TPoint>::iterator it = SignsPositions.begin(); it != SignsPositions.end(); ++it) {\n        TPoint temp = *it - pos;\n        if (abs(temp.x) < radius && abs(temp.y) < radius )\n            counter++;\n\n    }\n    return counter;\n}\n\n/// name - нзвание знака\n/// label - надпись на знаке\n/// pos - положение знака\n/// xoffset - cдвиг знака относительно pos.x\n/// yoffset - cдвиг знака относительно pos.y\n/// rotation - поворот знака\n/// rotationHandle - поворот сноски, знак будет крепиться к сноске\n/// scale - масштабирование\n/// fOnAttachment - знак находится на примыкании (то есть на въезде или выезде),\n///                 поставить True если на примыкании\nvoid TAcadExport::DrawSign(\n    AnsiString Name,\n    AnsiString label,\n    AutoCADPoint pos,\n    int LPos,\n    int xoffset,\n    int yoffset,\n    double rotation,\n    double rotationHandle,\n    double scale,\n    bool fOnAttachment,\n    AcadBlockReferencePtr &signspot,\n    bool fUnderRoad\n)\n{\n    static AcadBlockReferencePtr block;\n    static AutoCADPoint newPos;\n    static int _pos;\n    static int txOffset, tyOffset;\n    xoffset *= scale;\n    yoffset *= scale;\n\n    if (fDrawMap) {\n        _pos = LPos / 100;\n    } else {\n        if (Name == \"6.13\") {\n            int sPos;\n            sPos = label.Pos(\"-\");\n            sPos = sPos == 0 ? label.Length() + 1 : sPos;\n            if (fAuto6_13) {\n                if (TryStrToInt(label.SubString(1, sPos - 1), sPos)) {\n                    pos.x = sPos * 100000;\n                } else {\n                    pos.x = RoundTo((float)pos.x / 100000, 0) * 100000;\n                }\n                _pos = 0;\n            } else {\n                _pos = (int)LPos % 100000 / 100;\n            }\n            if (fLeftValueOnly6_13) {\n                label = label.SubString(1, sPos - 1);\n            }\n        } else {\n            _pos = (int)LPos % 100000 / 100;\n        }\n    }\n\n    txOffset = xoffset;\n    tyOffset = yoffset;\n\n    IAcadSelectionSet *set = AutoCAD.ActiveDocument->ActiveSelectionSet;\n    set->Clear();\n\n    // копируем сноску\n    block = signspot->Copy();\n    AutoCAD.SetAttribute(block, \"LABEL\", AnsiString(_pos));\n    // поворачиваем сноску\n    block->set_Rotation(rotationHandle);\n\n    // чтобы за край не уходили\n    float posOffset = 0.25 * ScaleY;\n    if (!fUnderRoad && !fDrawMap) {\n        int framePos = (LPos / 100) % (iStep / 100);\n        if (framePos <= 30 * posOffset) {\n            tyOffset += (rotationHandle == -M_PI / 2) ? 3000 * posOffset : -3000 * posOffset;\n        } else if ( (iStep / 100) - framePos <= 30 * posOffset ) {\n            tyOffset += (rotationHandle == -M_PI / 2) ? -3000 * posOffset : 3000 * posOffset;\n        }\n    }\n\n    //if (fUnderRoad || fOnAttachment) {\n    //    tyOffset += 500 * posOffset;\n    //}\n    // чтобы не было наложений, наложенные знаки сдивгаем вправо\n    int countOfSignsNearCurrent;\n    countOfSignsNearCurrent = findSignSuperposition(TPoint(pos.x, pos.y) , 1000 * posOffset);\n    if ( countOfSignsNearCurrent > 0 ) {\n        if (fOnAttachment) {\n            txOffset -= 1000 * countOfSignsNearCurrent * posOffset;\n        } else {\n            tyOffset += 1000 * countOfSignsNearCurrent * posOffset;\n        }\n    }\n\n    // запомним положение знака\n    SignsPositions.push_back(TPoint(pos.x, pos.y) );\n\n    // поставим сноску и сдвинем ее хвостик\n    //AutoCAD.SetPropertyDouble(block,\"Length\",1200);\n    block->set_InsertionPoint(AutoCAD.cadPoint(int(pos.x), int(pos.y)));\n    AutoCAD.SetPropertyPoint(block, \"pHand\", AutoCADPoint(txOffset, tyOffset));\n\n    // собственно рисуем знак\n    //block = AutoCAD.DrawBlock(Name,int(newPos.x),int(newPos.y),rotation,scale);\n    block = AutoCAD.DrawBlock(Name, int(txOffset), int(tyOffset), rotation, scale);\n    // поворачиваем блок относительно центра\n    block->Rotate(AutoCAD.cadPoint(0, 0), rotationHandle);\n    block->Move(AutoCAD.cadPoint(0, 0), AutoCAD.cadPoint(int(pos.x), int(pos.y)));\n    if (block.IsBound()) {\n        SetAttributes(block, Helpers::SignLabelParser(Name, label));\n        if (Name.Pos(\"6.10.1\") || Name.Pos(\"6.10.2\") || Name.Pos(\"6.9.1\") || Name.Pos(\"6.9.2\")) {\n            block->color = 5; /*синий цвет знакам*/\n        }\n    }\n\n}\n\nvoid TAcadExport::SetAttributes(AcadBlockReferencePtr block, AnsiString labels)\n{\n    int count = 1, last = 0, i;\n    int length = labels.Length();\n\n    for (i = 1; i <= length; i++) {\n        if (labels[i] == '\\\\') {\n            switch (count) {\n            case 1:\n                AutoCAD.SetAttribute(block, \"LABEL\", labels.SubString(last + 1, (i - last - 1)).UpperCase());\n                break;\n            case 2:\n                AutoCAD.SetAttribute(block, \"LABEL1\", labels.SubString(last + 1, (i - last - 1)).UpperCase());\n                break;\n\n            case 3:\n                AutoCAD.SetAttribute(block, \"LABEL1\", labels.SubString(last + 1, (i - last - 1)).UpperCase());\n                break;\n            }\n            count++;\n            last = i;\n            if (count == 3)\n                break;\n        }\n    }\n    switch (count) {\n    case 1:\n        AutoCAD.SetAttribute(block, \"LABEL\", labels.SubString(last + 1, (length - last)).UpperCase());\n        break;\n\n    case 2:\n        AutoCAD.SetAttribute(block, \"LABEL1\", labels.SubString(last + 1, (length - last)).UpperCase());\n        break;\n\n    case 3:\n        AutoCAD.SetAttribute(block, \"LABEL2\", labels.SubString(last + 1, (length - last)).UpperCase());\n        break;\n    }\n}\n\n\n\nbool __fastcall TAcadExport::ExportSign(TExtPolyline *Poly, TRoadSign *s, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n    return true;\n}\n\n\nTPoint __fastcall TAcadExport::GetCenterOnPolyline(\n    TExtPolyline *p, int minx, int maxx, float* out_angle, int *width_of_sector, TPoint* pointStart, TPoint* pointEnd)\n{\n    float length, k;\n    int i1 = 0,\n        i2 = p->Count - 1;\n    TPoint pEnd, pStart, pOffset;\n    std::vector<TPoint> Points;\n    for (int i = 0; i < p->Count; ++i) {\n        int j = i;\n\n        if (p->Points[0].x > p->Points[p->Count - 1].x) {\n            j = p->Count - j - 1;\n        }\n        Points.push_back(p->Points[j]);\n    }\n\n    if (Points[i1].x < minx && minx != maxx) {\n        i1 = -1;\n        for (int i = 1; i < Points.size(); ++i) {\n            if (Points[i].x > minx) {\n                i1 = i - 1;\n                break;\n            }\n        }\n        if (i1 == -1) {\n            return TPoint(-1, -1);\n        }\n    }\n\n    if (Points[i2].x > maxx && minx != maxx) {\n        i2 = -1;\n        for (int i = Points.size() - 2; i >= 0; --i) {\n            if (Points[i].x < maxx) {\n                i2 = i + 1;\n                break;\n            }\n        }\n        if (i2 == -1) {\n            return TPoint(-1, -1);\n        }\n    }\n\n    pStart = Points[i1];\n    pEnd = Points[i2];\n\n    if (pStart.x < minx && minx != maxx) {\n        k = 1;\n        pOffset.x = Points[i1 + 1].x - Points[i1].x;\n        pOffset.y = Points[i1 + 1].y - Points[i1].y;\n        k = (float) (minx - pStart.x) / pOffset.x;\n        pStart.x += pOffset.x * k + 1;\n        pStart.y += pOffset.y * k;\n    }\n\n    if (pEnd.x > maxx && minx != maxx) {\n        k = 1;\n        pOffset.x = Points[i2].x - Points[i2 - 1].x;\n        pOffset.y = Points[i2].y - Points[i2 - 1].y;\n        k = (float) (pEnd.x - maxx) / pOffset.x;\n        pEnd.x -= pOffset.x * k - 1;\n        pEnd.y -= pOffset.y * k;\n    }\n\n    int centerX = (pEnd.x + pStart.x) / 2;\n\n    for (int i = i1; i < i2; ++i) {\n        TPoint p1 = Points[i];\n        TPoint p2 = Points[i + 1];\n        if (i == i1) p1 = pStart;\n        if (i == i2 - 1) p2 = pEnd;\n        if (p1.x < centerX && centerX < p2.x) {\n            k = 1;\n            if (out_angle) {\n                *out_angle = Helpers::GetAngle2(p1, p2, ScaleY);\n            }\n            if (width_of_sector) {\n                *width_of_sector = pEnd.x - pStart.x;\n            }\n            if (pointStart) {\n                *pointStart = pStart;\n            }\n            if (pointEnd) {\n                *pointEnd = pEnd;\n            }\n            k = (float) (centerX - p1.x) / (p2.x - p1.x);\n            return TPoint(p1.x + (p2.x - p1.x) * k, p1.y + (p2.y - p1.y) * k);\n        }\n    }\n    return TPoint(-1, -1);\n}\n\nvoid __fastcall TAcadExport::DrawTextUnderLine(TPoint p1, TPoint p2, AnsiString text)\n{\n    TPoint centerPoint;\n    float kUnderTextHeight = 1;\n    float angle = Helpers::GetAngle2(p1, p2, ScaleY);\n    centerPoint.x = (p1.x + p2.x) / 2;\n    centerPoint.y = (p1.y + p2.y) / 2;\n    AutoCAD.DrawText(text, kUnderTextHeight * UnderTextHeight, acAlignmentBottomCenter,  centerPoint.x, -ScaleY * centerPoint.y, angle);\n}\n\nvoid __fastcall TAcadExport::DrawTextOverPoly(TExtPolyline *Poly, AnsiString text,\n        AnsiString(__closure *textControlFunction)(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data), void* data)\n{\n    int lastStep, curStep;\n    float angle;\n    int width_of_sector;\n    float kUnderTextHeight = 1;\n\n    int ilastStepPoint = 0;\n    AnsiString str;\n    TPoint centerPoint, pStart, pEnd;\n\n    if (!fDrawMap) {\n        curStep = lastStep = Poly->Points[0].x / iStep;\n        for (int i = 1; i < Poly->Count; ++i) {\n            curStep = Poly->Points[i].x / iStep;\n\n            if (curStep != lastStep) {\n                int iMin = curStep\n                centerPoint = GetCenterOnPolyline(Poly, lastStep * iStep, (lastStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n                if (centerPoint.x != -1) {\n                    str = text;\n                    if (textControlFunction) {\n                        str = textControlFunction(text, pStart, pEnd, centerPoint, angle, data);\n                    }\n                    if (!str.IsEmpty()) {\n                        AutoCAD.DrawText(\n                            str,\n                            kUnderTextHeight * UnderTextHeight,\n                            acAlignmentBottomCenter,\n                            centerPoint.x,\n                            -ScaleY * centerPoint.y,\n                            angle\n                        );\n                    }\n                }\n                lastStep = curStep;\n            }\n        }\n        centerPoint = GetCenterOnPolyline(Poly, curStep * iStep, (curStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n    } else {\n        centerPoint = GetCenterOnPolyline(Poly, -1, -1, &angle, &width_of_sector, &pStart, &pEnd);\n    }\n\n    if (centerPoint.x != -1) {\n        str = text;\n        if (textControlFunction) {\n            str = textControlFunction(text, pStart, pEnd, centerPoint, angle, data);\n        }\n        if (!str.IsEmpty()) {\n            AutoCAD.DrawText(str,\n                             kUnderTextHeight * UnderTextHeight,\n                             acAlignmentBottomCenter,\n                             centerPoint.x,\n                             -ScaleY * centerPoint.y,\n                             angle);\n        }\n    }\n}\n\nAnsiString TAcadExport::RoadMarkTextDraw(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data)\n{\n    AnsiString str = text;\n    float kUnderTextHeight = 1, kEdgeLines = 0.5;\n    TRoadMark* m = (TRoadMark*)data;\n\n    int start, end;\n    if (fDrawMap && m) {\n        start = m->LMin / 100;\n        end = m->LMax / 100;\n    } else {\n        start = (pStart.x / 100) % 1000;\n        end = (pEnd.x / 100) % 1000;\n    }\n    end = end == 0 ? 1000 : end;\n    int length = end - start;\n\n    if (length >= 10) {\n        str.sprintf(\"%s(%d)\", text, length);\n        if (length < 20) {\n            kUnderTextHeight *= (float)length / 20;\n        }\n    } else {\n        kUnderTextHeight = 0.6;\n    }\n    float kPositionMarksHeight = kUnderTextHeight * 0.75;\n    float scale = ScaleYBlock / 4;\n\n    AutoCAD.DrawText(str,\n                     kUnderTextHeight * UnderTextHeight * scale,\n                     centerPoint.y > 0 ? acAlignmentBottomCenter : acAlignmentTopCenter,\n                     centerPoint.x,\n                     -ScaleY * centerPoint.y + (centerPoint.y > 0 ? scale : -scale) * UnderTextYOffset * kEdgeLines,\n                     angle);\n\n    if (length >= 15 && start != 0 && start != 1000 && start != iStep / 100) {\n        AutoCAD.DrawText(IntToStr(start),\n                         kPositionMarksHeight * UnderTextHeight * ScaleYBlock / 3.5,\n                         centerPoint.y > 0 ? acAlignmentTopLeft : acAlignmentTopRight,\n                         pStart.x + 100 * scale,\n                         -ScaleY * pStart.y + (centerPoint.y > 0 ? scale : -scale) * UnderTextYOffset * kEdgeLines,\n                         M_PI_2 + angle);\n    }\n    /*if (length >= 15 && end != 0 && end != 1000 && start != iStep / 100) {\n        AutoCAD.DrawText(IntToStr(end),\n                         kPositionMarksHeight * UnderTextHeight,\n                         acAlignmentMiddleLeft,\n                         pEnd.x,\n                         -ScaleY*pEnd.y + UnderTextYOffset * kEdgeLines,\n                         angle + M_PI_2);\n    }*/\n    return \"\";\n}\n\n// Миша, взять код разметки можно так\n// TPlanLabel *l=m->GetText(0);\n// String s=l->Caption;\n// после окончания обработки надо удалять l\n// delete l;\n// line это номер линии (0 - осевая 1,2 - номера справа -1,-2 - слева\n// 100 - разметка не на линиях\nAcadPolylinePtr TAcadExport::DrawRoadMark(TRoadMark *m, TExtPolyline *Poly, AnsiString name,\n        int iRow, int line, AutoCADTable *table, bool dontDrawPolyLine)\n{\n    AcadPolylinePtr pl;\n    float Min, Max, angle;\n    int iMaxY, MaxY;\n    int count = Poly->Count;\n    float kEdgeLines = 0.5;\n\n    if (fDrawMap) table = NULL; // в режиме карты в таблице ничего не рисуем\n\n    if (count > 1) { // are there any points to draw?\n        if (!dontDrawPolyLine) {\n            pl = DrawPolyPoints(Poly, false);\n        }\n\n        if (Poly->Points[0].x > Poly->Points[count - 1].x) {\n            Min = Poly->Points[count - 1].x;\n            Max = Poly->Points[0].x;\n        } else {\n            Max = Poly->Points[count - 1].x;\n            Min = Poly->Points[0].x;\n        }\n        if (abs(Poly->Points[0].y) > abs(Poly->Points[count - 1].y)) {\n            iMaxY = 0;\n        } else {\n            iMaxY = count - 1;\n        }\n\n        if (iRow != -1 || fDrawMap) { // if we draw road mark on common road\n            int yOffset;\n            // fill rows in tables\n            if (table && line != 0) { // if we draw lines over central\n                table->DrawRepeatTextIntervalRoadMark(iRow, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n            } else { // if we draw central line\n                tableTop.DrawRepeatTextIntervalRoadMark(iTop0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n                tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n            }\n            if ( line >= 0 ) {\n                yOffset = -ScaleY * (Poly->Points[(Poly->Count) / 2 - (Poly->Count % 2 ? 0 : 1)].y) + UnderTextYOffset;\n            } else {\n                yOffset = -ScaleY * (Poly->Points[(Poly->Count) / 2 - (Poly->Count % 2 ? 0 : 1)].y) - UnderTextYOffset;\n            }\n\n            AnsiString label_under_mark = name;\n\n            float kUnderTextHeight = ScaleY / 3.5;\n            if (Max - Min < 750) {\n                kUnderTextHeight = 0.6 * ScaleY / 3.5;\n            }\n            DrawTextOverPoly(Poly, label_under_mark, RoadMarkTextDraw, m);\n\n        } else { // if we draw road mark on attachments\n            AcadTextPtr text;\n            // we should recalculate angle of text, to draw it properly\n            if (iMaxY > 0) {\n                angle = Helpers::GetAngle2(Poly->Points[iMaxY], Poly->Points[iMaxY - 1], ScaleY);\n                Max = Poly->Points[iMaxY].x + (Poly->Points[iMaxY - 1].x - Poly->Points[iMaxY].x) / 2;\n                MaxY = Poly->Points[iMaxY].y + (Poly->Points[iMaxY - 1].y - Poly->Points[iMaxY].y) / 2;\n            } else {\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n                Max = Poly->Points[0].x + (Poly->Points[1].x - Poly->Points[0].x) / 2;\n                MaxY = Poly->Points[0].y + (Poly->Points[1].y - Poly->Points[0].y) / 2;\n            }\n\n            if (Poly->Points[iMaxY].y > 0) {\n                Max -= 0.5 * UnderTextYOffset;\n            } else {\n                Max += 0.5 * UnderTextYOffset;\n            }\n            DrawTextOverPoly(Poly, name, RoadMarkTextDraw, m);\n        }\n        if (Max - Min >= 1000) {\n            AcadLinePtr line = AutoCAD.DrawLine(Poly->Points[0].x, -ScaleY * (Poly->Points[0].y) - UnderTextYOffset * kEdgeLines,\n                                                Poly->Points[0].x, -ScaleY * (Poly->Points[0].y) + UnderTextYOffset * kEdgeLines);\n            line->Rotate(AutoCAD.cadPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0),\n                         Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY));\n\n            line = AutoCAD.DrawLine(Poly->Points[Poly->Count - 1].x, -ScaleY * (Poly->Points[Poly->Count - 1].y) - UnderTextYOffset * kEdgeLines,\n                                    Poly->Points[Poly->Count - 1].x, -ScaleY * (Poly->Points[Poly->Count - 1].y) + UnderTextYOffset * kEdgeLines);\n            line->Rotate(AutoCAD.cadPoint(Poly->Points[Poly->Count - 1].x, -ScaleY * Poly->Points[Poly->Count - 1].y, 0),\n                         Helpers::GetAngle2(Poly->Points[Poly->Count - 2], Poly->Points[Poly->Count - 1], ScaleY));\n        }\n    }\n\n    return pl;\n}\n\n\n\nAcadBlockReferencePtr TAcadExport::DrawBlockOnLine(String blockName, TPoint p1, TPoint p2, String lengthPropName, double scale)\n{\n    float yoffset = -ScaleY * (p2.y - p1.y);\n    float xoffset = p2.x - p1.x;\n    float angle = xoffset != 0 ? atan(yoffset / xoffset) : yoffset < 0 ? -M_PI_2 : M_PI_2;\n    if (xoffset < 0)angle += M_PI;\n    float length = sqrt(yoffset * yoffset + xoffset * xoffset);\n    AcadBlockReferencePtr block = AutoCAD.DrawBlock(blockName, p1.x, -ScaleY * p1.y, angle, scale);\n    if (block.IsBound()) {\n        vector<AnsiString> props;\n        Utils::split(lengthPropName, \" ,\", props);\n        for (int i = 0; i < props.size(); ++i) {\n            try {\n                AutoCAD.SetPropertyDouble(block, props[i], length);\n            } catch (...) {\n                BUILDER_ERROR(\"Не смог изменить свойство \"\n                              << props[i].c_str()\n                              << \" блока \"\n                              << blockName.c_str()\n                              << \" на промежутке \"\n                              << \"[\" << p1.x << \"; \" << p1.y << \"]\"\n                              << \"[\" << p2.x << \"; \" << p2.y << \"]\");\n            }\n        }\n    }\n    return block;\n}\n\nbool __fastcall TAcadExport::ExportRoadMark(TExtPolyline *Poly, TRoadMark *m, int line, String code, bool fEnd) {\n    bool ffind;\n    float x, y, height, rot, length, yoffset, xoffset, angle, Min, Max;\n    int iRow, i;\n    AutoCADTable *table, *table2;\n    AcadPolylinePtr pl[1];\n    TPoint p;\n    float R1_2_1BorderHeight2 = 434 / 2;\n    AnsiString str;\n\n    int count;\n\n    AcadHatchPtr hatch;\n    AcadTextPtr text;\n    AcadPolylinePtr pl1;\n    AcadBlockReferencePtr block;\n    AcadAcCmColorPtr color;\n    int lastUnderTextYOffset;\n\n    try {\n        if (fEnd) {\n            if (iTop0 != -1)tableTop.FillLastGaps(iStep, iTop0);\n            if (iBottom0 != -1)tableBottom.FillLastGaps(iStep, iBottom0);\n            for (i = 0; i < iTopAxeCount; i++) {\n                tableTop.FillLastGaps(iStep, iTopAxe - i);\n            }\n            for (i = 0; i < iBottomAxeCount; i++) {\n                tableBottom.FillLastGaps(iStep, iBottomAxe + i);\n            }\n            return true;\n        }\n\n\n        table2 = 0;\n        iRow = -1;\n\n        if (line >= -10 && line < 0) {\n            if (iTopAxeCount >= abs(line)) {\n                table = &tableTop;\n                iRow = iTopAxe + line + 1;\n            }\n        } else if (line > 0 && line <= 10) {\n            if (iBottomAxeCount >= abs(line)) {\n                table = &tableBottom;\n                iRow = iBottomAxe + line - 1;\n            }\n        } else if (line == 0) {\n            table = 0; /*вывод возможен в две таблицы сразу*/\n            iRow = 0;\n        }\n\n        ffind = false;\n        count = Poly->Count;\n\n        if (count > 1) {\n\n            if (Poly->Points[0].x > Poly->Points[count - 1].x) {\n                Min = Poly->Points[count - 1].x;\n                Max = Poly->Points[0].x;\n            } else {\n                Max = Poly->Points[count - 1].x;\n                Min = Poly->Points[0].x;\n            }\n\n            if (~iStart) {\n                if (Max < iStart) return true;\n            }\n            if (~iEnd) {\n                if (Min > iEnd) return true;\n            }\n\n            switch (m->Kind) {\n            case ma1: /*сплошная*/\n                DrawRoadMark(m, Poly, \"1.1\", iRow, line, table);\n                break;\n            case ma1_park: /*сплошная на парковке*/\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.1_park\", Poly->Points[i + 1], Poly->Points[i], \"Length\", ScaleYBlock / 4);\n                }\n                break;\n\n            case ma2_1:/*Край проезжей части (сплошная) */\n                DrawRoadMark(m, Poly, \"1.2.1\", iRow, line, table);\n                break;\n\n            case ma2_2:/*Краевая линия (прерывистая)  */\n                pl1 = DrawRoadMark(m, Poly, \"1.2.2\", iRow, line, table);\n                try {\n                    if (pl1) pl1->set_Linetype(WideString(\"linedash_1\"));\n                } catch (...) {}\n                break;\n\n            case ma3: /*двойная сплошная*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n                DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.3\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n                }\n                break;\n\n            case ma4:/*Обозначение мест, где запрещена остановка*/\n                /*pl1 = DrawPolyPoints(Poly);\n\n                color = pl1->TrueColor;\n                color->SetRGB(255,180,0);\n                pl1->TrueColor = color;\n\n                if(table&&line){\n                    table->DrawRepeatTextIntervalRoadMark(iRow,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n                }else{\n                    tableTop.DrawRepeatTextIntervalRoadMark(iTop0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n                    tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n                } */\n\n                pl1 = DrawRoadMark(m, Poly, \"1.4\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    color = pl1->TrueColor;\n                    pl1->set_Lineweight(acLnWt040);\n                    color->SetRGB(255, 180, 0);\n                    pl1->TrueColor = color;\n                }\n\n                //DrawTextOverPoly(Poly, \"1.4\", RoadMarkTextDraw);\n                break;\n\n            case ma5: /*Прерывистая линия*/\n                pl1 = DrawRoadMark(m, Poly, \"1.5\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Linetype(WideString(\"linedash_1\"));\n                    pl1->set_LinetypeScale(0.5);\n                }\n                break;\n\n            case ma6: /*Приближение к сплошной линии*/\n                pl1 = DrawRoadMark(m, Poly, \"1.6\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Linetype(WideString(\"linedash_2\"));\n                    pl1->set_LinetypeScale(0.5);\n                }\n                break;\n\n            case ma7:  /*Обозначение полос движения на перекрестке*/\n                pl1 = DrawRoadMark(m, Poly, \"1.7\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Linetype(WideString(\"linedash_3\"));\n                    pl1->set_LinetypeScale(0.33);\n                }\n                break;\n\n            case ma8: /*Обозначение границы между полосой разгона и основной полосой*/\n                pl1 = DrawRoadMark(m, Poly, \"1.8\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Linetype(WideString(\"linedash_1\"));\n                    pl1->set_LinetypeScale(0.2);\n                }\n                break;\n\n            case ma9: /*Обозначение границ реверсивных полос движения*/\n                BUILDER_ERROR(\"Разметка 1.9 не реализована\");\n                break;\n\n            case ma10:  /*Обозначение мест, где запрещена стоянка*/\n                pl1 = DrawRoadMark(m, Poly, \"1.10\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Linetype(WideString(\"linedash_1\"));\n                    pl1->set_LinetypeScale(0.33);\n                    color = pl1->TrueColor;\n                    pl1->set_Lineweight(acLnWt040);\n                    color->SetRGB(255, 180, 0);\n                    pl1->TrueColor = color;\n                }\n                break;\n\n            case ma11l:  /*Движение с одной стороны (прерывистая слева)*/\n            case ma11r:  /*Движение с одной стороны (прерывистая справа)*/\n                for (int i = 0; i < count - 1; i++) {\n                    block = DrawBlockOnLine(\"r_1.11\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n                    int px =  Poly->Points[i + 1].x - Poly->Points[i].x;\n                    int py =  Poly->Points[i + 1].y - Poly->Points[i].y;\n                    length = sqrt(px * px + py * py * ScaleY * ScaleY);\n                    if (block.IsBound() ) {\n                        float lengthScale = 0.1;\n                        AutoCAD.SetPropertyDouble(block, \"Length\", length / lengthScale);\n                        block->set_XScaleFactor(lengthScale);\n                        if ((m->Kind == ma11r && m->Direction == roDirect) || (m->Kind == ma11l && m->Direction == roUnDirect)) {\n                            AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                        }\n                    }\n                }\n                DrawTextOverPoly(Poly, \"1.11\", RoadMarkTextDraw);\n                break;\n\n            case ma12:  /*Стоп линия*/\n                /*for(int i=0;i<count-1;i++){\n                    DrawBlockOnLine(\"r_1.12\", Poly->Points[i], Poly->Points[i+1], \"Length\");\n                } */\n                pl1 = DrawRoadMark(m, Poly, \"1.12\", iRow, line, table);\n                if (pl1.IsBound()) {\n                    pl1->set_Lineweight(acLnWt040);\n                }\n                break;\n\n            case ma13: /*Обозначение места, где водитель обязан уступить дорогу*/\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.13\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n                }\n                break;\n\n            case ma14_1:\n            case ma14_2:/*пешеход*/\n            case ma14_3:\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.14.1\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n                }\n                break;\n            case ma14_1e:\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.14.1_e\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n                }\n                break;\n            case ma14_2e:\n                for (int i = 0; i < count - 1; i++) {\n                    DrawBlockOnLine(\"r_1.14.2_e\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n                }\n                break;\n\n            case ma15: /*Обозначение переезда для велосипедистов*/\n                BUILDER_ERROR(\"Разметка 1.15 не реализована\");\n                //tableBottom.DrawRepeatTextInterval(0,\"1.15\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma16_1: /*Обозначение островков, разделяющих потоки  противоположенных направлений*/\n            case ma16_2: /*Обозначение островков, разделяющих потоки  одного направления*/\n            case ma16_3: /*Обозначение островков в местах слияния транспортных потоков*/\n\n                switch (m->Kind) {\n                case  ma16_1: str = \"1.16.1\"; break;\n                case  ma16_2: str = \"1.16.2\"; break;\n                case  ma16_3: str = \"1.16.3\"; break;\n                }\n                p.y = 0;\n                p.x = 0;\n                for (i = 0; i < Poly->Count; i++) {\n                    p.x += Poly->Points[i].x;\n                    p.y += Poly->Points[i].y;\n                }\n\n                p.y *= -ScaleY;\n                p.x /= Poly->Count;\n                p.y /= Poly->Count;\n\n                //text = AutoCAD.DrawText(str,UnderTextHeight,acAlignmentMiddleCenter, p.x,p.y);\n                pl[0] = DrawPolyPoints(Poly, false, true);\n                hatch = AutoCAD.FillArea((IDispatch**)pl, 1, 0, L\"ANSI31\");\n                hatch->PatternScale = 50;\n                pl[0]->Delete();\n\n                block = AutoCAD.DrawBlock(\"r_label\", p.x, p.y, 0, ScaleYBlock / 4);\n                if (block.IsBound()) {\n                    AutoCAD.SetAttribute(block, \"Label\", str);\n                }\n\n                //tableBottom.DrawRepeatTextInterval(0,\"1.16\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma17: /*Обозначение остановок маршрутных транспортных средств*/\n            {\n                float scale = ScaleYBlock / 4;\n                block = DrawBlockOnLine(\"r_1.17\", Poly->Points[0], Poly->Points[count - 1], \"Length Length2\", scale);\n\n                // чтобы выводить разметку так чтобы правая ножка не отрывалась от общего контура\n                // в случае изменения размеров блока разметки, надо поменять значение 582 на значение шага повторения\n                float blockDefaultLength = 582 * scale;\n                float length = Helpers::GetLength(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                int realLength = ((int)length / (int)blockDefaultLength) * blockDefaultLength;\n                AutoCAD.SetPropertyDouble(block, \"Length\",  realLength);\n                AutoCAD.SetPropertyDouble(block, \"Length2\", realLength);\n\n            }\n                //tableBottom.DrawRepeatTextInterval(0,\"1.17\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n            break;\n\n            case ma18l: /*Направление движения(налево)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.18_3\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                break;\n            case ma18p: /*Направление движения(прямо)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.18_1\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                break;\n            case ma18pl: /*Направление движения(прямо,налево)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.18_2\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                break;\n            case ma18pr: /*Направление движения(прямо,направо)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.18_2\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                break;\n            case ma18prl: /*Направление движения(прямо,направо,налево)*/\n                BUILDER_ERROR(\"Разметка 1.8prl не реализована\");\n                break;\n\n            case ma18r: /*Направление движения(направо)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.18_3\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                break;\n            case ma18rl: /*Направление движения(направо,налево)*/\n                BUILDER_ERROR(\"Разметка 1.8rl не реализована\");\n                //tableBottom.DrawRepeatTextInterval(0,\"1.18\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma19_1:  /*Направление перестроения(направо)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.19\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                break;\n            case ma19_2:  /*Направление перестроения(налево)*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.19\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                //tableBottom.DrawRepeatTextInterval(0,\"1.19\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma20: /*Приближение к поперечной линии 1.13*/\n                angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n                block = AutoCAD.DrawBlock(\"r_1.20\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n                break;\n\n            case ma21: /*Приближение к поперечной линии 1.12*/\n                //tableBottom.DrawRepeatTextInterval(0,\"1.21\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                BUILDER_ERROR(\"Разметка 1.21 не реализована\");\n                break;\n\n            case ma22:  /*Обозначение номера дороги*/\n                BUILDER_ERROR(\"Разметка 1.22 не реализована\");\n                //tableBottom.DrawRepeatTextInterval(0,\"1.22\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma23:  /*Обозначение полосы движения только для маршрутных транспортных средств*/\n                block = AutoCAD.DrawBlock(\"r_1.23\",\n                                          Poly->Points[0].x,\n                                          -ScaleY * Poly->Points[0].y,\n                                          m->Direction == roDirect ? 0 : M_PI,\n                                          ScaleYBlock / 4);\n                //tableBottom.DrawRepeatTextInterval(0,\"1.23\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n\n            case ma24_1: /*Дублирование предупреждающих дорожных знаков*/\n            case ma24_2: /*Дублирование запрещающих дорожных знаков*/\n            case ma24_3: /*Дублирование дорожного знака Инвалиды*/\n                BUILDER_ERROR(\"Разметка 1.24 на позиции \" << Poly->Points[0].x << \" не реализована\");\n                //tableBottom.DrawRepeatTextInterval(0,\"1.24\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n                break;\n            case ma24_4: /*Дублирование дорожного знака Инвалиды*/\n                block = AutoCAD.DrawBlock(\"r_1.24_4\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y,\n                                          m->Direction == roDirect ? 0 : M_PI);\n                break;\n            case ma25:  /*Обозначение искусственных неровностей*/\n                x = Poly->Points[0].x;\n                y = Poly->Points[0].y;\n                height = ScaleY * (Poly->Points[count - 1].y - y);\n                if (height < 0) {\n                    rot = M_PI / 2;\n                    height = -height;\n                } else {\n                    rot = -M_PI / 2;\n                }\n                block = AutoCAD.DrawBlock(\"r_1.25\", x, -ScaleY * y, rot, ScaleYBlock / 4);\n                AutoCAD.SetPropertyDouble(block, \"Width\", height);\n                break;\n            default:\n                BUILDER_ERROR(\"Разметка с id=\" << m->Kind << \" не реализована (id смотри в таблице Classifier)\");\n            }\n        }\n    } catch (...) {\n        BUILDER_ERROR( (\"Ошибка вывода разметки \" + IntToStr((int)m->Kind) + \" на позиции \" + IntToStr(Poly->Points[0].x)).c_str() );\n        return false;\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportTube(TExtPolyline *Poly, TRoadTube* t, bool fEnd) {\n    static float xLength, yLength, edge, Length;\n    static  AcadBlockReferencePtr block;\n    static min, max, miny, maxy;\n    TPoint pS, pE, pT;\n\n    if (fEnd) {\n        return true;\n    }\n\n    if (Poly->Points[0].y > Poly->Points[1].y) {\n        pE = Poly->Points[1];\n        pS = Poly->Points[0];\n    } else {\n        pE = Poly->Points[0];\n        pS = Poly->Points[1];\n    }\n\n    if (Poly->Points[0].x < Poly->Points[1].x) {\n        min = Poly->Points[0].x;\n        max = Poly->Points[1].x;\n    } else {\n        min = Poly->Points[1].x;\n        max = Poly->Points[0].x;\n    }\n\n\n    if (~iStart) {\n        if (max < iStart) return true;\n    }\n    if (~iEnd) {\n        if (min > iEnd) return true;\n    }\n\n    xLength = pS.x - pE.x;\n    yLength = ScaleY * (pS.y - pE.y);\n    edge = yLength == 0 ? -M_PI_2 : atan(xLength / yLength) - M_PI_2;\n    if (yLength > 0) edge += M_PI;\n    Length = sqrt(xLength * xLength + yLength * yLength);\n    if (!fAlreadyDrawTube) {\n        Tube = AutoCAD.DrawBlock(\"tube\");\n        fAlreadyDrawTube = true;\n    }\n    block = Tube->Copy();\n    block->set_InsertionPoint(AutoCAD.cadPoint(pS.x, -ScaleY * pS.y));\n    block->Rotation = edge;\n    AutoCAD.SetPropertyDouble(block, \"Length\", Length);\n    AutoCAD.SetAttribute(block, \"LABEL\", \"т:\" + IntToStr((pS.x / 100) % 1000));\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportBridge(TExtPolyline *Poly, TRoadBridge *b, bool fEnd) {\n    static float yMin, yMax, xMin, xMax, width, length;\n    static AcadBlockReferencePtr block;\n    if (fEnd) {\n        return true;\n    }\n    yMin = Poly->Points[0].y;\n    yMax = Poly->Points[2].y;\n    xMin = Poly->Points[0].x;\n    xMax = Poly->Points[2].x;\n    width = yMax - yMin;\n    if (width < 0) width = - width;\n    length = xMax - xMin;\n    if (length < 0) length = - length;\n    block = AutoCAD.DrawBlock(\"bridge\", xMin < xMax ? xMin : xMax, -ScaleY * (yMin > yMax ? yMin : yMax));\n    AutoCAD.SetPropertyDouble(block, \"Width\", ScaleY * width);\n    AutoCAD.SetPropertyDouble(block, \"Length\", length);\n    return true;\n}\n\n\nAcadBlockReferencePtr TAcadExport::DrawBarrier(vector<TPoint> &points, AnsiString blockname, bool fFlip, bool fExist, bool fOpenLeft, int *fLastVisible)\n{\n\n    float yoffset, xoffset, angle, length;\n    TPoint pMax, pMin;\n    AcadBlockReferencePtr block;\n\n    int count = points.size();\n\n    for (int i = 0; i < count - 1; i++) {\n        pMin  = points[i];\n        pMin.y *= -ScaleY;\n\n        pMax  = points[i + 1];\n        pMax.y *= -ScaleY;\n\n        yoffset = (pMax.y - pMin.y);\n        xoffset = pMax.x - pMin.x;\n        angle = xoffset != 0 ? atan(yoffset / xoffset) : yoffset < 0 ? -M_PI_2 : M_PI_2;\n        if (xoffset < 0)angle += M_PI;\n        length = sqrt(yoffset * yoffset + xoffset * xoffset);\n\n        block.Unbind();\n        block = AutoCAD.DrawBlock(blockname, pMin.x, pMin.y, angle);\n\n        if (block.IsBound()) {\n            if (!fExist) block->color = NotExistColor;\n            AutoCAD.SetPropertyDouble(block, \"Length\", length);\n            AutoCAD.SetPropertyList(block, \"Flip\", fFlip);\n            if (i > 0) {\n                if (i < count - 2) {\n                    AutoCAD.SetPropertyListVariant(block, \"visible\", \"none\");\n                } else {\n                    if (fLastVisible) *fLastVisible = 2;\n                    AutoCAD.SetPropertyListVariant(block, \"visible\", \"right\");\n                }\n            } else {\n                if (fOpenLeft) {\n                    if (count > 2) {\n                        AutoCAD.SetPropertyListVariant(block, \"visible\", \"none\");\n                    } else {\n                        if (fLastVisible) *fLastVisible = 2;\n                        AutoCAD.SetPropertyListVariant(block, \"visible\", \"right\");\n                    }\n                } else {\n                    if (count > 2) {\n                        AutoCAD.SetPropertyListVariant(block, \"visible\", \"left\");\n                    } else {\n                        if (fLastVisible) *fLastVisible = 0;\n                        AutoCAD.SetPropertyListVariant(block, \"visible\", \"both\");\n                    }\n                }\n            }\n        }\n    }\n    return block;\n}\n\n\nvoid StyleDrawBarrierMetal(AcadPolylinePtr& pl, void* data)\n{\n    BarrierDrawStyleParameters* params = (BarrierDrawStyleParameters*)data;\n    pl->set_Lineweight(params->lineWeight);\n    pl->set_LinetypeScale(params->lineTypeScale);\n    pl->set_Linetype(WideString(\"barrier-circle\"));\n    if (!params->exist)\n        pl->color = params->NotExistColor;\n}\n\nvoid StyleDrawBarrierUndefined(AcadPolylinePtr& pl, void* data)\n{\n    BarrierDrawStyleParameters* params = (BarrierDrawStyleParameters*)data;\n    pl->set_Lineweight(params->lineWeight);\n    pl->set_LinetypeScale(params->lineTypeScale);\n    pl->set_Linetype(WideString(\"barrier-square\"));\n    if (!params->exist)\n        pl->color = params->NotExistColor;\n}\n\nvoid StyleDrawBarrierCivil(AcadPolylinePtr& pl, void* data)\n{\n    BarrierDrawStyleParameters* params = (BarrierDrawStyleParameters*)data;\n    pl->set_Lineweight(acLnWt070);\n    pl->set_LinetypeScale(params->lineTypeScale * 6);\n    pl->set_Linetype(WideString(\"perila\"));\n    pl->color = 20;\n}\n\nvoid StyleDrawBarrierNewJersey(AcadPolylinePtr& pl, void* data)\n{\n    BarrierDrawStyleParameters* params = (BarrierDrawStyleParameters*)data;\n    pl->set_Lineweight(params->lineWeight);\n    pl->set_LinetypeScale(params->lineTypeScale);\n    pl->set_Linetype(WideString(\"barrier-square\"));\n    if (!params->exist)\n        pl->color = params->NotExistColor;\n}\n\nbool __fastcall TAcadExport::ExportBarrier(TExtPolyline *Poly, TRoadBarrier *b, bool exist, bool fEnd) {\n    static dir, counter = 0;\n    static AnsiString str;\n\n    static AcadBlockReferencePtr lBlockLeft, lBlockRight, block;\n    static float lEndRight = -1, lEndLeft = -1;\n    static lPropLeft = -1, lPropRight = -1, curProp;\n    static bool fOpenLeft;\n\n\n    if (fEnd) {\n        if (!fDrawMap) {\n            if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n            if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n        }\n        return true;\n    }\n\n    dir = b->Placement == opLeft ? 1 : -1;\n\n    lPointBarrier.x = Poly->Points[Poly->Count - 1].x;\n\n    vector<TPoint> points;\n    for (int i = 0; i < Poly->Count; i++) {\n        points.push_back(Poly->Points[i]);\n    }\n    if (iMinBarrierSegmentLength != -1)\n        Utils::optimize(points, iMinBarrierSegmentLength);\n\n    sort(points.begin(), points.end(), barrierPointAsc());\n\n    bool temp;\n\n    float Min, Max, yoffset, xoffset, angle, length;\n    TPoint pMin, pMax;\n    bool inversed;\n    if (points.front().x > points.back().x) {\n        Min = points.back().x;\n        pMin = points.back();\n        pMax = points.front();\n        Max = points.front().x;\n        inversed = true;\n    } else {\n        Max = points.back().x;\n        pMax = points.back();\n        pMin = points.front();\n        Min = points.front().x;\n        inversed = false;\n    }\n\n    if (~iStart) {\n        if (Max < iStart) return true;\n    }\n    if (~iEnd) {\n        if (Min > iEnd) return true;\n    }\n\n    curProp = 0;\n\n    fOpenLeft = false;\n    int lastStep;\n\n    switch (b->Placement) {\n    case opLeft:\n        if ( abs(int(pMin.x - lEndLeft)) < 200) {\n            switch (lPropLeft) {\n            case 0:\n                curProp = 2;\n                if (lBlockLeft.IsBound()) {\n                    fOpenLeft = true;\n                    AutoCAD.SetPropertyListVariant(lBlockLeft, \"visible\", \"left\");\n                }\n                break;\n\n            case 1:\n            case 3:\n                curProp = 2;\n                break;\n\n            case 2:\n                curProp = 2;\n                if (lBlockLeft.IsBound()) {\n                    fOpenLeft = true;\n                    AutoCAD.SetPropertyListVariant(lBlockLeft, \"visible\", \"none\");\n                }\n                break;\n            }\n        }\n        lEndLeft = pMax.x;\n        break;\n    case opRight:\n        if ( abs(int(pMin.x - lEndRight)) < 200) {\n            switch (lPropLeft) {\n            case 0:\n                curProp = 2;\n                if (lBlockRight.IsBound()) {\n                    fOpenLeft = true;\n                    AutoCAD.SetPropertyListVariant(lBlockRight, \"visible\", \"left\");\n                }\n                break;\n\n            case 1:\n            case 3:\n                curProp = 2;\n                break;\n\n            case 2:\n                curProp = 2;\n                if (lBlockRight.IsBound()) {\n                    fOpenLeft = true;\n                    AutoCAD.SetPropertyListVariant(lBlockRight, \"visible\", \"none\");\n                }\n                break;\n            }\n        }\n        lEndRight = pMax.x;\n        break;\n    }\n\n    AnsiString barrierName = \"\";\n    AcadPolylinePtr pl;\n    AcadCirclePtr circle;\n    vector<AcadPolylinePtr> lines;\n    float k = ScaleY / 3.5;\n    int lineTypeScale = 20 * k;\n    int endsRadius = 100 * k;\n    int lineWeight = acLnWt040;\n\n    BarrierDrawStyleParameters params;\n    params.lineWeight = lineWeight;\n    params.lineTypeScale = lineTypeScale;\n    params.NotExistColor = lineWeight;\n    params.exist = exist;\n\n    switch (b->Construction) {\n    case br112:\n        str = \"ДО (У3)\"; //str = \"Барьерное одностороннее\"\n        barrierName = \"barBarrierMetal\";\n        //block = DrawBarrier(points, barrierName, dir<0?0:1, exist, fOpenLeft, &curProp);\n        DrawPolyPoints(Poly, true, false, StyleDrawBarrierMetal, &params);\n        circle = AutoCAD.DrawCircle(pMin.x, pMin.y * -ScaleY, endsRadius);\n        circle->set_Lineweight(lineWeight);\n        if (!exist) circle->color = NotExistColor;\n\n        circle = AutoCAD.DrawCircle(pMax.x, pMax.y * -ScaleY, endsRadius);\n        circle->set_Lineweight(lineWeight);\n        if (!exist) circle->color = NotExistColor;\n        break;\n\n    case br113:\n        str = \"ДО (У3)\"; //str = \"Барьерное двухстороннее\";\n        barrierName = \"barBarrierMetalDuo\";\n        block = DrawBarrier(points, barrierName, dir < 0 ? 0 : 1, exist, fOpenLeft, &curProp);\n        break;\n\n    case br114:\n        str = \"Тросовое\";\n        break;\n\n    case br115:\n    case br118:\n        str = \"ДО (У3)\"; //str = \"Парапеты\"; \"По типу Нью-Джерси\";\n        barrierName = \"barNewJersey\";\n        DrawPolyPoints(Poly, true, false, StyleDrawBarrierNewJersey, &params);\n\n        pl = AutoCAD.DrawRect(pMin.x, pMin.y * -ScaleY, endsRadius, endsRadius);\n        pl->set_Lineweight(lineWeight);\n        if (!exist) pl->color = NotExistColor;\n\n        pl = AutoCAD.DrawRect(pMax.x, pMax.y * -ScaleY, endsRadius, endsRadius);\n        pl->set_Lineweight(lineWeight);\n        if (!exist) pl->color = NotExistColor;\n\n        // рисование сноски на разметку 2.5 на ограждении\n        lastStep = -9999;\n        for (int i = 0; i < points.size(); i++) {\n            int step = points[i].x / iStep;\n            if (step != lastStep\n                    || (i == points.size() - 1 && abs(points.front().x - points.back().x) > 10000)) {\n                block = AutoCAD.DrawBlock(\"r_label\", points[i].x, points[i].y * -ScaleY, 0, ScaleYBlock / 4);\n                if (block.IsBound()) {\n                    AutoCAD.SetAttribute(block, \"Label\", \"2.5\");\n                }\n            }\n            lastStep = step;\n        }\n\n        break;\n\n    case br116:\n        str = \"Сетки\";\n        break;\n\n    case br117:\n        str = \"Перила\";\n        barrierName = \"barCivil\";\n        params.lineTypeScale = lineTypeScale * 2;\n        DrawPolyPoints(Poly, true, false, StyleDrawBarrierCivil, &params);\n        break;\n\n    case brm:\n        str = \"ДО (У3)\"; //str = \"Металлическое\";\n        barrierName = \"barBarrierMetal\";\n        block = DrawBarrier(points, barrierName, dir < 0 ? 0 : 1, exist, fOpenLeft, &curProp);\n        break;\n\n    default:\n        str = \"ДО (У3)\"; // нестандартное\n        DrawPolyPoints(Poly, true, false, StyleDrawBarrierUndefined, &params);\n        pl = AutoCAD.DrawRect(pMin.x, pMin.y * -ScaleY, endsRadius, endsRadius);\n        pl->set_Lineweight(lineWeight);\n        if (!exist) pl->color = NotExistColor;\n\n        pl = AutoCAD.DrawRect(pMax.x, pMax.y * -ScaleY, endsRadius, endsRadius);\n        pl->set_Lineweight(lineWeight);\n        if (!exist) pl->color = NotExistColor;\n        break;\n    }\n\n    if (block.IsBound()) {\n        switch (curProp) {\n        case 0:\n            break;\n        case 1:\n            AutoCAD.SetPropertyListVariant(block, \"visible\", \"left\");\n            break;\n        case 2:\n            AutoCAD.SetPropertyListVariant(block, \"visible\", \"right\");\n            break;\n        case 3:\n            AutoCAD.SetPropertyListVariant(block, \"visible\", \"none\");\n            break;\n        }\n    }\n\n    for (int i = 0; i < lines.size(); ++i) {\n        lines[i].Release();\n    }\n\n    if (strProjectBarrierPrefix.Length()) {\n        str = AnsiString(exist ? \"\" : strProjectBarrierPrefix.c_str()) + \" \" + str; //\"ДО (У3)\";\n    }\n\n    if (!fDrawMap) {\n        switch (b->Placement) {\n        case opLeft:\n            if (block.IsBound()) lBlockLeft = block;\n            lPropLeft = curProp;\n            tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n            break;\n        case opRight:\n            if (block.IsBound()) lBlockRight = block;\n            lPropRight = curProp;\n            tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n            break;\n        }\n    }\n\n    return true;\n\n}\n\nbool __fastcall TAcadExport::ExportSignal(TExtPolyline *Poly, TRoadSignal *s, bool exist, bool fEnd) {\n    static AnsiString str;\n\n    if (fEnd) {\n        if (!fDrawMap) {\n            if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n            if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n        }\n        return true;\n    }\n\n    if (~iStart) {\n        if (s->LMax < iStart) return true;\n    }\n    if (~iEnd) {\n        if (s->LMin > iEnd) return true;\n    }\n\n    float scale = ((float)ScaleY / 2) * 100;\n\n    AcadBlockReferencePtr block;\n\n    int count = Poly->Count;\n    try {\n        if (s->Count == 1) {\n            if (!fDrawMap) {\n                switch (s->Placement) {\n                case opLeft:\n                    tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n                    break;\n                case opRight:\n                    tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n                    break;\n                }\n            }\n            block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0, scale);\n            if (!exist) block->color = NotExistColor;\n        } else if (s->Count > 1 && count > 1) {\n\n            float *length = new float[count];\n            float tx, ty, step, curL, k;\n            int iEnd, iStart;\n            int i;\n            int iCur = 1;\n\n            length[0] = 0;\n            for (i = 0; i < count - 1; i++) {\n                tx = Poly->Points[i + 1].x - Poly->Points[i].x;\n                ty = Poly->Points[i + 1].y - Poly->Points[i].y;\n                length[iCur++] = length[iCur - 1] + sqrt(tx * tx + ty * ty);\n                if (!Poly->Codes[i].Visible()) {\n                    iEnd = i;\n                }\n            }\n            step = length[iCur - 1] / (s->Count - 1);\n\n            int *signalsPos = new int[s->Count];\n            int signalsPosCount = 0;\n            signalsPos[signalsPosCount++] = s->LMin;\n\n            iCur = 1;\n            curL = 0;\n            for (i = 0; i < s->Count - 2; i++) {\n                curL += step;\n                while (curL > length[iCur]) {\n                    iCur++;\n                    if (iCur > count) {\n                        break;\n                    }\n                }\n\n                k = 1 - (length[iCur] - curL) / (length[iCur] - length[iCur - 1]);\n                tx = Poly->Points[iCur].x - Poly->Points[iCur - 1].x;\n                ty = -ScaleY * (Poly->Points[iCur].y - Poly->Points[iCur - 1].y);\n                signalsPos[signalsPosCount] = Poly->Points[iCur - 1].x + k * tx;\n                block = AutoCAD.DrawBlock(\"signalpost\", signalsPos[signalsPosCount], -ScaleY * Poly->Points[iCur - 1].y + k * ty, 0, scale);\n                if (!exist) block->color = NotExistColor;\n                signalsPosCount++;\n            }\n\n            signalsPos[signalsPosCount++] = s->LMax;\n            sp = signalsPos;\n            spCount = signalsPosCount;\n\n            if (!fDrawMap) {\n                switch (s->Placement) {\n                case opLeft:\n                    tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n                    break;\n                case opRight:\n                    tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n                    break;\n                }\n            }\n\n            block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0, scale);\n            if (!exist) block->color = NotExistColor;\n            block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[count - 1].x, -ScaleY * Poly->Points[count - 1].y, 0, scale);\n            if (!exist) block->color = NotExistColor;\n            delete[] length;\n            delete[] signalsPos;\n        }\n    } catch (...) {\n        BUILDER_ERROR( (\"Ошибка вывода столбиков на промежутке [\" + IntToStr(s->LMin) + \"; \" + IntToStr(s->LMax) + \"]\").c_str() );\n        return false;\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportMoundHeight(TMoundHeight *m, int fase, bool fEnd) {\n    AnsiString str;\n    static bool ffirstL, ffirstR;\n    static lRightHeight, lLeftHeight, lRightL, lLeftL;\n\n    if (fEnd) {\n        return true;\n    }\n\n    if (fDrawMap) return true;\n\n    if (fase) {\n        switch (m->Placement) {\n        case rsLeft:\n            if (ffirstL) {\n                ffirstL = false;\n            } else {\n                if ( !((~iStart && m->L < iStart) || (~iEnd && lLeftL > iEnd)) ) {\n                    if (lLeftHeight > m->Height) {\n                        tableTop.DrawLine(iTopMoundH, lLeftL, 0.5, m->L, 0.1);\n                    } else if (lLeftHeight < m->Height) {\n                        tableTop.DrawLine(iTopMoundH, lLeftL, 0.1, m->L, 0.5);\n                    } else {\n                        tableTop.DrawLine(iTopMoundH, lLeftL, 0.5, m->L, 0.5);\n                    }\n                    tableTop.DrawRepeatTextIntervalMoundHeight(iTopMoundH, lLeftL, m->L, lLeftHeight, m->Height, iStep);\n                }\n            }\n            lLeftHeight = m->Height;\n            lLeftL = m->L;\n            break;\n\n        case rsRight:\n            if (ffirstR) {\n                ffirstR = false;\n            } else {\n                if ( !((~iStart && m->L < iStart) || (~iEnd && lRightL > iEnd)) ) {\n                    if (lRightHeight > m->Height) {\n                        tableBottom.DrawLine(iBottomMoundH, lRightL, 0.5, m->L, 0.1);\n                    } else if (lRightHeight < m->Height) {\n                        tableBottom.DrawLine(iBottomMoundH, lRightL, 0.1, m->L, 0.5);\n                    } else {\n                        tableBottom.DrawLine(iBottomMoundH, lRightL, 0.5, m->L, 0.5);\n                    }\n                    tableBottom.DrawRepeatTextIntervalMoundHeight(iBottomMoundH, lRightL, m->L, lRightHeight, m->Height, iStep);\n                }\n            }\n            lRightHeight = m->Height;\n            lRightL = m->L;\n            break;\n        }\n    } else {\n        ffirstL = ffirstR = true;\n    }\n    return true;\n}\n\n\nbool __fastcall TAcadExport::ExportCurve(TDangerCurve *c, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n\n    if (fDrawMap) return true;\n\n    int tLessForVerticalLabels = lessForVerticalLabels;\n\n    lessForVerticalLabels = 0;\n    tableBottom.lessForVerticalLabels = 0;\n    tableTop.lessForVerticalLabels = 0;\n\n    static TCurveKind lKind = -1;\n    float length = c->LMax - c->LMin;\n\n    if (~iStart) {\n        if (c->LMax < iStart) return true;\n    }\n    if (~iEnd) {\n        if (c->LMin > iEnd) return true;\n    }\n\n    AcadEllipsePtr ellipse;\n    AcadBlockReferencePtr block;\n\n    try {\n        switch (c->Kind) {\n        case ckCircle:\n            if (iTopCurves >= 0) {\n                block = tableTop.DrawBlock(\"pArc\", iTopCurves, c->LMin);\n                AutoCAD.SetPropertyDouble(block, \"Length\", length);\n                if (c->Radius < 0) {\n                    c->Radius = -c->Radius;\n                    AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                }\n            }\n            if (iBottomCurves >= 0) {\n                block = tableBottom.DrawBlock(\"pArc\", iBottomCurves, c->LMin);\n                AutoCAD.SetPropertyDouble(block, \"Length\", length);\n                if (c->Radius < 0) {\n                    c->Radius = -c->Radius;\n                    AutoCAD.SetPropertyList(block, \"Flip\", 1);\n                }\n            }\n            tableTop.DrawRepeatTextIntervalRoadMark(iTopCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n            tableBottom.DrawRepeatTextIntervalRoadMark(iBottomCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n            break;\n\n        case ckLeftCurve:\n            if (lKind == ckLine) {\n                if (iTopCurves >= 0) {\n                    ellipse = tableTop.DrawLeftArcEllipse(iTopCurves, c->LMin, c->LMax);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = 0;\n                        ellipse->EndAngle = M_PI_2;\n                    } else {\n                        ellipse->StartAngle = M_PI * 1.5;\n                        ellipse->EndAngle = M_PI * 2;\n                    }\n                    tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n                    tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n                }\n                if (iBottomCurves >= 0) {\n                    ellipse = tableBottom.DrawLeftArcEllipse(iBottomCurves, c->LMin, c->LMax);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = 0;\n                        ellipse->EndAngle = M_PI_2;\n                    } else {\n                        ellipse->StartAngle = M_PI * 1.5;\n                        ellipse->EndAngle = M_PI * 2;\n                    }\n                    tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n                    tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n                }\n            } else if (lKind == ckCircle) {\n                if (iTopCurves >= 0) {\n                    ellipse = tableTop.DrawLeftArcEllipse(iTopCurves, c->LMax, c->LMin);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI * 1.5;\n                        ellipse->EndAngle = M_PI * 2;\n                    } else {\n                        ellipse->StartAngle = M_PI;\n                        ellipse->EndAngle = M_PI * 1.5;\n                    }\n                    tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n                    tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n                }\n                if (iBottomCurves >= 0) {\n                    ellipse = tableBottom.DrawLeftArcEllipse(iBottomCurves, c->LMax, c->LMin);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI * 1.5;\n                        ellipse->EndAngle = M_PI * 2;\n                    } else {\n                        ellipse->StartAngle = M_PI;\n                        ellipse->EndAngle = M_PI * 1.5;\n                    }\n                    tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n                    tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n                }\n            }\n\n            break;\n\n        case ckRightCurve:\n\n            if (lKind == ckLine) {\n                if (iTopCurves >= 0) {\n                    ellipse = tableTop.DrawRightArcEllipse(iTopCurves, c->LMin, c->LMax);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI_2;\n                        ellipse->EndAngle = M_PI;\n                    } else {\n                        ellipse->StartAngle = 0;\n                        ellipse->EndAngle = M_PI_2;\n                    }\n                    tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n                    tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n                }\n                if (iBottomCurves >= 0) {\n                    ellipse = tableBottom.DrawRightArcEllipse(iBottomCurves, c->LMin, c->LMax);\n                    if (abs(c->LMin - c->LMax) < tableBottom.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI_2;\n                        ellipse->EndAngle = M_PI;\n                    } else {\n                        ellipse->StartAngle = 0;\n                        ellipse->EndAngle = M_PI_2;\n                    }\n                    tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n                    tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n                }\n            } else if (lKind == ckCircle) {\n                if (iTopCurves >= 0) {\n                    ellipse = tableTop.DrawRightArcEllipse(iTopCurves, c->LMax, c->LMin);\n                    if (abs(c->LMin - c->LMax) < tableTop.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI;\n                        ellipse->EndAngle = M_PI * 1.5;\n                    } else {\n                        ellipse->StartAngle = M_PI_2;\n                        ellipse->EndAngle = M_PI;\n                    }\n                    tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n                    tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n                }\n                if (iBottomCurves >= 0) {\n                    ellipse = tableBottom.DrawRightArcEllipse(iBottomCurves, c->LMax, c->LMin);\n                    if (abs(c->LMin - c->LMax) < tableBottom.RowHeight / 2) {\n                        ellipse->StartAngle = M_PI;\n                        ellipse->EndAngle = M_PI * 1.5;\n                    } else {\n                        ellipse->StartAngle = M_PI_2;\n                        ellipse->EndAngle = M_PI;\n                    }\n                    tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n                    tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n                }\n            }\n\n            break;\n\n        case ckLine:\n            tableTop.DrawLine(iTopCurves, c->LMin, c->LMax);\n            tableBottom.DrawLine(iBottomCurves, c->LMin, c->LMax);\n            break;\n        }\n    } catch (...) {\n        BUILDER_ERROR( (\"Ошибка вывода кривой в плане на промежутке [\" + IntToStr(c->LMin) + \"; \" + IntToStr(c->LMax) + \"]\").c_str() );\n        return false;\n    }\n    lKind = c->Kind;\n\n    lessForVerticalLabels = tLessForVerticalLabels;\n    tableBottom.lessForVerticalLabels = tLessForVerticalLabels * 100;\n    tableTop.lessForVerticalLabels = tableBottom.lessForVerticalLabels;\n\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportSlope(TDangerSlope *s, int fase, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n\n    if (fDrawMap) return true;\n\n    if (~iStart) {\n        if (s->LMax < iStart) return true;\n    }\n    if (~iEnd) {\n        if (s->LMin > iEnd) return true;\n    }\n\n    if (s->Promille > 0) {\n        if (iTopSlopes >= 0) {\n            tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, true);\n            tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n        }\n        if (iBottomSlopes >= 0) {\n            tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, true);\n            tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n        }\n        if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n        if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n    } else if (s->Promille < 0) {\n        if (iTopSlopes >= 0) {\n            tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, false);\n            tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n        }\n        if (iBottomSlopes >= 0) {\n            tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, false);\n            tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n        }\n        if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n        if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n    } else {\n        if (iTopSlopes >= 0) {\n            tableTop.DrawLine(iTopSlopes, s->LMin, tableTop.kBottomEmptyPadding, s->LMax, tableTop.kBottomEmptyPadding);\n            tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n        }\n        if (iBottomSlopes >= 0) {\n            tableBottom.DrawLine(iBottomSlopes, s->LMin, tableBottom.kBottomEmptyPadding, s->LMax, tableBottom.kBottomEmptyPadding);\n            tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n        }\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportBusStop(TExtPolyline *Poly, TBusStop *s, bool fEnd) {\n    static float rotation;\n    if (fEnd) {\n        return true;\n    }\n\n    if (~iStart) {\n        if (Poly->Points[0].x < iStart) return true;\n    }\n    if (~iEnd) {\n        if (Poly->Points[0].x > iEnd) return true;\n    }\n\n    rotation = s->GetPlacement() == spLeft ? M_PI : 0;\n    AutoCAD.DrawBlock(\"busstop\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, rotation, ScaleY / 2);\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportRestZone(TExtPolyline *Poly, TSquareRoadSideObject_Kromka *r, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n    DrawPolyPoints(Poly);\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportSidewalk(KromkaObjectGroup *sidewalksGroup, bool fEnd) {\n\n    if (fEnd) {\n        if (!fDrawMap) {\n            if (~iTopSidewalks)tableTop.FillLastGaps(iStep, iTopSidewalks);\n            if (~iBottomSidewalks)tableBottom.FillLastGaps(iStep, iBottomSidewalks);\n        }\n        return true;\n    }\n\n    if (sidewalksGroup->objects.size()) {\n        for (int j = 0; j < sidewalksGroup->objects.size(); ++j) {\n            TSquareRoadSideObject_Kromka* s = sidewalksGroup->objects[j].obj;\n\n            if (~iStart) {\n                if (s->LMax < iStart) continue;\n            }\n            if (~iEnd) {\n                if (s->LMin > iEnd) continue;\n            }\n\n            TExtPolyline *Poly = s->PrepareMetric(sidewalksGroup->road());\n\n            AcadPolylinePtr pl[1];\n            pl[0] = DrawPolyPoints(Poly, false, true);\n            AcadHatchPtr hatch = AutoCAD.FillArea((IDispatch**)pl, 1, !sidewalksGroup->objects[j].exist ? NotExistColor : 0, strSidewalksHatch);\n            if (hatch) hatch->PatternScale = iSidewalsHatchScale;\n\n            delete Poly;\n        }\n\n        AnsiString str = \"а/б\";\n        if (!fDrawMap) {\n            switch (sidewalksGroup->objects[0].obj->Placement) {\n            case spLeft:\n                tableTop.DrawRepeatTextIntervalRoadMark(iTopSidewalks, str,\n                                                        sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n                break;\n            case spRight:\n                tableBottom.DrawRepeatTextIntervalRoadMark(iBottomSidewalks, str,\n                        sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n                break;\n            }\n        }\n\n    }\n    return true;\n}\n\nAcadBlockReferencePtr TAcadExport::DrawBorder(vector<TPoint> &points, AnsiString blockname, bool fExist)\n{\n    int count = points.size();\n    float yoffset, xoffset, angle, length;\n    TPoint pMax, pMin;\n    AcadBlockReferencePtr block;\n    for (int i = 0; i < count - 1; i++) {\n        pMin  = points[i];\n        pMin.y *= -ScaleY;\n\n        pMax  = points[i + 1];\n        pMax.y *= -ScaleY;\n\n        yoffset = (pMax.y - pMin.y);\n        xoffset = pMax.x - pMin.x;\n        angle = xoffset != 0 ? atan(yoffset / xoffset) : yoffset < 0 ? -M_PI_2 : M_PI_2;\n        if (xoffset < 0)angle += M_PI;\n        length = sqrt(yoffset * yoffset + xoffset * xoffset);\n\n        block = AutoCAD.DrawBlock(blockname, pMin.x, pMin.y, angle);\n\n        if (block.IsBound()) {\n            if (!fExist) block->color = NotExistColor;\n            AutoCAD.SetPropertyDouble(block, \"Length\", length);\n        }\n    }\n    return block;\n}\n\nvoid StyleBorderBgLine(AcadPolylinePtr& line, void* data)\n{\n    BorderDrawStyleParams *params = (BorderDrawStyleParams*)data;\n    line->set_Lineweight(50);\n    if (!params->exist) {\n        line->color = params->NotExistColor;\n    }\n}\n\nvoid StyleBorderFgLine(AcadPolylinePtr& line, void* data)\n{\n    line->set_Lineweight(30);\n    line->set_Linetype(WideString(\"linedash_1\"));\n    AcadAcCmColorPtr color;\n    color = line->TrueColor;\n    color->SetRGB(255, 255, 255);\n    line->TrueColor = color;\n}\n\nbool __fastcall TAcadExport::ExportBorder(TExtPolyline *Poly, TLinearRoadSideObject *o, bool exist, bool fEnd) {\n    if (fEnd) return true;\n\n    if (~iStart) {\n        if (o->LMax < iStart) return true;\n    }\n    if (~iEnd) {\n        if (o->LMin > iEnd) return true;\n    }\n    BorderDrawStyleParams params;\n    params.exist = exist;\n    params.NotExistColor = NotExistColor;\n    DrawPolyPoints(Poly, true, false, StyleBorderBgLine, &params);\n    DrawPolyPoints(Poly, true, false, StyleBorderFgLine, &params);\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportLighting(TExtPolyline *Poly, TRoadLighting *s, bool exist, bool fEnd) {\n    if (fEnd) {\n        return true;\n    }\n\n    if (~iStart) {\n        if (Poly->Points[0].x < iStart) return true;\n    }\n    if (~iEnd) {\n        if (Poly->Points[0].x > iEnd) return true;\n    }\n\n    AcadBlockReferencePtr block;\n\n    double angle;\n    if (Poly->Count == 2) {\n        angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n    } else {\n        if (s->Placement == rsRight) {\n            angle = M_PI;\n        } else {\n            angle = 0;\n        }\n    }\n\n    block = AutoCAD.DrawBlock(\"lamp\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 2);\n    if (block.IsBound()) {\n        switch (s->Kind) {\n        case lkOnce:\n            AutoCAD.SetPropertyList(block, \"Style\", 0);\n            break;\n\n        case lkDouble:\n            AutoCAD.SetPropertyList(block, \"Style\", 1);\n            break;\n        }\n        if (!exist) {\n            block->color = NotExistColor;\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n}\n\n\nvoid TAcadExport::ExportAddRowLine( AutoCADTable *table, int iRow,\n                                    int iPos, int iEnd, AnsiString str)\n{\n    if (fDrawMap) return;\n\n    AnsiString style = str.SubString(1, 2);\n    AnsiString params;\n    AnsiString sTemp;\n    if (style == \"$c\") { //заливка\n        params = str.SubString(3, str.Length() - 2).Trim();\n        char hatchName[255];\n        float scale;\n        int color = 0;\n        sscanf(params.c_str(), \"%s\\t%f\\t%i\", hatchName, &scale, &color);\n        table->FillArea(iRow, iPos, iEnd, hatchName, iFillHatchScale, color);\n        table->DrawBorder(iPos, iRow);\n        table->DrawBorder(iEnd, iRow);\n    } else if (style == \"$b\") { //блок\n        params = str.SubString(3, str.Length() - 2).Trim();\n        AnsiString blockName;\n\n        TStringList *paramsValues = new TStringList();\n        ExtractStrings(TSysCharSet() << '\\t' << ' ',\n                       TSysCharSet() << ' ' << '\\t',\n                       params.c_str(), paramsValues);\n        if (paramsValues->Count == 0) {\n            return;\n        }\n\n        blockName = paramsValues->Strings[0]; // первый параметр - имя блока\n        paramsValues->Delete(0);\n        AcadBlockReferencePtr block = table->DrawBlock(blockName, iRow, iPos, (float)iEnd / 100);\n\n        if (paramsValues->Count > 0) {\n            if (block.IsBound()) {\n                for (int i = 0; i < paramsValues->Count; i++) {\n                    AnsiString param = paramsValues->Strings[i];\n                    int suffixPos;\n                    AnsiString name, value;\n\n                    if ( suffixPos = param.Pos(':')) {\n                        name = param.SubString(1, suffixPos - 1);\n                        value = param.SubString(suffixPos + 1,  param.Length() - suffixPos);\n                        AutoCAD.SetAttribute(block, name, value);\n                    } else if (suffixPos = param.Pos('=')) {\n                        name = param.SubString(1, suffixPos - 1);\n                        value = param.SubString(suffixPos + 1,  param.Length() - suffixPos);\n                        double dValue;\n                        if (TryStrToFloat(value, dValue)) {\n                            AutoCAD.SetPropertyDouble(block, name, dValue);\n                        }\n                    } else if (suffixPos = param.Pos('<')) {\n                        int iValue;\n                        name = param.SubString(1, suffixPos - 1);\n                        value = param.SubString(suffixPos + 1,  param.Length() - suffixPos);\n                        if (TryStrToInt(value, iValue)) {\n                            AutoCAD.SetPropertyList(block, name, iValue);\n                        } else {\n                            AutoCAD.SetPropertyListVariant(block, name, value);\n                        }\n                    }\n                }\n            }\n        }\n        delete paramsValues;\n    } else { // просто текст\n        table->DrawRepeatTextIntervalRoadMark(iRow, str, iPos, iEnd, 0, iStep, true);\n    }\n}\n\nstruct ExportAddRowsOptions {\n    ExportAddRowsOptions()\n        : offset(0)\n    {}\n\n    /**\n    * try to update options with the values from line\n    * values form (assigning value without spaces):\n    * offset=value1 option2=value2 ...\n    */\n    static void FromLine(AnsiString line, ExportAddRowsOptions &options) {\n        int pos;\n        int result;\n        AnsiString subString;\n        // trying to find offset option\n#define INSTRUCTION \"offset\"\n        if ( pos = line.Pos(INSTRUCTION) ) {\n            subString = line.SubString(pos, line.Length() - pos + 1);\n            result = sscanf(subString.c_str(), INSTRUCTION\"=%d\", &options.offset);\n        }\n#undef INSTRUCTION\n    }\n\n    int offset; // offset of output rows\n};\n\nint __fastcall TAcadExport::ExportAddRows(AnsiString path, AutoCADTable *table, bool check)\n{\n    if (fDrawMap) return 0;\n\n    int iRow = -1;\n    int iCount;\n    int ePos, sPos;\n    char sEPos[32], sSPos[32];\n    AnsiString sIRow;\n    char str[512] = {0};\n    char value2[128] = {0};\n\n    ExportAddRowsOptions exportAddRowOptions;\n\n    AnsiString str2;\n    AnsiString value;\n    str2 = ChangeFileExt(ExtractFileName(path), \"\");\n\n    int startCount = table == &tableTop ? iTopAddRow : iBottomAddRow;\n    AnsiString LayerName = table == &tableTop ? \"Top\" : \"Bottom\";\n\n    if (!sscanf(str2.c_str(), \"%i_%s\", &iRow, &str)) return -1;\n    sIRow = IntToStr(iRow);\n    iCount = sIRow.Length();\n    strcpy(str, str2.SubString(iCount + 2, str2.Length() - iCount).c_str());\n    if (iRow < 0) iRow = -iRow;\n    if (!check) {\n        ifstream file(path.c_str());\n        AnsiString line;\n        string s;\n        int count;\n\n        if (file.is_open()) {\n            AddLayer(str);\n            if (table->IsHeaderInclude) {\n                table->DrawHeaderText(startCount + iRow - 1, str, HeaderTextHeight);\n            }\n\n            if (OutInfoLog) OutInfoLog(\"Вывожу \\\"\" + AnsiString(str) + \"\\\"\");\n\n            int linesCount = 0;\n            int currentLine = 0;\n            while (getline(file, s)) {\n                linesCount++;\n            }\n            file.clear();\n            file.seekg(0, ios::beg);\n\n            while (getline(file, s))  {\n                // выходим если нажали отмену\n                if (ProgressForm->Thread) {\n                    AcadExportThread *thread = dynamic_cast<AcadExportThread*>(ProgressForm->Thread);\n                    if ( thread->IsTerminated) {\n                        return -1;\n                    }\n                }\n\n                s.erase(s.find_last_not_of(\" \\n\\r\\t\") + 1);\n\n                line = s.c_str();\n                if (s.length() <= 0)\n                    continue;\n\n                if (line[1] == '#') { // if comment\n                    // remove comment symbol, and trim string\n                    line[1] = ' ';\n                    line.Trim();\n                    // try to execute special option commands\n                    ExportAddRowsOptions::FromLine(line, exportAddRowOptions);\n                } else if (s.length() > 0) {\n                    try {\n                        vector<AnsiString> words;\n                        Utils::split(line, \" \\t\", words, 3);\n\n                        count = strlen(sSPos) + 1 + strlen(sEPos) + 1;\n                        if (!TryStrToInt(words[0], sPos)) {\n                            OutInfoLog(\"Неправильный формат данных: \" + str2 + \" - \" + line);\n                            continue;\n                        }\n                        if (!TryStrToInt(words[1], ePos)) {\n                            OutInfoLog(\"Ошибка вывода: \" + str2 + \" - \" + line);\n                            continue;\n                        }\n                        sPos += exportAddRowOptions.offset;\n                        ePos += exportAddRowOptions.offset;\n\n                        line = words[2];\n\n                        ExportAddRowLine(table, startCount + iRow - 1, sPos, ePos, line.Trim());\n                        //table->DrawRepeatTextIntervalSpec(startCount+iRow-1, AnsiString(s.c_str()).Trim(), sPos, ePos,0,iStep,true);\n                    } catch (...) {\n                        OutInfoLog(\"Ошибка вывода: \" + str2 + \" - \" + line);\n                    }\n                }\n                currentLine++;\n                if (ProgressChanged) {\n                    ProgressChanged((float) currentLine / linesCount * 100, \"\");\n                }\n            }\n            file.close();\n        }\n    }\n    return iRow;\n}\n\nint __fastcall TAcadExport::ExportGraphicPath(AnsiString path, bool check)\n{\n    if (fDrawMap) return 0;\n\n    int iRow = -1;\n    int iCount, i;\n    int ePos, sPos;\n    char sEPos[32], sSPos[32];\n    AnsiString sIRow;\n    char str[512] = {0};\n    char value2[128] = {0};\n\n    AnsiString str2;\n    str2 = ChangeFileExt(ExtractFileName(path), \"\");\n\n    AnsiString value;\n\n    if (!sscanf(str2.c_str(), \"%i_%s\", &iRow, &str)) return -1;\n    sIRow = IntToStr(iRow);\n    iCount = sIRow.Length();\n    strcpy(str, str2.SubString(iCount + 2, str2.Length() - iCount).c_str());\n    if (iRow < 0) iRow = -iRow;\n    if (!check) {\n        ifstream file(path.c_str());\n        string s;\n        int count, linesCount, iValue;\n        float lValue = -1, curValue;\n        if (file.is_open()) {\n            AddLayer(\"Graphic\" + IntToStr(iRow));\n\n            lValue = curValue = 0;\n            vector<double> pointsArray;\n            bool fWas = false;\n\n            int linesCount = 0;\n            int currentLine = 0;\n            while (getline(file, s)) {\n                linesCount++;\n            }\n            file.clear();\n            file.seekg(0, ios::beg);\n\n            while (getline(file, s))  {\n                lValue = curValue;\n\n                if (sscanf(s.c_str(), \"%i %i %i\", &sPos, &ePos, &iValue) == 3) {\n                    curValue = (float)iValue / 100.0f;\n                    pointsArray.push_back(sPos);\n                    pointsArray.push_back(tableGraphic.LeftTop.y - tableGraphic.RowHeight * (iRow - 1) - (1 - lValue)*tableGraphic.RowHeight);\n                    pointsArray.push_back(sPos);\n                    pointsArray.push_back(tableGraphic.LeftTop.y - tableGraphic.RowHeight * (iRow - 1) - (1 - curValue)*tableGraphic.RowHeight);\n                    fWas = true;\n                }\n                lValue = curValue;\n\n                currentLine++;\n                if (ProgressChanged) {\n                    ProgressChanged((float) currentLine / linesCount * 100, \"\");\n                }\n            }\n            if (fWas) {\n                pointsArray.push_back(ePos);\n                pointsArray.push_back(tableGraphic.LeftTop.y - tableGraphic.RowHeight * (iRow - 1) - (1 - lValue)*tableGraphic.RowHeight);\n                pointsArray.push_back(ePos);\n                pointsArray.push_back(tableGraphic.LeftTop.y - tableGraphic.RowHeight * (iRow - 1) - (1 - curValue)*tableGraphic.RowHeight);\n            }\n\n            file.close();\n            if (pointsArray.size()) {\n                AutoCAD.DrawPolyLine(pointsArray.begin(), pointsArray.size() / 2, 2);\n            }\n        }\n    }\n    return iRow;\n}\n\nint __fastcall TAcadExport::ExportGraphic(AnsiString DirPath, bool check)\n{\n\n    TSearchRec rec;\n    int value = -1;\n    int max = 0;\n    if (!FindFirst(DirPath + \"\\\\graphic\\\\*.*\", 0, rec)) {\n        do {\n            if ((value = ExportGraphicPath(DirPath + \"\\\\graphic\\\\\" + rec.Name, check)) > 0) {\n                if (max < value)max = value;\n            }\n        } while (!FindNext(rec));\n    }\n    FindClose(rec);\n    return max;\n}\n\n\nint __fastcall TAcadExport::ExportTopAddRows(AnsiString DirPath, bool check)\n{\n    if (!check && fTopAddRowsWithoutData) return 0;\n    TSearchRec rec;\n    int value = -1;\n    int max = 0;\n    if (!FindFirst(DirPath + \"\\\\top\\\\*.*\", 0, rec)) {\n        do {\n            // выходим если нажали отмену\n            if (ProgressForm->Thread) {\n                AcadExportThread *thread = dynamic_cast<AcadExportThread*>(ProgressForm->Thread);\n                if ( thread->IsTerminated) {\n                    return -1;\n                }\n            }\n            if ((value = ExportAddRows(DirPath + \"\\\\top\\\\\" + rec.Name, &tableTop, check)) > 0) {\n                // выходим если кто-то нажал отмену\n                if (value == -1) {\n                    return -1;\n                }\n\n                if (max < value)max = value;\n            }\n        } while (!FindNext(rec));\n    }\n    FindClose(rec);\n    return max;\n}\n\nint __fastcall TAcadExport::ExportBottomAddRows(AnsiString DirPath, bool check)\n{\n    if (!check && fBottomAddRowsWithoutData) return 0;\n    TSearchRec rec;\n    int value = -1;\n    int max = 0;\n    if (!FindFirst(DirPath + \"\\\\bottom\\\\*.*\", 0, rec)) {\n        do {\n            if ((value = ExportAddRows(DirPath + \"\\\\bottom\\\\\" + rec.Name, &tableBottom, check)) > 0) {\n                if (max < value)max = value;\n            }\n        } while (!FindNext(rec));\n    }\n    FindClose(rec);\n    return max;\n}\n\nvoid __fastcall TAcadExport::DrawGrid(int step)\n{\n    for (int i = 0; i < curRoad->LMax; i += step) {\n        AutoCAD.DrawLine(i, -RCenter - tableBottom.TableHeight, i, RCenter + tableTop.TableHeight);\n        AutoCAD.DrawText(IntToStr((i / 100) % 1000), 3 * UnderTextHeight, 0,\n                         i + UnderTextYOffset, RCenter - UnderTextYOffset - 3 * UnderTextHeight);\n    }\n\n}\n\nvoid TAcadExport::ExportRuler(int iStart, int iEnd, bool fEnd)\n{\n    if (fEnd) {\n        return;\n    }\n\n    iStart = iStart / 100000;\n    iEnd = iEnd / 100000 + 1;\n\n    for (int i = iStart; i < iEnd; i++) {\n        AutoCAD.SetAttribute(AutoCAD.DrawBlock(\"Ruler\", i * 100000, tableTop.LeftTop.y - tableTop.TableHeight), \"START\", IntToStr(i));\n    }\n}\n\nbool __fastcall TAcadExport::ExportRoadCover(TExtPolyline *p, TRoadPart *t, bool fEnd)\n{\n    if (fEnd) return true;\n    AcadPolylinePtr pl[1];\n    pl[0] = DrawPolyPoints(p, false, true);\n    AcadHatchPtr hatch = AutoCAD.FillArea((IDispatch**)pl, 1, 0, L\"SOLID\");\n    pl[0]->Erase();\n    AcadAcCmColor *color =  hatch->TrueColor;\n    AnsiString strParams;\n    AnsiString name;\n    unsigned char Color[3] = {0, 0, 0};\n    int idSurface = t->GetPropValue(\"Surface\").ToInt();\n\n    switch (idSurface) {\n    case 233:    //Цементобетон\n        Color[0] = Color[1] = Color[2] = 240;\n        strParams = \"$c\\tSOLID\\t75\\t254\"; // заливка тип масштаб цвет\n        name = \"Цементобетон\";\n        break;\n\n    case 234:   // Асфальтобетон\n        Color[0] = 196;\n        Color[1] = 220;\n        Color[2] = 220;\n        strParams = \"$c\\tSOLID\\t75\\t161\"; // заливка тип масштаб цвет\n        name = \"Асфальтобетон\";\n        break;\n\n    case 235:   // щебень укреп\n        Color[0] = 244;\n        Color[1] = 200;\n        Color[2] = 128;\n        strParams = \"$c\\tSOLID\\t75\\t43\"; // заливка тип масштаб цвет\n        name = \"Щебень (гравий)\";\n        break;\n\n    case 236:  // щебень\n        Color[0] = 220;\n        Color[1] = 220;\n        Color[2] = 180;\n        strParams = \"$c\\tSOLID\\t75\\t43\"; // заливка тип масштаб цвет\n        name = \"Щебеночное (гравийное)\";\n        break;\n\n    case 237:  // грунтовое\n        Color[0] = 196;\n        Color[1] = 220;\n        Color[2] = 220;\n        strParams = \"$c\\tSOLID\\t75\\t161\"; // заливка тип масштаб цвет\n        name = \"Грунтовое\";\n        break;\n\n    case 238:\n        Color[0] = 220;\n        Color[1] = 220;\n        Color[2] = 180;\n        strParams = \"$c\\tSOLID\\t75\\t254\"; // заливка тип масштаб цвет\n        name = \"прочее\";\n        break;\n    }\n\n    color->SetRGB(Color[0], Color[1], Color[2]);\n    hatch->TrueColor = color;\n\n    if (~iBottomSurface) {\n        ExportAddRowLine(&tableBottom, iBottomSurface, t->LMin, t->LMax, strParams);\n        ExportAddRowLine(&tableBottom, iBottomSurface, t->LMin, t->LMax, name);\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportTown(TExtPolyline *p, TTown *t, bool fEnd)\n{\n    if (fEnd) return true;\n    AcadPolylinePtr pl[1];\n    pl[0] = DrawPolyPoints(p, false, true);\n    AcadHatchPtr hatch = AutoCAD.FillArea((IDispatch**)pl, 1, 0, L\"SOLID\");\n    pl[0]->Erase();\n    AcadAcCmColor *color =  hatch->TrueColor;\n    color->SetRGB(225, 225, 225);\n    hatch->TrueColor = color;\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportPlan(TExtPolyline *p, TLinearRoadSideObject *t, int kind, bool fEnd)\n{\n    if (fEnd) {\n        return true;\n    }   // 2385239\n    if (kind >= 2385228 && kind <= 2385239) {  /*рисуем площадные объекты*/\n        AcadPolylinePtr pl[1];\n        int scale = 50;\n        int rotate = 0;\n        bool fErasePolyline = true;\n        pl[0] = DrawPolyPoints(p, false, true);\n        AnsiString fillType = \"\";\n        unsigned char Color[3];\n\n        switch (kind) {\n        case 2385228:  //Берег\n            fillType = \"\";\n            Color[0] = 185;\n            Color[1] = 255;\n            Color[2] = 255;\n            scale = 400;\n            break;\n\n        case 2385229:  //Болото\n            fillType = \"DASH\";\n            Color[0] = 202;\n            Color[1] = 227;\n            Color[2] = 174;\n            scale = 200;\n            break;\n\n        case 2385230:  //Лес\n            fillType = \"GRASS\";\n            Color[0] = 208;\n            Color[1] = 255;\n            Color[2] = 208;\n            scale = 150;\n            rotate = 180;\n            break;\n\n        case 2385231:  //Кустарник\n            fillType = \"GRASS\";\n            Color[0] = 208;\n            Color[1] = 255;\n            Color[2] = 208;\n            scale = 100;\n            break;\n\n        case 2385232:  //Пашня\n            fillType = \"\";\n            Color[0] = 240;\n            Color[1] = 240;\n            Color[2] = 240;\n            //fErasePolyline = false;\n            break;\n\n        case 2385233:  //Луг\n            fillType = \"\";\n            Color[0] = 208;\n            Color[1] = 255;\n            Color[2] = 208;\n            break;\n        case 2385239: // газон\n            fillType = \"\";\n            Color[0] = 64;\n            Color[1] = 255;\n            Color[2] = 0;\n            break;\n        }\n\n\n        AcadHatchPtr hatch;\n        hatch = AutoCAD.FillArea((IDispatch**)pl, 1, 0, \"SOLID\");\n        SetObjectColor(hatch, Color[0], Color[1], Color[2]);\n        if (!fillType.IsEmpty()) {\n            hatch = AutoCAD.FillArea((IDispatch**)pl, 1, 0, fillType);\n            SetObjectColor(hatch, 0, 0, 0);\n            hatch->PatternScale = scale;\n            if (rotate) {\n                hatch->set_PatternAngle((float)rotate / 180 * M_PI);\n            }\n        }\n        if (fErasePolyline) pl[0]->Erase();\n\n    } else if (kind == 2385108 || kind == 2385224 || // Линия застройки\n               kind == 2385225 || kind == 2385248 || // Забор деревянный, Забор металлический\n               kind == 2385249 || kind == 2385250) { // Квартал жилой, Квартал нежилой,  Квартал\n        AcadPolylinePtr pl;\n        unsigned char Color[3];\n\n        if (kind == 2385108) { // Линия застройки\n            Color[0] = 255, Color[1] = 0, Color[2] = 255;\n        } else if (kind == 2385224 || kind == 2385225) { // Забор деревянный, Забор металлический\n            Color[0] = 134, Color[1] = 94, Color[2] = 94;\n        } else if (kind == 2385248 || kind == 2385249 || kind == 2385250) { // Квартал жилой, Квартал нежилой,  Квартал\n            Color[0] = 94, Color[1] = 132, Color[2] = 112;\n        }\n\n        pl = DrawPolyPoints(p, false, false);\n        SetObjectColor(pl, Color[0], Color[1], Color[2]);\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportCommunication(TExtPolyline *p, TCommunication *t, bool fEnd )\n{\n    if (fEnd) return true;\n    AcadPolylinePtr pl;\n    switch (t->CommKind) {\n    case 2385262: // трамвайные пути\n        pl = DrawPolyPoints(p);\n        /*for(int i=0;i<p->Count-1;i++){\n            DrawBlockOnLine(\"train-lines\", p->Points[i], p->Points[i+1], \"Length VerticalLineLength\");\n        }*/\n        if (pl.IsBound()) {\n            pl->set_Linetype(WideString(\"trainpath\"));\n            pl->set_LinetypeScale(ScaleY / 0.2);\n        }\n        break;\n    default:\n        pl = DrawPolyPoints(p);\n        pl->set_Linetype(WideString(\"linedash_1\"));\n        pl->set_Lineweight(acLnWt030);\n    }\n    return true;\n}\n\nbool __fastcall TAcadExport::ExportTrafficLight(TExtPolyline *p, vector<TTrafficLight*> &trafficLights, bool fEnd )\n{\n    if (fEnd) return true;\n    static float rotation;\n    if (fEnd) {\n        return true;\n    }\n\n    if (~iStart) {\n        if (p->Points[0].x < iStart) return true;\n    }\n    if (~iEnd) {\n        if (p->Points[0].x > iEnd) return true;\n    }\n\n    for (int i = 0; i < trafficLights.size(); ++i) {\n        TTrafficLight* t = trafficLights[i];\n        rotation = -(float)t->Direction / 180.0 * M_PI;\n        AnsiString blockKind = \"\";\n        switch (t->Kind) {\n        case tlkT: blockKind = \"T\"; break;\n        case tlkTl: blockKind = \"T_l\"; break;\n        case tlkTr: blockKind = \"T_r\"; break;\n        case tlkTrl: blockKind = \"T_rl\"; break;\n        case tlkP: blockKind = \"TP\"; break;\n        case trlkTR: blockKind = \"TR\"; break;  //2385256\n        }\n\n        float scale = ScaleYBlock / 2;\n        AcadBlockReferencePtr block\n            = AutoCAD.DrawBlock(\"light\", p->Points[0].x, -ScaleY * p->Points[0].y, rotation, scale);\n        if (block.IsBound()) {\n            AutoCAD.SetPropertyListVariant(block, \"Type\", blockKind);\n            /*if(!exist) {\n                block->color = NotExistColor;\n            } */\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n\n#endif // WITHOUT_AUTOCAD\n\n",
			"file": "acadexport.cpp",
			"file_size": 138925,
			"file_write_time": 130921734617989984,
			"settings":
			{
				"buffer_size": 135211,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AcadExportThread.cpp",
			"settings":
			{
				"buffer_size": 40106,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 2114 files for \"ExportSlope\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2906  }\n 2907  \n 2908: bool __fastcall TAcadExport::ExportSlope(TDangerSlope *s, int fase, bool fEnd) {\n 2909      if (fEnd) {\n 2910          return true;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n  153        bool __fastcall ExportSignal(TExtPolyline *Poly,TRoadSignal *s,bool exist, bool fEnd = false);\n  154        bool __fastcall ExportCurve(TDangerCurve *c, bool fEnd = false);\n  155:       bool __fastcall ExportSlope(TDangerSlope *s, int fase = 1, bool fEnd = false);\n  156        bool __fastcall ExportBusStop(TExtPolyline *Poly,TBusStop *s, bool fEnd = false);\n  157        bool __fastcall ExportLighting(TExtPolyline *Poly,TRoadLighting *s, bool exist, bool fEnd = false);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AcadExportThread.cpp:\n  903  }\n  904  \n  905: int __fastcall AcadExportThread::ExportSlope(TDtaSource* data, TAcadExport* aexp)\n  906  {\n  907  	SET_PROGRESS_FORM_POSITION(0)\n  ...\n  914              TDangerSlope *t=dynamic_cast<TDangerSlope*>(data->Objects->Items[i]);\n  915              if (t) {\n  916:                 aexp->ExportSlope(t);\n  917              }\n  918          }\n  919      }\n  920:     aexp->ExportSlope(0,0,true);\n  921      return 0;\n  922  }\n  ...\n 1174          // Участки уклонов выводим из слоя с профилем\n 1175          if (ProfilData) {\n 1176:             if (FAutoCADExport->ExportSlope) {\n 1177                  SET_PROGRESS_FORM_MINMAX(0,ProfilData->Objects->Count-1);\n 1178:                 EXPORT_ITEM(ExportSlope(ProfilData, aexp), \"Выводим участки уклонов ...\");\n 1179              }\n 1180          }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AcadExportThread.h:\n   80          int __fastcall ExportLamps(vector<pair<int,wpbar> > &data, TAcadExport* aexp);\n   81          int __fastcall ExportBorders(vector<pair<int,wpbar> > &data, TAcadExport* aexp);\n   82:         int __fastcall ExportSlope(TDtaSource* data, TAcadExport* aexp);\n   83          int __fastcall ExportCurves(TDtaSource* data, TAcadExport* aexp);        \n   84  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADExportForm.cpp:\n   90     ini->WriteBool(\"AutoCAD\",\"ExportSignalExistToo\",chkSignalExistToo->Checked);\n   91     ini->WriteBool(\"AutoCAD\",\"ExportTubes\",chkTubes->Checked);\n   92:    ini->WriteBool(\"AutoCAD\",\"ExportSlopes\",chkSlope->Checked);\n   93     ini->WriteBool(\"AutoCAD\",\"ExportCurves\",chkCurves->Checked);\n   94     ini->WriteBool(\"AutoCAD\",\"ExportMoundHeights\",chkMoundHeights->Checked);\n   ..\n  183     chkSignalExistToo->Checked = ini->ReadBool(\"AutoCAD\",\"ExportSignalExistToo\",false);\n  184     chkTubes->Checked = ini->ReadBool(\"AutoCAD\",\"ExportTubes\",true);\n  185:    chkSlope->Checked = ini->ReadBool(\"AutoCAD\",\"ExportSlopes\",true);\n  186     chkMoundHeights->Checked = ini->ReadBool(\"AutoCAD\",\"ExportMoundHeights\",true);\n  187     chkCurves->Checked = ini->ReadBool(\"AutoCAD\",\"ExportCurves\",true);\n  ...\n  761      count += ExportBusstops;\n  762      count += ExportRoadSideObjects;\n  763:     count += ExportSlope;\n  764      count += ExportCurves;\n  765      count += ExportMoundHeights;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign.ini:\n   42  ExportSignal=1\n   43  ExportTubes=1\n   44: ExportSlopes=1\n   45  ExportCurves=1\n   46  ExportTable=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.ini:\n   42  ExportSignal=1\n   43  ExportTubes=1\n   44: ExportSlopes=1\n   45  ExportCurves=1\n   46  ExportTable=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ОДН.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ОДН_петя.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД (область) А3.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД (область).ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город-175.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город_250.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ТП-город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\журнал для ПОДД.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\новый.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\техпаспорт А4 - насыпи.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=0\n   13: ExportSlopes=0\n   14  ExportCurves=0\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт - только знаки.ini:\n   10  ExportSignal=0\n   11  ExportTubes=0\n   12: ExportSlopes=0\n   13  ExportCurves=0\n   14  ExportMoundHeights=0\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=0\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_1-2000.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_1-2000_насыпи.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=0\n   13: ExportSlopes=0\n   14  ExportCurves=0\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\n71 matches across 27 files\n\n\nSearching 2114 files for \"DrawRepeatVerticalTextInterval\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2923          if (iTopSlopes >= 0) {\n 2924              tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2925:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2926          }\n 2927          if (iBottomSlopes >= 0) {\n 2928              tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2929:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2930          }\n 2931          if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n ....\n 2934          if (iTopSlopes >= 0) {\n 2935              tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2936:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2937          }\n 2938          if (iBottomSlopes >= 0) {\n 2939              tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2940:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2941          }\n 2942          if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n ....\n 2945          if (iTopSlopes >= 0) {\n 2946              tableTop.DrawLine(iTopSlopes, s->LMin, tableTop.kBottomEmptyPadding, s->LMax, tableTop.kBottomEmptyPadding);\n 2947:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2948          }\n 2949          if (iBottomSlopes >= 0) {\n 2950              tableBottom.DrawLine(iBottomSlopes, s->LMin, tableBottom.kBottomEmptyPadding, s->LMax, tableBottom.kBottomEmptyPadding);\n 2951:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2952          }\n 2953      }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1955  }\n 1956  \n 1957: void AutoCADTable::DrawRepeatVerticalTextInterval(int iRow,\n 1958                                  float sPos, float ePos,float kyPos,\n 1959                                  float step, bool fWithBorders, float kProp)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  237  \n  238  \n  239:         void DrawRepeatVerticalTextInterval(int iRow,float sPos, float ePos,\n  240                                  float step = 0,float kyPos = 0.75,\n  241                                  bool fWithBorders = true, float kProp = 0.43);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n19 matches across 5 files\n\n\nSearching 2114 files for \"DrawVerticalText\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2789                      }\n 2790                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2791:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2792                  }\n 2793                  if (iBottomCurves >= 0) {\n ....\n 2801                      }\n 2802                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2803:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2804                  }\n 2805              } else if (lKind == ckCircle) {\n ....\n 2814                      }\n 2815                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2816:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2817                  }\n 2818                  if (iBottomCurves >= 0) {\n ....\n 2826                      }\n 2827                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2828:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2829                  }\n 2830              }\n ....\n 2845                      }\n 2846                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2847:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2848                  }\n 2849                  if (iBottomCurves >= 0) {\n ....\n 2857                      }\n 2858                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2859:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2860                  }\n 2861              } else if (lKind == ckCircle) {\n ....\n 2870                      }\n 2871                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2872:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2873                  }\n 2874                  if (iBottomCurves >= 0) {\n ....\n 2882                      }\n 2883                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2884:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2885                  }\n 2886              }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1985       if(sPos<iMin*step){\n 1986           if(int(sPos)%int(step) == 0){\n 1987:              DrawVerticalText(0,iRow,sPos,1-kyPos,true,kProp);\n 1988           }\n 1989           temp = iMin*step;\n 1990:          DrawVerticalText(1000,iRow,temp,kyPos,false,kProp);\n 1991           pos[counter++] = iMin*step;\n 1992       }\n 1993       for(int i=iMin;i<iMax-1;i++){\n 1994           temp = i*step;\n 1995:          DrawVerticalText(0,iRow,temp,1-kyPos,true,kProp);\n 1996           temp = (i+1)*step;\n 1997:          DrawVerticalText(1000,iRow,temp,kyPos,false,kProp);\n 1998       }\n 1999       if(ePos>(iMax-1)*step){\n 2000          temp = (iMax-1)*step;\n 2001:         DrawVerticalText(0,iRow,temp,1-kyPos,true,kProp);\n 2002          pos[counter++] = ePos;\n 2003:         DrawVerticalText(int(ePos)%int(step)/100,iRow,ePos,kyPos,false,kProp);\n 2004       }\n 2005       if(fWithBorders) DrawSnakeBorder(iRow,pos,counter);\n ....\n 2007     }else{\n 2008       if(int(sPos)%int(step) == 0){\n 2009:          DrawVerticalText(0,iRow,sPos,1-kyPos,true,kProp);\n 2010       }\n 2011       if(int(ePos)%int(step)==0){\n 2012:        DrawVerticalText(1000,iRow,ePos,1-kyPos,true,kProp);\n 2013       }else{\n 2014:        DrawVerticalText(int(ePos)%int(step)/100,iRow,ePos,kyPos,false,kProp);\n 2015       }\n 2016  \n ....\n 2054  }\n 2055  \n 2056: AcadTextPtr AutoCADTable::DrawVerticalText(AnsiString txt, int iRow, float Pos,\n 2057                                           float kyPos,bool fRight, float kProp)\n 2058  {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  166                                      bool fWithBorders = true,float kProp = 0.43);\n  167          void DrawHeaderText(int row,AnsiString str, float kProp = 0.34);\n  168:         AcadTextPtr DrawVerticalText(AnsiString txt, int iRow, float Pos, float kyPos = 0.5,\n  169                                          bool fRight = true, float kProp = 0.2);\n  170          /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n30 matches across 5 files\n\n\nSearching 2114 files for \"minE\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  138            }\n  139            minS = -1;\n  140:           minE = -1;          \n  141          }        \n  142  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\DBDataSource.cpp:\n 2129  DB->Connection=FConnection;\n 2130  DB->CommandText=String(\"insert into ListDataSources (FullTitle,NumRoad,NumType,\\\n 2131:         NumOrganization,Executor,Examiner,DateCreate,DateBegin)\\\n 2132          values ('\")+PrjName+String(\"',\")+String(RoadId)+String(\",3,\")+String(OrgNum)+\n 2133          String(\",'\")+ExecName+String(\"','\")+ExamName+\n\nD:\\_DISTR\\_ASUDOR\\RSign\\GdiEdit.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\LICENSE:\n  102  \n  103    An interactive user interface displays \"Appropriate Legal Notices\"\n  104: to the extent that it includes a convenient and prominently visible\n  105  feature that (1) displays an appropriate copyright notice, and (2)\n  106  tells the user that there is no warranty for the work (except to the\n  ...\n  108  work under this License, and how to view a copy of this License.  If\n  109  the interface presents a list of user commands or options, such as a\n  110: menu, a prominent item in the list meets this criterion.\n  111  \n  112    1. Source Code.\n  ...\n  212  terms of section 4, provided that you also meet all of these conditions:\n  213  \n  214:     a) The work must carry prominent notices stating that you modified\n  215      it, and giving a relevant date.\n  216  \n  217:     b) The work must carry prominent notices stating that it is\n  218      released under this License and any conditions added under section\n  219      7.  This requirement modifies the requirement in section 4 to\n\nD:\\_DISTR\\_ASUDOR\\RSign\\OpenSource.cpp:\n   18  {\n   19  if(ADODataSet1->Active) ADODataSet1->Active=false;\n   20: ADODataSet1->CommandText=\"select id_,FullTitle,Executor,Examiner,DateCreate,NumType\\\n   21   from ListDataSources where NumRoad=\"+String(RoadId)+\" or id_<10 order by id_\";\n   22  if(!ADODataSet1->Active) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\ActiveX\\MediaPlayer_TLB.h:\n 1026    // [2010] Opens the given filename asynchronously\n 1027    virtual HRESULT STDMETHODCALLTYPE Open(BSTR bstrFileName/*[in]*/) = 0;\n 1028:   // [53] Determines whether the sound card is enabled on the machine\n 1029    virtual HRESULT STDMETHODCALLTYPE IsSoundCardEnabled(VARIANT_BOOL* pbSoundCard/*[out,retval]*/) = 0;\n 1030    // [2023] Jumps to the next item\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\_old\\_decimal.pyd:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\packages\\iTextSharp.5.5.5\\AGPL.txt:\n   90  \n   91    An interactive user interface displays \"Appropriate Legal Notices\"\n   92: to the extent that it includes a convenient and prominently visible\n   93  feature that (1) displays an appropriate copyright notice, and (2)\n   94  tells the user that there is no warranty for the work (except to the\n   ..\n   96  work under this License, and how to view a copy of this License.  If\n   97  the interface presents a list of user commands or options, such as a\n   98: menu, a prominent item in the list meets this criterion.\n   99  \n  100    1. Source Code.\n  ...\n  200  terms of section 4, provided that you also meet all of these conditions:\n  201  \n  202:     a) The work must carry prominent notices stating that you modified\n  203      it, and giving a relevant date.\n  204  \n  205:     b) The work must carry prominent notices stating that it is\n  206      released under this License and any conditions added under section\n  207      7.  This requirement modifies the requirement in section 4 to\n  ...\n  541  \n  542    Notwithstanding any other provision of this License, if you modify the\n  543: Program, your modified version must prominently offer all users\n  544  interacting with it remotely through a computer network (if your version\n  545  supports such interaction) an opportunity to receive the Corresponding\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\packages\\iTextSharp.5.5.5\\lib\\iTextSharp.xml:\n  427              Applies the properties of the Anchor to a Chunk.\n  428              @param chunk			the Chunk (part of the Anchor)\n  429:             @param notGotoOK		if true, this chunk will determine the local destination\n  430              @param localDestination	true if the chunk is a local goto and the reference a local destination\n  431:             @return	the value of notGotoOK or false, if a previous Chunk was used to determine the local destination\n  432          </member>\n  433          <member name=\"P:iTextSharp.text.Anchor.Chunks\">\n  ...\n 9463              These are applied later in the line-based phase of the algorithm.\n 9464          </member>\n 9465:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineParagraphEmbeddingLevel\" проигнорирован -->\n 9466:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineExplicitEmbeddingLevels\" проигнорирован -->\n 9467          <member name=\"M:iTextSharp.text.pdf.BidiOrder.RemoveExplicitCodes\">\n 9468              Rules X9.\n ....\n 9487              \n 9488               The interaction of these rules makes handling them a bit complex.\n 9489:              This examines resultTypes but does not modify it.  It returns embedding and\n 9490               override information in the result array.  The low 7 bits are the level, the high\n 9491               bit is set if the level is an override, and clear if it is an embedding.\n ....\n 14827               a binary tree but a lot less than a trie. Performance is\n 14828               comparable with a hash table, sometimes it outperforms a hash\n 14829:              function (most of the time can determine a miss faster than a hash).</p>\n 14830              \n 14831               <p>The main purpose of this java port is to serve as a base for\n .....\n 15725          </member>\n 15726          <member name=\"M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk,iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)\">\n 15727:             Determines if a space character should be inserted between a previous chunk and the current chunk.\n 15728              This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.\n 15729              By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the\n .....\n 15848          </member>\n 15849          <member name=\"M:iTextSharp.text.pdf.parser.MarkedContentInfo.HasMcid\">\n 15850:             Determine if an MCID is available\n 15851              @return true if the MCID is available, false otherwise\n 15852          </member>\n .....\n 16424              being a true representation of how it appears in the PDF.\n 16425              \n 16426:             This renderer also uses a simple strategy based on the font metrics to determine if\n 16427              a blank space should be inserted into the output.\n 16428              \n .....\n 16641          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.GetRise\">\n 16642              The rise represents how far above the nominal baseline the text should be rendered.  The {@link #getBaseline()}, {@link #getAscentLine()} and {@link #getDescentLine()} methods already include Rise.\n 16643:             This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)\n 16644              @return The Rise for the text draw operation, in user space units (Ts value, scaled to user space)\n 16645              @since 5.3.3\n .....\n 16710          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.Decode(iTextSharp.text.pdf.PdfString)\">\n 16711              Decodes a PdfString (which will contain glyph ids encoded in the font's encoding)\n 16712:             based on the active font, and determine the unicode equivalent\n 16713              @param in	the String that needs to be encoded\n 16714              @return	    the encoded String\n .....\n 17296          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Clip\">\n 17297              Modify the current clipping path by intersecting it with the current path, using the\n 17298:             nonzero winding number rule to determine which regions lie inside the clipping\n 17299              path.\n 17300          </member>\n 17301          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoClip\">\n 17302              Modify the current clipping path by intersecting it with the current path, using the\n 17303:             even-odd rule to determine which regions lie inside the clipping path.\n 17304          </member>\n 17305          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.SetGrayFill(System.Single)\">\n .....\n 17462          </member>\n 17463          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Fill\">\n 17464:             Fills the path, using the non-zero winding number rule to determine the region to fill.\n 17465          </member>\n 17466          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFill\">\n 17467:             Fills the path, using the even-odd rule to determine the region to fill.\n 17468          </member>\n 17469          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.FillStroke\">\n 17470:             Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.\n 17471          </member>\n 17472          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathFillStroke\">\n 17473:             Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.\n 17474          </member>\n 17475          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFillStroke\">\n 17476:             Fills the path, using the even-odd rule to determine the region to fill and strokes it.\n 17477          </member>\n 17478          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathEoFillStroke\">\n 17479:             Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.\n 17480          </member>\n 17481          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image)\">\n .....\n 20281          </member>\n 20282          <member name=\"P:iTextSharp.text.pdf.PdfGState.TextKnockout\">\n 20283:             Determines the behaviour of overlapping glyphs within a text object\n 20284              in the transparent imaging model.\n 20285              @param v\n .....\n 24560          </member>\n 24561          <member name=\"M:iTextSharp.text.pdf.PdfPTable.GetFittingRows(System.Single,System.Int32)\">\n 24562:             Determine which rows fit on the page, respecting isSplitLate().\n 24563              Note: sets max heights of the inspected rows as a side effect,\n 24564              just like PdfPTable.getRowHeight(int, boolean) does.\n .....\n 25486          </member>\n 25487          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FormFlattening\">\n 25488:             Determines if the fields are flattened on close. The fields added with\n 25489              {@link #addAnnotation(PdfAnnotation,int)} will never be flattened.\n 25490              @param flat <CODE>true</CODE> to flatten the fields, <CODE>false</CODE>\n .....\n 25492          </member>\n 25493          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FreeTextFlattening\">\n 25494:             Determines if the FreeText annotations are flattened on close. \n 25495              @param flat <CODE>true</CODE> to flatten the FreeText annotations, <CODE>false</CODE>\n 25496              (the default) to keep the FreeText annotations as active content.\n .....\n 26002          <member name=\"M:iTextSharp.text.pdf.PRTokeniser.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)\">\n 26003              Creates a PRTokeniser for the specified {@link RandomAccessSource}.\n 26004:             The beginning of the file is read to determine the location of the header, and the data source is adjusted\n 26005              as necessary to account for any junk that occurs in the byte source before the header\n 26006              @param file the source\n .....\n 29237                 rejection              (2), -- you don't get it, more information elsewhere in the message\n 29238                 waiting                (3), -- the request body part has not yet been processed, expect to hear more later\n 29239:                revocationWarning      (4), -- this message contains a warning that a revocation is imminent\n 29240                 revocationNotification (5), -- notification that a revocation has occurred\n 29241                 keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg\n .....\n 34802          </member>\n 34803          <member name=\"P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse\">\n 34804:             determines whether or not strings should be processed and printed\n 34805              from back to front.\n 34806          </member>\n .....\n 38099               Convenience Method for data exchange with the cipher.\n 38100              \n 38101:              Determines blocksize and splits data to blocksize.\n 38102              \n 38103               @param data the data to be processed\n .....\n 38267               word <em>x</em> is rotated left by <em>y</em> bits.\n 38268               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38269:              are used to determine the rotation amount. Here it is\n 38270               assumed that the wordsize used is a power of 2.\n 38271              \n .....\n 38277               word <em>x</em> is rotated left by <em>y</em> bits.\n 38278               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38279:              are used to determine the rotation amount. Here it is\n 38280               assumed that the wordsize used is a power of 2.\n 38281              \n .....\n 38320               word <em>x</em> is rotated left by <em>y</em> bits.\n 38321               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38322:              are used to determine the rotation amount. Here it is\n 38323               assumed that the wordsize used is a power of 2.\n 38324              \n .....\n 38330               word <em>x</em> is rotated left by <em>y</em> bits.\n 38331               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38332:              are used to determine the rotation amount. Here it is\n 38333               assumed that the wordsize used is a power of 2.\n 38334              \n .....\n 38360               word <em>x</em> is rotated left by <em>y</em> bits.\n 38361               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38362:              are used to determine the rotation amount. Here it is\n 38363               assumed that the wordsize used is a power of 2.\n 38364              \n .....\n 38370               word <em>x</em> is rotated left by <em>y</em> bits.\n 38371               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38372:              are used to determine the rotation amount. Here it is\n 38373               assumed that the wordsize used is a power of 2.\n 38374              \n .....\n 41283          <member name=\"M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])\">\n 41284              <summary>\n 41285:             Reports the session ID once it has been determined.\n 41286              </summary>\n 41287              <param name=\"sessionID\">\n .....\n 42928              Open a literal data packet, returning a stream to store the data inside the packet,\n 42929              as an indefinite length stream. The stream is written out as a series of partial\n 42930:             packets with a chunk size determined by the size of the passed in buffer.\n 42931              </p>\n 42932              <p>\n .....\n 47227               RestoreAfterInsert\n 47228               Additions to red-black trees usually destroy the red-black \n 47229:              properties. Examine the tree and restore. Rotations are normally \n 47230               required to restore it\n 47231              </summary>\n .....\n 47257               RestoreAfterDelete\n 47258               Deletions from red-black trees may destroy the red-black \n 47259:              properties. Examine the tree and restore. Rotations are normally \n 47260               required to restore it\n 47261              </summary>\n .....\n 47268          <member name=\"M:System.util.collections.OrderedTreeEnumerator.#ctor(System.util.collections.OrderedTreeNode,System.Boolean,System.Boolean,System.util.collections.OrderedTreeNode)\">\n 47269              <summary>\n 47270:              Determine order, walk the tree and push the nodes onto the stack\n 47271              </summary>\n 47272          </member>\n .....\n 47808          </member>\n 47809          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.sources\">\n 47810:             The underlying sources (along with some meta data to quickly determine where each source begins and ends)\n 47811          </member>\n 47812          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.currentSourceEntry\">\n .....\n 47938          <member name=\"P:iTextSharp.text.io.RAFRandomAccessSource.Length\">\n 47939              {@inheritDoc}\n 47940:             Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes\n 47941              after construction, that change will not be reflected in this call.\n 47942          </member>\n .....\n 47959          </member>\n 47960          <member name=\"M:iTextSharp.text.io.RandomAccessSourceFactory.SetForceRead(System.Boolean)\">\n 47961:             Determines whether the full content of the source will be read into memory\n 47962              @param forceRead true if the full content will be read, false otherwise\n 47963              @return this object (this allows chaining of method calls)\n .....\n 50439          </member>\n 50440          <member name=\"T:iTextSharp.text.xml.simpleparser.INewLineHandler\">\n 50441:              A NewLineHandler determines if an encountered tag should result in a new line\n 50442               in a document.\n 50443              \n .....\n 51741          <member name=\"M:iTextSharp.xmp.impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)\">\n 51742              <summary>\n 51743:             Determines the ID for a certain RDF Term.\n 51744              Arranged to hopefully minimize the parse time for large XMP.\n 51745              </summary>\n .....\n 53509          <member name=\"M:iTextSharp.xmp.IXmpSchemaRegistry.ResolveAlias(System.String,System.String)\">\n 53510              <summary>\n 53511:             Determines if a name is an alias, and what it is aliased to.\n 53512              </summary>\n 53513              <param name=\"aliasNs\">\n .....\n 55933                                  -- a brief description or identifier of the encValue content\n 55934                                  -- (may be meaningful only to the sending entity, and used only\n 55935:                                 -- if EncryptedValue might be re-examined by the sending entity\n 55936                                  -- in the future)\n 55937                                  encValue       BIT STRING }\n .....\n 56502          </member>\n 56503          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.ContainsKey(`0)\">\n 56504:             <summary>Determines whether the <see cref=\"T:ReadOnlyDictionary`2\" />\n 56505              contains the specified key.</summary>\n 56506              <returns>\n .....\n 56550          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})\">\n 56551              <summary>\n 56552:             Determines whether the <see cref=\"T:ICollection`1\"/> contains a\n 56553              specific value.\n 56554              </summary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\PDFBinder\\bin\\Release\\itextsharp.xml:\n  427              Applies the properties of the Anchor to a Chunk.\n  428              @param chunk			the Chunk (part of the Anchor)\n  429:             @param notGotoOK		if true, this chunk will determine the local destination\n  430              @param localDestination	true if the chunk is a local goto and the reference a local destination\n  431:             @return	the value of notGotoOK or false, if a previous Chunk was used to determine the local destination\n  432          </member>\n  433          <member name=\"P:iTextSharp.text.Anchor.Chunks\">\n  ...\n 9463              These are applied later in the line-based phase of the algorithm.\n 9464          </member>\n 9465:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineParagraphEmbeddingLevel\" проигнорирован -->\n 9466:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineExplicitEmbeddingLevels\" проигнорирован -->\n 9467          <member name=\"M:iTextSharp.text.pdf.BidiOrder.RemoveExplicitCodes\">\n 9468              Rules X9.\n ....\n 9487              \n 9488               The interaction of these rules makes handling them a bit complex.\n 9489:              This examines resultTypes but does not modify it.  It returns embedding and\n 9490               override information in the result array.  The low 7 bits are the level, the high\n 9491               bit is set if the level is an override, and clear if it is an embedding.\n ....\n 14827               a binary tree but a lot less than a trie. Performance is\n 14828               comparable with a hash table, sometimes it outperforms a hash\n 14829:              function (most of the time can determine a miss faster than a hash).</p>\n 14830              \n 14831               <p>The main purpose of this java port is to serve as a base for\n .....\n 15725          </member>\n 15726          <member name=\"M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk,iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)\">\n 15727:             Determines if a space character should be inserted between a previous chunk and the current chunk.\n 15728              This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.\n 15729              By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the\n .....\n 15848          </member>\n 15849          <member name=\"M:iTextSharp.text.pdf.parser.MarkedContentInfo.HasMcid\">\n 15850:             Determine if an MCID is available\n 15851              @return true if the MCID is available, false otherwise\n 15852          </member>\n .....\n 16424              being a true representation of how it appears in the PDF.\n 16425              \n 16426:             This renderer also uses a simple strategy based on the font metrics to determine if\n 16427              a blank space should be inserted into the output.\n 16428              \n .....\n 16641          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.GetRise\">\n 16642              The rise represents how far above the nominal baseline the text should be rendered.  The {@link #getBaseline()}, {@link #getAscentLine()} and {@link #getDescentLine()} methods already include Rise.\n 16643:             This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)\n 16644              @return The Rise for the text draw operation, in user space units (Ts value, scaled to user space)\n 16645              @since 5.3.3\n .....\n 16710          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.Decode(iTextSharp.text.pdf.PdfString)\">\n 16711              Decodes a PdfString (which will contain glyph ids encoded in the font's encoding)\n 16712:             based on the active font, and determine the unicode equivalent\n 16713              @param in	the String that needs to be encoded\n 16714              @return	    the encoded String\n .....\n 17296          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Clip\">\n 17297              Modify the current clipping path by intersecting it with the current path, using the\n 17298:             nonzero winding number rule to determine which regions lie inside the clipping\n 17299              path.\n 17300          </member>\n 17301          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoClip\">\n 17302              Modify the current clipping path by intersecting it with the current path, using the\n 17303:             even-odd rule to determine which regions lie inside the clipping path.\n 17304          </member>\n 17305          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.SetGrayFill(System.Single)\">\n .....\n 17462          </member>\n 17463          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Fill\">\n 17464:             Fills the path, using the non-zero winding number rule to determine the region to fill.\n 17465          </member>\n 17466          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFill\">\n 17467:             Fills the path, using the even-odd rule to determine the region to fill.\n 17468          </member>\n 17469          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.FillStroke\">\n 17470:             Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.\n 17471          </member>\n 17472          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathFillStroke\">\n 17473:             Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.\n 17474          </member>\n 17475          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFillStroke\">\n 17476:             Fills the path, using the even-odd rule to determine the region to fill and strokes it.\n 17477          </member>\n 17478          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathEoFillStroke\">\n 17479:             Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.\n 17480          </member>\n 17481          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image)\">\n .....\n 20281          </member>\n 20282          <member name=\"P:iTextSharp.text.pdf.PdfGState.TextKnockout\">\n 20283:             Determines the behaviour of overlapping glyphs within a text object\n 20284              in the transparent imaging model.\n 20285              @param v\n .....\n 24560          </member>\n 24561          <member name=\"M:iTextSharp.text.pdf.PdfPTable.GetFittingRows(System.Single,System.Int32)\">\n 24562:             Determine which rows fit on the page, respecting isSplitLate().\n 24563              Note: sets max heights of the inspected rows as a side effect,\n 24564              just like PdfPTable.getRowHeight(int, boolean) does.\n .....\n 25486          </member>\n 25487          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FormFlattening\">\n 25488:             Determines if the fields are flattened on close. The fields added with\n 25489              {@link #addAnnotation(PdfAnnotation,int)} will never be flattened.\n 25490              @param flat <CODE>true</CODE> to flatten the fields, <CODE>false</CODE>\n .....\n 25492          </member>\n 25493          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FreeTextFlattening\">\n 25494:             Determines if the FreeText annotations are flattened on close. \n 25495              @param flat <CODE>true</CODE> to flatten the FreeText annotations, <CODE>false</CODE>\n 25496              (the default) to keep the FreeText annotations as active content.\n .....\n 26002          <member name=\"M:iTextSharp.text.pdf.PRTokeniser.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)\">\n 26003              Creates a PRTokeniser for the specified {@link RandomAccessSource}.\n 26004:             The beginning of the file is read to determine the location of the header, and the data source is adjusted\n 26005              as necessary to account for any junk that occurs in the byte source before the header\n 26006              @param file the source\n .....\n 29237                 rejection              (2), -- you don't get it, more information elsewhere in the message\n 29238                 waiting                (3), -- the request body part has not yet been processed, expect to hear more later\n 29239:                revocationWarning      (4), -- this message contains a warning that a revocation is imminent\n 29240                 revocationNotification (5), -- notification that a revocation has occurred\n 29241                 keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg\n .....\n 34802          </member>\n 34803          <member name=\"P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse\">\n 34804:             determines whether or not strings should be processed and printed\n 34805              from back to front.\n 34806          </member>\n .....\n 38099               Convenience Method for data exchange with the cipher.\n 38100              \n 38101:              Determines blocksize and splits data to blocksize.\n 38102              \n 38103               @param data the data to be processed\n .....\n 38267               word <em>x</em> is rotated left by <em>y</em> bits.\n 38268               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38269:              are used to determine the rotation amount. Here it is\n 38270               assumed that the wordsize used is a power of 2.\n 38271              \n .....\n 38277               word <em>x</em> is rotated left by <em>y</em> bits.\n 38278               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38279:              are used to determine the rotation amount. Here it is\n 38280               assumed that the wordsize used is a power of 2.\n 38281              \n .....\n 38320               word <em>x</em> is rotated left by <em>y</em> bits.\n 38321               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38322:              are used to determine the rotation amount. Here it is\n 38323               assumed that the wordsize used is a power of 2.\n 38324              \n .....\n 38330               word <em>x</em> is rotated left by <em>y</em> bits.\n 38331               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38332:              are used to determine the rotation amount. Here it is\n 38333               assumed that the wordsize used is a power of 2.\n 38334              \n .....\n 38360               word <em>x</em> is rotated left by <em>y</em> bits.\n 38361               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38362:              are used to determine the rotation amount. Here it is\n 38363               assumed that the wordsize used is a power of 2.\n 38364              \n .....\n 38370               word <em>x</em> is rotated left by <em>y</em> bits.\n 38371               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38372:              are used to determine the rotation amount. Here it is\n 38373               assumed that the wordsize used is a power of 2.\n 38374              \n .....\n 41283          <member name=\"M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])\">\n 41284              <summary>\n 41285:             Reports the session ID once it has been determined.\n 41286              </summary>\n 41287              <param name=\"sessionID\">\n .....\n 42928              Open a literal data packet, returning a stream to store the data inside the packet,\n 42929              as an indefinite length stream. The stream is written out as a series of partial\n 42930:             packets with a chunk size determined by the size of the passed in buffer.\n 42931              </p>\n 42932              <p>\n .....\n 47227               RestoreAfterInsert\n 47228               Additions to red-black trees usually destroy the red-black \n 47229:              properties. Examine the tree and restore. Rotations are normally \n 47230               required to restore it\n 47231              </summary>\n .....\n 47257               RestoreAfterDelete\n 47258               Deletions from red-black trees may destroy the red-black \n 47259:              properties. Examine the tree and restore. Rotations are normally \n 47260               required to restore it\n 47261              </summary>\n .....\n 47268          <member name=\"M:System.util.collections.OrderedTreeEnumerator.#ctor(System.util.collections.OrderedTreeNode,System.Boolean,System.Boolean,System.util.collections.OrderedTreeNode)\">\n 47269              <summary>\n 47270:              Determine order, walk the tree and push the nodes onto the stack\n 47271              </summary>\n 47272          </member>\n .....\n 47808          </member>\n 47809          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.sources\">\n 47810:             The underlying sources (along with some meta data to quickly determine where each source begins and ends)\n 47811          </member>\n 47812          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.currentSourceEntry\">\n .....\n 47938          <member name=\"P:iTextSharp.text.io.RAFRandomAccessSource.Length\">\n 47939              {@inheritDoc}\n 47940:             Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes\n 47941              after construction, that change will not be reflected in this call.\n 47942          </member>\n .....\n 47959          </member>\n 47960          <member name=\"M:iTextSharp.text.io.RandomAccessSourceFactory.SetForceRead(System.Boolean)\">\n 47961:             Determines whether the full content of the source will be read into memory\n 47962              @param forceRead true if the full content will be read, false otherwise\n 47963              @return this object (this allows chaining of method calls)\n .....\n 50439          </member>\n 50440          <member name=\"T:iTextSharp.text.xml.simpleparser.INewLineHandler\">\n 50441:              A NewLineHandler determines if an encountered tag should result in a new line\n 50442               in a document.\n 50443              \n .....\n 51741          <member name=\"M:iTextSharp.xmp.impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)\">\n 51742              <summary>\n 51743:             Determines the ID for a certain RDF Term.\n 51744              Arranged to hopefully minimize the parse time for large XMP.\n 51745              </summary>\n .....\n 53509          <member name=\"M:iTextSharp.xmp.IXmpSchemaRegistry.ResolveAlias(System.String,System.String)\">\n 53510              <summary>\n 53511:             Determines if a name is an alias, and what it is aliased to.\n 53512              </summary>\n 53513              <param name=\"aliasNs\">\n .....\n 55933                                  -- a brief description or identifier of the encValue content\n 55934                                  -- (may be meaningful only to the sending entity, and used only\n 55935:                                 -- if EncryptedValue might be re-examined by the sending entity\n 55936                                  -- in the future)\n 55937                                  encValue       BIT STRING }\n .....\n 56502          </member>\n 56503          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.ContainsKey(`0)\">\n 56504:             <summary>Determines whether the <see cref=\"T:ReadOnlyDictionary`2\" />\n 56505              contains the specified key.</summary>\n 56506              <returns>\n .....\n 56550          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})\">\n 56551              <summary>\n 56552:             Determines whether the <see cref=\"T:ICollection`1\"/> contains a\n 56553              specific value.\n 56554              </summary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net35\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net40\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net45\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\n124 matches across 15 files\n\n\nSearching 2114 files for \"minE\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  138            }\n  139            minS = -1;\n  140:           minE = -1;          \n  141          }        \n  142  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n6 matches across 3 files\n\n\nSearching 2114 files for \"minS\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  137                 RowslEnd[i] = gFillGapsBegin;\n  138            }\n  139:           minS = -1;\n  140            minE = -1;          \n  141          }        \n\nD:\\_DISTR\\_ASUDOR\\RSign\\GdiEdit.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n14 matches across 4 files\n\n\nSearching 2114 files for \"RowslEnd\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1309    gFillGaps = 0;\n 1310    LeftTop = _LeftTop;\n 1311:   RowslEnd = 0;\n 1312    RowsCount = _RowsCount;\n 1313    FillGaps[-1] = true;\n ....\n 1332     if(iRow==-1){\n 1333       for(int i=0;i<RowsCount;i++){\n 1334:         if(gFillGaps[i]) DrawRepeatEmptyInterval(i,RowslEnd[i],TableWidth,step,true);\n 1335       }\n 1336     }else{\n 1337:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],TableWidth,step,true);\n 1338     }\n 1339  }\n ....\n 1648  \n 1649  \n 1650:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 1651:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 1652     }\n 1653  \n ....\n 1720     }\n 1721  \n 1722:    RowslEnd[iRow] = ePos;\n 1723     delete[] pos;\n 1724  }\n ....\n 1755  \n 1756  \n 1757:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 1758:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 1759     }\n 1760  \n ....\n 1781     }\n 1782  \n 1783:    RowslEnd[iRow] = ePos;\n 1784     delete[] pos;\n 1785  }\n ....\n 1951     }\n 1952  \n 1953:    RowslEnd[iRow] = ePos;\n 1954     delete[] pos;\n 1955  }\n ....\n 2018     }\n 2019  \n 2020:    RowslEnd[iRow] = ePos;\n 2021     delete[] pos;\n 2022  }\n ....\n 2187                              bool fWithBorders ,float kProp)\n 2188  {\n 2189:   if (RowslEnd[row] > offBeg) offBeg = RowslEnd[row];\n 2190    if(offEnd <= offBeg) return;\n 2191  \n ....\n 2255     pos[0] = sPos;\n 2256  \n 2257:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 2258:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 2259     }\n 2260     emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n ....\n 2286     }\n 2287     delete[] pos;\n 2288:    RowslEnd[iRow] = ePos;\n 2289     \n 2290  #undef DRAWTEXT\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd;\n   71  \n   72          float iRowsFullHeight;\n   ..\n   80  \n   81                  iRowsFullHeight = gRowsCount*gRowHeight;\n   82:                 if(RowslEnd) delete[] RowslEnd;\n   83:                 RowslEnd = new float[value];\n   84                  SetFillGapsBegin(gFillGapsBegin);\n   85                  /*if(gFillGaps)\n   ..\n  126              if(gFillGapsBegin!=value) gFillGapsBegin = value;\n  127              for(int i=0;i<gRowsCount;i++){\n  128:                RowslEnd[i] = value;\n  129                 emptyMin[i] = value;\n  130              }\n  ...\n  135            fFirst = true;\n  136            for(int i=0;i<gRowsCount;i++){\n  137:                RowslEnd[i] = gFillGapsBegin;\n  138            }      \n  139          }        \n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n26 matches across 4 files\n\n\nSearching 2114 files for \"DrawEmpty\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1521  }\n 1522  \n 1523: void AutoCADTable::DrawEmpty(int iRow, float offsetBegin, float offsetEnd,\n 1524                               bool fWithBorders, bool fWithoutFill, bool fInc )\n 1525  {\n ....\n 1600     if(iMin!=iMax){\n 1601       if(sPos<iMin*step){\n 1602:          DrawEmpty(iRow,sPos,iMin*step,false,fWithoutFill, fInc);\n 1603           pos[counter++] = iMin*step;\n 1604       }\n 1605       for(int i=iMin;i<iMax-1;i++){\n 1606:          DrawEmpty(iRow,i*step,(i+1)*step,false,fWithoutFill, fInc);\n 1607           pos[counter++] = (i+1)*step;\n 1608       }\n 1609       if(ePos>(iMax-1)*step){\n 1610:         DrawEmpty(iRow,(iMax-1)*step,ePos,false,fWithoutFill, fInc);\n 1611          pos[counter++] = ePos;\n 1612       }\n 1613       if(fWithBorders)DrawSnakeBorder(iRow,pos,counter);\n 1614     }else{\n 1615:      DrawEmpty(iRow, sPos, ePos, false, fWithoutFill, fInc);\n 1616       if(fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n 1617     }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  182          void DrawSnakeBorder(int iRow, float sPos, float ePos);\n  183  \n  184:         void DrawEmpty(int Row, float offsetBegin, float offsetEnd,\n  185                          bool fWithBorders, bool fWithoutFill, bool fInc);\n  186  \n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n22 matches across 4 files\n\n\nSearching 2114 files for \"iStep\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  360                                  + \"\\r\\n\" + IntToStr((int)tableBottom.FillGapsBegin)\n  361                                  + \"\\r\\n\" + IntToStr((int)tableBottom.TableWidth)\n  362:                                 + \"\\r\\n\" + IntToStr((int)iStep)\n  363                                  + \"\\r\\n# высота верхней таблицы\"\n  364                                  + \"\\r\\n# высота нижней таблицы\"\n  ...\n  563      tableGraphic.LeftTop = AutoCADPoint(0, -form->RCenter - tableBottom.TableHeight);\n  564  \n  565:     iStep = form->Step;\n  566      return true;\n  567  }\n  ...\n 1313      float posOffset = 0.25 * ScaleY;\n 1314      if (!fUnderRoad && !fDrawMap) {\n 1315:         int framePos = (LPos / 100) % (iStep / 100);\n 1316          if (framePos <= 30 * posOffset) {\n 1317              tyOffset += (rotationHandle == -M_PI / 2) ? 3000 * posOffset : -3000 * posOffset;\n 1318:         } else if ( (iStep / 100) - framePos <= 30 * posOffset ) {\n 1319              tyOffset += (rotationHandle == -M_PI / 2) ? -3000 * posOffset : 3000 * posOffset;\n 1320          }\n ....\n 1524  \n 1525      if (!fDrawMap) {\n 1526:         curStep = lastStep = Poly->Points[0].x / iStep;\n 1527          for (int i = 1; i < Poly->Count; ++i) {\n 1528:             curStep = Poly->Points[i].x / iStep;\n 1529  \n 1530              if (curStep != lastStep) {\n 1531:                 centerPoint = GetCenterOnPolyline(Poly, lastStep * iStep, (lastStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n 1532                  if (centerPoint.x != -1) {\n 1533                      str = text;\n ....\n 1547              }\n 1548          }\n 1549:         centerPoint = GetCenterOnPolyline(Poly, curStep * iStep, (curStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n 1550      } else {\n 1551          centerPoint = GetCenterOnPolyline(Poly, -1, -1, &angle, &width_of_sector, &pStart, &pEnd);\n ....\n 1603                       angle);\n 1604  \n 1605:     if (length >= 15 && start != 0 && start != 1000 && start != iStep / 100) {\n 1606          AutoCAD.DrawText(IntToStr(start),\n 1607                           kPositionMarksHeight * UnderTextHeight * ScaleYBlock / 3.5,\n ....\n 1611                           M_PI_2 + angle);\n 1612      }\n 1613:     /*if (length >= 15 && end != 0 && end != 1000 && start != iStep / 100) {\n 1614          AutoCAD.DrawText(IntToStr(end),\n 1615                           kPositionMarksHeight * UnderTextHeight,\n ....\n 1662              // fill rows in tables\n 1663              if (table && line != 0) { // if we draw lines over central\n 1664:                 table->DrawRepeatTextIntervalRoadMark(iRow, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1665              } else { // if we draw central line\n 1666:                 tableTop.DrawRepeatTextIntervalRoadMark(iTop0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1667:                 tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1668              }\n 1669              if ( line >= 0 ) {\n ....\n 1768      try {\n 1769          if (fEnd) {\n 1770:             if (iTop0 != -1)tableTop.FillLastGaps(iStep, iTop0);\n 1771:             if (iBottom0 != -1)tableBottom.FillLastGaps(iStep, iBottom0);\n 1772              for (i = 0; i < iTopAxeCount; i++) {\n 1773:                 tableTop.FillLastGaps(iStep, iTopAxe - i);\n 1774              }\n 1775              for (i = 0; i < iBottomAxeCount; i++) {\n 1776:                 tableBottom.FillLastGaps(iStep, iBottomAxe + i);\n 1777              }\n 1778              return true;\n ....\n 1855  \n 1856                  if(table&&line){\n 1857:                     table->DrawRepeatTextIntervalRoadMark(iRow,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1858                  }else{\n 1859:                     tableTop.DrawRepeatTextIntervalRoadMark(iTop0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1860:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1861                  } */\n 1862  \n ....\n 2311      if (fEnd) {\n 2312          if (!fDrawMap) {\n 2313:             if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n 2314:             if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n 2315          }\n 2316          return true;\n ....\n 2475          lastStep = -9999;\n 2476          for (int i = 0; i < points.size(); i++) {\n 2477:             int step = points[i].x / iStep;\n 2478              if (step != lastStep\n 2479                      || (i == points.size() - 1 && abs(points.front().x - points.back().x) > 10000)) {\n ....\n 2547              if (block.IsBound()) lBlockLeft = block;\n 2548              lPropLeft = curProp;\n 2549:             tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2550              break;\n 2551          case opRight:\n 2552              if (block.IsBound()) lBlockRight = block;\n 2553              lPropRight = curProp;\n 2554:             tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2555              break;\n 2556          }\n ....\n 2566      if (fEnd) {\n 2567          if (!fDrawMap) {\n 2568:             if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n 2569:             if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n 2570          }\n 2571          return true;\n ....\n 2589                  switch (s->Placement) {\n 2590                  case opLeft:\n 2591:                     tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n 2592                      break;\n 2593                  case opRight:\n 2594:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n 2595                      break;\n 2596                  }\n ....\n 2648                  switch (s->Placement) {\n 2649                  case opLeft:\n 2650:                     tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n 2651                      break;\n 2652                  case opRight:\n 2653:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n 2654                      break;\n 2655                  }\n ....\n 2695                          tableTop.DrawLine(iTopMoundH, lLeftL, 0.5, m->L, 0.5);\n 2696                      }\n 2697:                     tableTop.DrawRepeatTextIntervalMoundHeight(iTopMoundH, lLeftL, m->L, lLeftHeight, m->Height, iStep);\n 2698                  }\n 2699              }\n ....\n 2714                          tableBottom.DrawLine(iBottomMoundH, lRightL, 0.5, m->L, 0.5);\n 2715                      }\n 2716:                     tableBottom.DrawRepeatTextIntervalMoundHeight(iBottomMoundH, lRightL, m->L, lRightHeight, m->Height, iStep);\n 2717                  }\n 2718              }\n ....\n 2773                  }\n 2774              }\n 2775:             tableTop.DrawRepeatTextIntervalRoadMark(iTopCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n 2776:             tableBottom.DrawRepeatTextIntervalRoadMark(iBottomCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n 2777              break;\n 2778  \n ....\n 2789                      }\n 2790                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2791:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2792                  }\n 2793                  if (iBottomCurves >= 0) {\n ....\n 2801                      }\n 2802                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2803:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2804                  }\n 2805              } else if (lKind == ckCircle) {\n ....\n 2814                      }\n 2815                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2816:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2817                  }\n 2818                  if (iBottomCurves >= 0) {\n ....\n 2826                      }\n 2827                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2828:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2829                  }\n 2830              }\n ....\n 2845                      }\n 2846                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2847:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2848                  }\n 2849                  if (iBottomCurves >= 0) {\n ....\n 2857                      }\n 2858                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2859:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2860                  }\n 2861              } else if (lKind == ckCircle) {\n ....\n 2870                      }\n 2871                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2872:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2873                  }\n 2874                  if (iBottomCurves >= 0) {\n ....\n 2882                      }\n 2883                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2884:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2885                  }\n 2886              }\n ....\n 2922      if (s->Promille > 0) {\n 2923          if (iTopSlopes >= 0) {\n 2924:             tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2925:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2926          }\n 2927          if (iBottomSlopes >= 0) {\n 2928:             tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2929:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2930          }\n 2931:         if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n 2932:         if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n 2933      } else if (s->Promille < 0) {\n 2934          if (iTopSlopes >= 0) {\n 2935:             tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2936:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2937          }\n 2938          if (iBottomSlopes >= 0) {\n 2939:             tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2940:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2941          }\n 2942:         if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n 2943:         if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n 2944      } else {\n 2945          if (iTopSlopes >= 0) {\n 2946              tableTop.DrawLine(iTopSlopes, s->LMin, tableTop.kBottomEmptyPadding, s->LMax, tableTop.kBottomEmptyPadding);\n 2947:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2948          }\n 2949          if (iBottomSlopes >= 0) {\n 2950              tableBottom.DrawLine(iBottomSlopes, s->LMin, tableBottom.kBottomEmptyPadding, s->LMax, tableBottom.kBottomEmptyPadding);\n 2951:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2952          }\n 2953      }\n ....\n 2985      if (fEnd) {\n 2986          if (!fDrawMap) {\n 2987:             if (~iTopSidewalks)tableTop.FillLastGaps(iStep, iTopSidewalks);\n 2988:             if (~iBottomSidewalks)tableBottom.FillLastGaps(iStep, iBottomSidewalks);\n 2989          }\n 2990          return true;\n ....\n 3017              case spLeft:\n 3018                  tableTop.DrawRepeatTextIntervalRoadMark(iTopSidewalks, str,\n 3019:                                                         sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n 3020                  break;\n 3021              case spRight:\n 3022                  tableBottom.DrawRepeatTextIntervalRoadMark(iBottomSidewalks, str,\n 3023:                         sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n 3024                  break;\n 3025              }\n ....\n 3208          delete paramsValues;\n 3209      } else { // просто текст\n 3210:         table->DrawRepeatTextIntervalRoadMark(iRow, str, iPos, iEnd, 0, iStep, true);\n 3211      }\n 3212  }\n ....\n 3327  \n 3328                          ExportAddRowLine(table, startCount + iRow - 1, sPos, ePos, line.Trim());\n 3329:                         //table->DrawRepeatTextIntervalSpec(startCount+iRow-1, AnsiString(s.c_str()).Trim(), sPos, ePos,0,iStep,true);\n 3330                      } catch (...) {\n 3331                          OutInfoLog(\"Ошибка вывода: \" + str2 + \" - \" + line);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n   71  \n   72  \n   73:       int iStep;   //шаг в сантиметрах   \n   74  \n   75        AutoCADTable tableTop,tableBottom, tableGraphic;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n70 matches across 4 files\n\n\nSearching 2114 files for \"GetAngle2\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  818                           pMin.x + (pMax.x - pMin.x) / 2,\n  819                           -ScaleY * (pMin.y + (pMax.y - pMin.y) / 2),\n  820:                          Helpers::GetAngle2(pMin, pMax, ScaleY)\n  821                          );\n  822      }\n  ...\n 1840  \n 1841              case ma3: /*двойная сплошная*/\n 1842:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n 1843                  DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n 1844                  for (int i = 0; i < count - 1; i++) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.cpp:\n   23  }\n   24  \n   25: float Helpers::GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length) {\n   26  \n   27      float yoffset = -ScaleY * (p2.y - p1.y);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.h:\n   11  public:\n   12      static float GetAngle(TPoint vec1, TPoint vec2);\n   13:     static float GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length=NULL);\n   14      static float GetLength(TPoint p1, TPoint p2, float ScaleY);\n   15      static bool compareSigns(const TRoadSign* s1, const TRoadSign* s2);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n11 matches across 4 files\n\n\nSearching 2114 files for \"GetAngle2\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  818                           pMin.x + (pMax.x - pMin.x) / 2,\n  819                           -ScaleY * (pMin.y + (pMax.y - pMin.y) / 2),\n  820:                          Helpers::GetAngle2(pMin, pMax, ScaleY)\n  821                          );\n  822      }\n  ...\n 1840  \n 1841              case ma3: /*двойная сплошная*/\n 1842:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n 1843                  DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n 1844                  for (int i = 0; i < count - 1; i++) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.cpp:\n   24  }\n   25  \n   26: float Helpers::GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length) {\n   27      /* Возвращает угол между вектором образованым точками p1 и p2 и осью X\n   28       * Если указан параметр length в него попадет длина вектора\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.h:\n   11  public:\n   12      static float GetAngle(TPoint vec1, TPoint vec2);\n   13:     static float GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length=NULL);\n   14      static float GetLength(TPoint p1, TPoint p2, float ScaleY);\n   15      static bool compareSigns(const TRoadSign* s1, const TRoadSign* s2);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n11 matches across 4 files\n\n\nSearching 2114 files for \"DrawTextOverPoly\" (case sensitive, whole word)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 1491  }\n 1492  \n 1493: void __fastcall TAcadExport::DrawTextOverPoly(TExtPolyline *Poly, AnsiString text,\n 1494          AnsiString(__closure *textControlFunction)(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data), void* data)\n 1495  {\n ....\n 1660                  kUnderTextHeight = 0.6 * ScaleY / 3.5;\n 1661              }\n 1662:             DrawTextOverPoly(Poly, label_under_mark, RoadMarkTextDraw, m);\n 1663  \n 1664          } else { // if we draw road mark on attachments\n ....\n 1680                  Max += 0.5 * UnderTextYOffset;\n 1681              }\n 1682:             DrawTextOverPoly(Poly, name, RoadMarkTextDraw, m);\n 1683          }\n 1684          if (Max - Min >= 1000) {\n ....\n 1850                  }\n 1851  \n 1852:                 //DrawTextOverPoly(Poly, \"1.4\", RoadMarkTextDraw);\n 1853                  break;\n 1854  \n ....\n 1917                      }\n 1918                  }\n 1919:                 DrawTextOverPoly(Poly, \"1.11\", RoadMarkTextDraw);\n 1920                  break;\n 1921  \n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n  189        void __fastcall DrawTextUnderLine(TPoint p1, TPoint p2, AnsiString text);\n  190  \n  191:       void __fastcall DrawTextOverPoly(TExtPolyline *Poly, AnsiString text,\n  192                AnsiString(__closure *textControlFunction)(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data)=0,\n  193                void* data=0);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n15 matches across 3 files\n",
			"settings":
			{
				"buffer_size": 76826,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "#include \"without_autocad.h\"\n#ifndef WITHOUT_AUTOCAD\n\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n\n#include \"AutoCADHelper.h\"\n#include \"MickMacros.h\"\n\n#pragma package(smart_init)\n\nint AutoCADHelper::GetTextWidth(AnsiString text, int Height)\n{\n    /*if(!cadActiveDocument) return -1;\n    wchar_t fontName[256];\n    short bold, italic, unuse;\n    cadActiveDocument->ActiveTextStyle->GetFont(&fontName, &bold, &italic, &unuse, &unuse);\n    BMP->Canvas->Font->Name = AnsiString(fontName);\n\n    TFontStyles style;\n    if(bold) style << fsBold;\n    if(italic) style << fsItalic;\n    BMP->Canvas->Font->Style = style;\n    BMP->Canvas->Font->Height = Height;\n                                        */\n    return BMP->Canvas->TextWidth(text);\n}\n\n/**\n* Create cadPoint\n*/\nVariant AutoCADHelper::cadPoint(double x, double y, double z)\n{\n   static bounds[2] = {0,2};\n   Variant vArray;\n   vArray = VarArrayCreate(bounds,1,varDouble);\n   double *ptr = (double*)vArray.ArrayLock();\n   ptr[0] = fInvertXAxe?-x:x;\n   ptr[1] = fInvertYAxe?-y:y;\n   ptr[2] = z;\n   vArray.ArrayUnlock();\n   return vArray; \n}\n\n\nvoid AutoCADHelper::SplitString(AnsiString str, char delim, vector<AnsiString> &out, bool fRemoveEmpties)\n{\n    int strLenght = str.Length();\n    int i,iLast = 1;\n    for(i=2;i<=strLenght;i++){\n      if(str[i]==delim){\n         if ( !fRemoveEmpties || (fRemoveEmpties && i - iLast > 0 ) ) {\n            out.push_back(str.SubString(iLast, i - iLast));\n         }\n         iLast = i + 1;\n      }\n    }\n    if ( !fRemoveEmpties || (fRemoveEmpties && strLenght - iLast + 1 > 0) ) {\n       out.push_back(str.SubString(iLast, strLenght - iLast + 1));\n    }\n}\n\nVariant AutoCADHelper::cadPointArray(double *points, int Count,\n                                    int coordCount)\n{\n   static j;\n   static bounds[2] = {0};\n   bounds[1] = Count*3-1;\n   Variant vArray;\n   vArray = VarArrayCreate(bounds,1,varDouble);\n   double *_ptr = (double*)vArray.ArrayLock();\n   switch(coordCount){\n        case 1:\n          for(j=0;j<Count;j++){\n            _ptr[j*3] = fInvertXAxe?-points[j]:points[j];\n          }\n          break;\n        case 2:\n          for(j=0;j<Count;j++){\n            _ptr[j*3] = fInvertXAxe?-points[2*j]:points[2*j];\n            _ptr[j*3 + 1] = fInvertYAxe?-points[2*j+1]:points[2*j+1];\n          }\n          break;\n        case 3:\n          memcpy(_ptr,points,Count);\n          break;\n   }\n   vArray.ArrayUnlock();\n\n   return vArray;\n}\n\nVariant AutoCADHelper::cadArray(IDispatch **objects, int count)\n{\n   static j;\n   static bounds[2] = {0};\n   bounds[1] = count-1;\n   Variant vArray;\n   vArray = VarArrayCreate(bounds,1,varDispatch);\n   IDispatch **_ptr = (IDispatch**)vArray.ArrayLock();\n\n   try {\n     for(j=0;j<count;j++){\n        _ptr[j] = objects[j];\n     }\n   }catch(...) {}\n\n   vArray.ArrayUnlock();\n   return vArray;\n}\n\nVariant AutoCADHelper::cadArray(WideString *strings, int count)\n{\n   static j;\n   static bounds[2] = {0};\n   bounds[1] = count-1;\n   Variant vArray;\n   vArray = VarArrayCreate(bounds,1, varOleStr);\n   for(j=0;j<count;j++){\n      vArray.PutElement(Variant(strings[j]),j);\n   }\n   \n   return vArray;\n}\n\nAcadLineTypePtr AutoCADHelper::getLineType(WideString name)\n{\n   try{\n     return  cadActiveDocument->Linetypes->Item(Variant(name));\n   }catch(...){\n     return AcadLineTypePtr();\n   }\n}\n\nAcadDocumentPtr &AutoCADHelper::getActiveDocument()\n{\n   if(cadActiveDocument){\n     return cadActiveDocument->GetDefaultInterface();\n   } else {\n       throw \"Can't create ptr to document, as it's not exist\";\n   }\n}\n\nAutoCADHelper::AutoCADHelper():fInvertYAxe(0),fInvertXAxe(0)\n{\n   gMakeBlockGap = 0.2;\n   gMakeBlockTextHeight = 1.2;\n   gMakeBlockTextOffsetX = 0.8;\n   comboSignCount = 0;\n   gMakeBlockTextEnable = true;\n   cadActiveDocument = new TAcadDocument(0);\n   cadApplication = 0;\n   fApplicationRun = false;\n   gCopyTextObject = 0;\n   gCopyText = 0;\n   iAutoSaveInterval = -1;\n   BMP = new Graphics::TBitmap();\n}\n\nAutoCADHelper::~AutoCADHelper()\n{\n   DeleteDocument(cadActiveDocument);\n   delete BMP;\n}\n\nAcadApplication *AutoCADHelper::BindAutoCAD()\n{\n   if(FAILED(cadApplication.BindToActive(ProgIDToClassID(\"AutoCAD.Application\")))) return 0;\n\n   if(cadApplication->Documents->Count>0 && cadApplication->ActiveDocument){\n       SetActive(cadApplication->ActiveDocument);\n   }\n\n   return cadApplication;\n}\n\nAcadApplication * AutoCADHelper::RunAutoCAD(bool fVisible)\n{\n//    if(FAILED(cadApplication.BindRunning())){\n    if(FAILED(cadApplication.BindToActive(ProgIDToClassID(\"AutoCAD.Application\")))){\n        if(FAILED(cadApplication.Bind(ProgIDToClassID(\"AutoCAD.Application\")))){\n           throw \"can't run AutoCAD\";\n        }\n    }\n    cadApplication->Visible = fVisible;\n\n    if(cadApplication->Documents->Count>0 && cadApplication->ActiveDocument){\n       SetActive(cadApplication->ActiveDocument);\n    }\n    return cadApplication;\n\n}\n\nAcadApplication *AutoCADHelper::getApplication()\n{\n   return cadApplication->Application;\n}\n\nTAcadDocument *AutoCADHelper::SetActive(AcadDocumentPtr docToConnect)\n{\n     cadActiveDocument->ConnectTo(docToConnect);\n     return cadActiveDocument;\n}\n\nvoid AutoCADHelper::DeleteDocument(TAcadDocument *doc)\n{\n    doc->Disconnect();\n}\n\nAcadDocumentPtr AutoCADHelper::OpenDocument(AnsiString FileName,\n                                           bool fSetActive, // set opened document as active document\n                                           bool fReopen) // reopen document even if inside autocad documents list\n{\n  if(!cadApplication.IsBound()) return AcadDocumentPtr();\n\n  int size = FileName.WideCharBufSize();\n  wchar_t *str = new  wchar_t[size];\n  FileName.WideChar(str,size);\n\n  AcadDocumentPtr doc;  // used o iterate over documents;\n\n  try{\n    if(fReopen){\n      // open existing document\n      doc = cadApplication->Documents->Open(str,TNoParam(),TNoParam());\n    }else{\n      // trying to find is current document with name opened\n      AcadDocuments *docs = cadApplication->Documents;\n      int count = docs->Count;\n      for(int i=0;i<count;i++){\n         doc = docs->Item(Variant(i));\n         if(!wcscmp(doc->FullName,str)){\n            break;\n         }\n      }\n      // if nothing find just open\n      doc = cadApplication->Documents->Open(str,TNoParam(),TNoParam());\n    }\n\n  }__finally{\n     delete[] str;\n  }\n  // if we should set opened document as active\n  if(fSetActive && doc.IsBound()){\n     SetActive(doc);\n  }\n  return doc;\n}\n\n\nAcadDocumentPtr AutoCADHelper::AddDocument(AnsiString _template)\n{\n   AcadDocumentPtr doc;\n   if(cadApplication){\n        doc = cadApplication->Documents->Add(Variant(_template));\n        SetActive(doc);\n   }\n   return doc;\n}\n\nvoid __fastcall AutoCADHelper::ActiveDocumentBeginClose(TObject *sender)\n{\n   if(gOnActiveDocumentBeginClose) {\n      gOnActiveDocumentBeginClose(sender);\n   }\n   if(sender == cadActiveDocument) {\n      DeleteDocument(cadActiveDocument);\n   }\n}\n\nvoid AutoCADHelper::ClearModelSpace()\n{\n  while(cadActiveDocument->ModelSpace->Count>0){\n     cadActiveDocument->ModelSpace->Item(Variant(0))->Delete();\n  }\n}\n\nAcadBlockPtr AutoCADHelper::getBlocks(int i)\n{\n   AcadBlockPtr block;\n   if(cadActiveDocument){\n     try{\n         block = cadActiveDocument->Blocks->Item(Variant(i));\n     }catch(...){\n         BUILDER_ERROR( \"Ошибка при попытке получить доступ к \" << i << \"-му блоку\" );\n     }\n   }\n   return block;\n}\n\nAcadBlockPtr AutoCADHelper::getBlocksByName(AnsiString BlockName)\n{\n   AcadBlockPtr block;\n   if(cadActiveDocument){\n     try{\n         block = cadActiveDocument->Blocks->Item(Variant(BlockName));\n     }catch(...){\n         BUILDER_ERROR( \"Ошибка при попытке получить доступ к '\" << BlockName.c_str() << \"' блоку\" );\n     }\n   }\n   return block;\n}\n\nint AutoCADHelper::getBlocksCount()\n{\n   return cadActiveDocument->Blocks->Count;\n}\n\n\nAcadHatchPtr AutoCADHelper::FillAreaBase(AcadHatchPtr hatch,  IDispatch **LoopObjects,\n                                   int LoopObjectsCount,\n                                   int HatchColor,\n                                   int hatchScale)\n{\n   WARNING_AND_RETURN_VALUE_ON_0(hatch.IsBound(), hatch);\n   hatch->AppendOuterLoop(cadArray(LoopObjects,LoopObjectsCount));\n   hatch->Evaluate();\n   hatch->PatternScale = hatchScale;\n   hatch->color = HatchColor;\n   return hatch;\n}                                   \n\nAcadHatchPtr AutoCADHelper::FillArea(IDispatch **LoopObjects,\n                                   int LoopObjectsCount,\n                                   int HatchColor,\n                                   WideString sHatchType,\n                                   int hatchScale)\n{\n   AcadHatchPtr hatch;\n   hatch = cadActiveDocument->ModelSpace->AddHatch(0,sHatchType,Variant(true));\n   FillAreaBase(hatch, LoopObjects, LoopObjectsCount, HatchColor, hatchScale);\n   return hatch;\n}\n\nAcadHatchPtr AutoCADHelper::FillAreaPS(IDispatch **LoopObjects,\n                                   int LoopObjectsCount,\n                                   int HatchColor,\n                                   WideString sHatchType,\n                                   int hatchScale)\n{\n   AcadHatchPtr hatch;\n   hatch = cadActiveDocument->PaperSpace->AddHatch(0,sHatchType,Variant(true));\n   FillAreaBase(hatch, LoopObjects, LoopObjectsCount, HatchColor, hatchScale);\n   return hatch;\n}\n\nAcadBlockReferencePtr AutoCADHelper::DrawBlock(WideString BlockName,\n                                        double x, double y,\n                                        double rotation, double scale)\n{\n   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument, AcadBlockReferencePtr());\n   AcadBlockReferencePtr refer;\n   try {\n       refer = cadActiveDocument->ModelSpace->InsertBlock(cadPoint(x,y),\n                  BlockName,scale,scale,scale,rotation);\n   } catch(...) {\n       BUILDER_ERROR( \"ошибка вывода блока: '\" + AnsiString(BlockName) + \"' (\" << fixed << std::setprecision(2) << x << \";\" << y << \")\");\n   }\n   return refer;\n}\n\nbool AutoCADHelper::GetPropertyPoint(  AcadBlockReferencePtr ptrBlock,\n                                       AnsiString PropertyName,\n                                       AutoCADPoint &point)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;  \n\n  Variant a;\n  Variant vProperities;\n  AnsiString PropertyNameX = PropertyName + \" X\";\n  AnsiString PropertyNameY = PropertyName + \" Y\";\n  AcadDynamicBlockReferencePropertyPtr prop;\n  \n  bool setX = false,setY = false;\n\n  PropertyName = PropertyName.UpperCase();\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (AcadDynamicBlockReferencePropertyPtr)(IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyNameX){\n                 setX = true;\n                 a = prop->get_Value();\n                 point.x = a;\n              }\n              else if(str ==  PropertyNameY){\n                 setY = true;\n                 a = prop->get_Value();\n                 point.y = a;\n              }\n              if(setX&&setY) return true;\n           }\n       }\n     }\n  }catch(...){\n        AnsiString blockName = \"undefined\";\n        try {\n            blockName = ptrBlock->Name;\n        } catch (...) {}\n        std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                   << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nbool AutoCADHelper::GetSubPropertyPoint(AcadBlockPtr ptrBlock, AnsiString PropertyName, AutoCADPoint &out)\n{\n    WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n    int count ,i;\n    AcadEntityPtr subBlock;    \n\n    count  = ptrBlock->Count;\n    for(i=0;i<count;i++){\n       subBlock = ptrBlock->Item(Variant(i));\n       if(subBlock->EntityType == 7){\n          if(GetPropertyPoint( (AcadBlockReferencePtr) subBlock, PropertyName, out))\n            return true;\n       }\n    }\n    return false;\n}\n\nbool AutoCADHelper::GetSubPropertyDouble(AcadBlockPtr ptrBlock, AnsiString PropertyName, double &out)\n{\n    WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n    int count ,i;\n    AcadEntityPtr subBlock;    \n\n    count  = ptrBlock->Count;\n    for(i=0;i<count;i++){\n       subBlock = ptrBlock->Item(Variant(i));\n       if(subBlock->EntityType == 7){\n          if(GetPropertyDouble( (AcadBlockReferencePtr) subBlock, PropertyName, out))\n            return true;\n       }\n    }\n    return false;\n}\n\nvoid AutoCADHelper::SetAttribute(AcadBlockReferencePtr ptrBlock,\n                                 AnsiString PropertyName,\n                                 WideString value, int rot)\n{\n   WARNING_AND_RETURN_ON_0(ptrBlock.IsBound());\n\n   int count;\n   AnsiString str;   \n\n   Variant vProperities;\n   Variant a;\n   AcadAttributeReferencePtr attribute;\n\n   PropertyName = PropertyName.UpperCase();\n   try{\n     ptrBlock->GetAttributes(vProperities);\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              attribute = (IDispatch*)vProperities.GetElement(i);\n              str = attribute->TagString;\n              if(str ==  PropertyName){\n                 attribute->set_TextString(value);\n                 if(rot!=-1)attribute->Rotation = (double)rot/180*M_PI;\n                 break;\n              }\n           }\n       }\n     }\n   }catch(...){\n        AnsiString blockName = \"undefined\";\n        try {\n            blockName = ptrBlock->Name;\n        } catch (...) {}\n        std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                   << \" of object \" << blockName << std::endl;\n   }\n}\n\nbool AutoCADHelper::GetPropertyDouble(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName, double &out)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;  \n  AcadDynamicBlockReferencePropertyPtr prop;\n\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyName){\n                 vProperities = prop->get_Value();\n                 out = vProperities;\n                 return true;\n              }\n           }\n       }\n     }\n  }catch(...){\n      AnsiString blockName = \"undefined\";\n      try {\n          blockName = ptrBlock->Name;\n      } catch (...) {}\n      std::cerr << \"Failed to get '\" << PropertyName.c_str() << \"'\"\n           << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nbool AutoCADHelper::GetPropertyVariant(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName, Variant &out)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;\n  AcadDynamicBlockReferencePropertyPtr prop;\n\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyName){\n                 vProperities = prop->get_Value();\n                 out = vProperities;\n                 return true;\n              }\n           }\n       }\n     }\n  }catch(...){\n      AnsiString blockName = \"undefined\";\n      try {\n          blockName = ptrBlock->Name;\n      } catch (...) {}\n      std::cerr << \"Failed to get '\" << PropertyName.c_str() << \"'\"\n           << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nbool AutoCADHelper::SetPropertyPoint(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName,\n                                 AutoCADPoint value)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;\n  Variant a;\n  AnsiString PropertyNameX = PropertyName + \" X\";\n  AnsiString PropertyNameY = PropertyName + \" Y\";\n  AcadDynamicBlockReferencePropertyPtr prop;\n\n  bool setX = false,setY = false;\n\n  PropertyName = PropertyName.UpperCase();\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (AcadDynamicBlockReferencePropertyPtr)(IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyNameX){\n                 setX = true;\n                 prop->set_Value(Variant(double(value.x)));\n              }\n              else if(str ==  PropertyNameY){\n                 setY = true;\n                 prop->set_Value(Variant(double(value.y)));\n              }\n              if(setX&&setY) return true;\n           }\n       }\n     }\n  }catch(...){\n        AnsiString blockName = \"undefined\";\n        try {\n            blockName = ptrBlock->Name;\n        } catch (...) {}\n        std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                   << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nbool AutoCADHelper::SetPropertyDouble(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName,\n                         double value)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;\n  AcadDynamicBlockReferencePropertyPtr prop;\n  bool isSet = false;\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count; i++){\n              prop = (IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyName){\n                 prop->set_Value(Variant(value));\n                 isSet = true;\n                 break;\n              }\n           }\n       }\n     }\n     if (!isSet) {\n         AnsiString blockName = ptrBlock->EffectiveName;\n         BUILDER_INFO(\"Не смог изменить свойство \"\n                    << PropertyName.c_str()\n                    << \" блока \"\n                    << blockName.c_str()\n                    );\n     }\n  }catch(...){\n        AnsiString blockName = \"undefined\";\n        try {\n            blockName = ptrBlock->Name;\n        } catch (...) {}\n        std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                   << \" of object \" << blockName << std::endl;\n  }\n  return isSet;\n}\n\nbool AutoCADHelper::SetPropertyListVariant(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName,\n                                 Variant value)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);\n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;\n  AcadDynamicBlockReferencePropertyPtr prop;\n\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyName){\n                 prop->set_Value(value);\n                 return true;\n              }\n           }\n       }\n     }\n  }catch(...){\n      AnsiString blockName = \"undefined\";\n      try {\n          blockName = ptrBlock->Name;\n      } catch (...) {}\n      std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                 << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nbool AutoCADHelper::SetPropertyList(AcadBlockReferencePtr ptrBlock, AnsiString PropertyName,\n                                 short value)\n{\n  WARNING_AND_RETURN_VALUE_ON_0(ptrBlock.IsBound(), false);  \n\n  int count;\n  AnsiString str;\n\n  Variant vProperities;\n  AcadDynamicBlockReferencePropertyPtr prop;\n\n  try{\n     vProperities = ptrBlock->GetDynamicBlockProperties();\n     if(vProperities.IsArray()){\n       count = vProperities.ArrayHighBound(1)+1;\n       if(count>0){\n           for(int i=0;i<count;i++){\n              prop = (IDispatch*)vProperities.GetElement(i);\n              str = prop->PropertyName;\n              if(str ==  PropertyName){\n                 prop->set_Value(Variant(value));\n                 return true;\n              }\n           }\n       }\n     }\n  }catch(...){\n        AnsiString blockName = \"undefined\";\n        try {\n            blockName = ptrBlock->Name;\n        } catch (...) {}\n        std::cerr << \"Failed to set property '\" << PropertyName.c_str() << \"'\"\n                   << \" of object \" << blockName << std::endl;\n  }\n  return false;\n}\n\nAcadLayoutPtr AutoCADHelper::AddPaperSpace(WideString name)\n{\n  try{\n    return cadActiveDocument->Layouts->Add(name);\n  }catch(...){\n    std::cerr << \"Failed to add PaperSpace '\" << AnsiString(name).c_str() << \"'\" << std::endl;\n  }\n  return AcadLayoutPtr();\n}\n\nbool AutoCADHelper::SetupViewport(AcadLayoutPtr layout, double x, double y,\n                                double width, double height)\n{\n   AcadPViewportPtr viewport;\n   cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   cadActiveDocument->set_ActiveLayout(layout);\n   try{\n     viewport = cadActiveDocument->ActiveViewport;\n     viewport->set_Center(cadPoint(x+width/2, y+ height/2));\n     viewport->Width = width;\n     viewport->Height = height;\n   }catch(...){\n      std::cerr << \"Failed to setup ViewPort\" << std::endl;\n      return false;\n   }\n   return true;\n}\n\nvoid AutoCADHelper::CheckExistingBlocks()\n{\n    existingBlocks.clear();\n	IAcadBlock * tempBlock;\n    IAcadBlocksPtr blocks = cadActiveDocument->Blocks;\n    int count = blocks->Count;\n\n    for(int i=0;i<count;++i) {\n		try {\n			tempBlock = blocks->Item(Variant(i));\n			existingBlocks.push_back(tempBlock->Name);\n		} catch(...) {\n			continue;\n		}\n	}\n}\n\nbool AutoCADHelper::BindToActiveDocument()\n{\n   TAcadDocument *doc;\n   try{\n     doc = SetActive(cadApplication->ActiveDocument);\n   }catch(...){\n     std::cerr << \"Не могу подключиться к активному документу T_T\" << std::endl \n               << \"Скорее всего AutoCAD не запущен, либо нету активных документов\" << std::endl;\n     return false;\n   }\n   return true;\n}\n\nvoid AutoCADHelper::SetBACKGROUNDPLOT_ZERO()\n{\n   SendCommand(\"BACKGROUNDPLOT 0\\n\");\n}\n\nvoid AutoCADHelper::SelectPaperSpace()\n{\n   //cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   SendCommand(\"_TILEMODE 0 \");\n}\n\nvoid AutoCADHelper::SendCommand(WideString command)\n{\n   cadActiveDocument->SendCommand(command);\n}\n\nAcadLayoutPtr AutoCADHelper::SetAsActiveLayout(Variant index)\n{\n   AcadLayoutPtr layout;\n   try{\n     layout = cadActiveDocument->Layouts->Item(index);\n     cadActiveDocument->set_ActiveLayout(layout);\n   }catch(...){\n     std::cerr << \"Failed to set layout with number '\" << index << \"' as active\" << std::endl;\n   }\n   return layout;\n}\n\n\nbool AutoCADHelper::PrintActiveLayoutToFile(WideString FileName)\n{\n  try{\n    cadActiveDocument->Plot->PlotToFile(FileName);\n  }catch(...){\n    std::cerr << \"Failed to print active layout to file: \"\n              << AnsiString(FileName).c_str() << std::endl;\n  }\n  return true;\n}\n\nbool AutoCADHelper::PrintLayoutsToFile(WideString FileName, int* arrayofindexes, int count)\n{\n   WideString *names = new WideString[count];\n   try{\n     for(int i=0;i<count;i++){\n        names[i] = WideString(cadActiveDocument->Layouts->Item(Variant(arrayofindexes[i]))->Name) + \"12\";\n     }\n     Variant array;\n     Variant a1;\n     array = cadArray(names,count);\n     cadActiveDocument->Plot->SetLayoutsToPlot(a1);\n     cadActiveDocument->Plot->PlotToFile(FileName);\n   }catch(...){\n      std::cerr << \"Failed to print layouts to file: \"\n              << AnsiString(FileName).c_str() << std::endl;\n      delete[] names;\n      return false;\n   }\n   delete[] names;\n   return true;\n}\n\nvoid AutoCADHelper::BeginMSpace(AcadPViewportPtr viewport)\n{\n     WARNING_AND_RETURN_ON_NULL( viewport.IsBound() );\n     viewport->Display(True);\n     AcadDocumentPtr doc = viewport->Document;\n     doc->set_MSpace(True);\n}\n\nvoid AutoCADHelper::EndMSpace(AcadPViewportPtr viewport)\n{\n     WARNING_AND_RETURN_ON_NULL( viewport.IsBound() );\n     AcadDocumentPtr doc = viewport->Document;\n     doc->set_MSpace(False);\n     viewport->Display(False);\n}\n\nbool AutoCADHelper::SetupActiveViewportZoomWindow(double x, double y,\n                                double width, double height)\n{\n   AcadPViewportPtr viewport;\n   cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   try{\n     viewport = (IDispatch*)Variant((IDispatch*)cadActiveDocument\n                  ->GetDefaultInterface()).OlePropertyGet(\"ActivePViewport\");\n\n     BeginMSpace(viewport);\n       cadApplication->ZoomWindow(cadPoint(x,y),cadPoint(x+width,y+height));\n     EndMSpace(viewport);\n\n     cadApplication.ZoomExtents();\n   }catch(...){\n      std::cerr << \"Failed to setup zoom window\" << std::endl;\n      return false;\n   }\n   return true;\n}\n\nbool AutoCADHelper::SetupActiveViewportZoomScale(double ZoomFactor)\n{\n   AcadPViewportPtr viewport;\n   cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   try{\n     viewport = (IDispatch*)Variant((IDispatch*)cadActiveDocument\n                  ->GetDefaultInterface()).OlePropertyGet(\"ActivePViewport\");\n\n     BeginMSpace(viewport);\n       cadApplication->ZoomScaled(ZoomFactor,acZoomScaledAbsolute);\n     EndMSpace(viewport);\n\n     cadApplication->ZoomExtents();\n   }catch(...){\n      std::cerr << \"Failed to setup zoom window\" << std::endl;   \n      return false;\n   }\n   return true;\n}\n\nbool AutoCADHelper::SetupActiveViewportZoomCenter(double x, double y, double scale)\n{\n   AcadPViewportPtr viewport;\n   cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   try{\n     viewport = (IDispatch*)Variant((IDispatch*)cadActiveDocument\n                  ->GetDefaultInterface()).OlePropertyGet(\"ActivePViewport\");\n\n     BeginMSpace(viewport);\n       cadApplication->ZoomCenter(cadPoint(x,y),1);\n     EndMSpace(viewport);\n\n     cadApplication->ZoomExtents();\n   }catch(...){\n      std::cerr << \"Failed to setup zoom window\" << std::endl;   \n      return false;\n   }\n   return true;\n}\n\nvoid AutoCADHelper::AddPaperSpace(AnsiString name, double x, double y,\n                                        double width, double height)\n{\n   AcadPViewportPtr viewport;\n   AcadLayoutPtr layout = cadActiveDocument->Layouts->Add(WideString(name));\n\n   cadActiveDocument->set_ActiveSpace(acPaperSpace);\n   cadActiveDocument->set_ActiveLayout(layout);\n\n   SetupActiveViewportZoomWindow(x, y, width, height);\n   \n   cadActiveDocument->PurgeAll();\n}\n\nAcadTextPtr AutoCADHelper::DrawText(AnsiString str, double height, AcAlignment alignment,\n                                  double x, double y, double rotation)\n{\n   AcadTextPtr text;\n   if (height > 0) {\n     text = cadActiveDocument->ModelSpace->AddText(WideString(str),cadPoint(x,y),height);\n     text->Rotate(cadPoint(x,y),rotation);\n     text->Alignment = alignment;\n     text->set_TextAlignmentPoint(cadPoint(x,y));\n   }\n   return text;\n}\n\nAcadTextPtr AutoCADHelper::DrawTextPS(AnsiString str, double height,\n                                  double x, double y, double rotation)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadTextPtr());\n   AcadTextPtr text;\n   text = cadActiveDocument->PaperSpace->AddText(WideString(str),cadPoint(x,y),height);\n   text->Rotate(cadPoint(x,y),rotation);\n   return text;\n}\n\nAcadLinePtr AutoCADHelper::DrawLine(double x1, double y1, double x2, double y2)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadLinePtr());\n   return cadActiveDocument->ModelSpace->AddLine(cadPoint(x1,y1),cadPoint(x2,y2));\n}\n\nAcadLinePtr AutoCADHelper::DrawLinePS(double x1, double y1, double x2, double y2)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadLinePtr());\n   return cadActiveDocument->PaperSpace->AddLine(cadPoint(x1,y1),cadPoint(x2,y2));\n}\n\nAcadPolylinePtr AutoCADHelper::DrawPolyLine(double *array, int count, int coordCount)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadPolylinePtr());\n   return cadActiveDocument->ModelSpace->AddPolyline(cadPointArray(array,count, coordCount));\n}\n\nAcadPolylinePtr AutoCADHelper::DrawPolyLine(vector<double> &array, int coordCount)\n{\n   return DrawPolyLine(array.begin(), array.size()/coordCount, coordCount);\n}\n\nAcadPolylinePtr AutoCADHelper::DrawPolyLinePS(double *array, int count, int coordCount)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadPolylinePtr());\n   return cadActiveDocument->PaperSpace->AddPolyline(cadPointArray(array,count, coordCount));\n}\n\nAcadEllipsePtr AutoCADHelper::DrawEllipse(double centerX, double centerY, double MajorAxis,double MinorAxis)\n{\n//    WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadEllipsePtr());\n\n    double temp;\n    Variant majAx;\n\n    if(MinorAxis<0)MinorAxis = -MinorAxis;\n    if(MajorAxis<0)MajorAxis = -MajorAxis;\n\n    if(MajorAxis<MinorAxis){\n       majAx = cadPoint(0,-MinorAxis);\n       temp = MajorAxis / MinorAxis;\n    }else{\n       majAx = cadPoint(MajorAxis);\n       temp = MinorAxis / MajorAxis;\n    }\n\n    AcadEllipsePtr ellipse = cadActiveDocument->ModelSpace->AddEllipse(cadPoint(centerX,centerY),\n                 majAx,Variant(temp));\n    if(MajorAxis<MinorAxis){\n       //ellipse->Rotate(cadPoint(centerX,centerY),M_PI_2);\n    }\n    return ellipse;\n}\n\nAcadPolylinePtr AutoCADHelper::DrawRect(double centerX, double centerY, double width, double height)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadPolylinePtr());\n\n   double rect[10];\n   double width2,height2;\n   width2 = width*0.5;\n   height2 = height*0.5;\n\n   rect[0] = centerX - width2;\n   rect[1] = centerY - height2;\n\n   rect[2] = centerX + width2;\n   rect[3] = centerY - height2;\n\n   rect[4] = centerX + width2;\n   rect[5] = centerY + height2;\n\n   rect[6] = centerX - width2;\n   rect[7] = centerY + height2;\n\n   rect[8] = centerX - width2;\n   rect[9] = centerY - height2;\n\n   return DrawPolyLine(rect,5,2);\n}\n\nAcadPolylinePtr AutoCADHelper::DrawRectPS(double centerX, double centerY, double width, double height)\n{\n//    WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadPolylinePtr());\n    double rect[10];\n    double width2,height2;\n\n    width2 = width*0.5;\n    height2 = height*0.5;\n\n    rect[0] = centerX - width2;\n    rect[1] = centerY - height2;\n\n    rect[2] = centerX + width2;\n    rect[3] = centerY - height2;\n\n    rect[4] = centerX + width2;\n    rect[5] = centerY + height2;\n\n    rect[6] = centerX - width2;\n    rect[7] = centerY + height2;\n\n    rect[8] = centerX - width2;\n    rect[9] = centerY - height2;\n\n    return DrawPolyLinePS(rect,5,2);\n}\n\nAcadArcPtr AutoCADHelper::DrawArc(double centerX, double centerY,\n                                double radius, double sAngle, double eAngle)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadArcPtr());\n   return cadActiveDocument->ModelSpace->AddArc(cadPoint(centerX,centerY),\n                                                        radius,sAngle,eAngle);\n}\n\nAcadCirclePtr AutoCADHelper::DrawCircle(double centerX, double centerY, double radius)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadCirclePtr());\n   return cadActiveDocument->ModelSpace->AddCircle(cadPoint(centerX,centerY),radius);\n}\n\nAcadCirclePtr AutoCADHelper::DrawCirclePS(double centerX, double centerY, double radius)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadCirclePtr());\n   return cadActiveDocument->PaperSpace->AddCircle(cadPoint(centerX,centerY),radius);\n}\n\nvoid AutoCADHelper::Regen()\n{\n//   WARNING_AND_RETURN_ON_0(cadActiveDocument);\n   cadActiveDocument->Regen(acAllViewports);\n}\n\nAcadLineTypePtr AutoCADHelper::LoadLineType(WideString LineTypeName,\n                                          WideString FileName,\n                                          WideString ShapeFileName)\n{\n//   WARNING_AND_RETURN_VALUE_ON_0(cadActiveDocument.IsBound(), AcadLineTypePtr());\n   try{\n       if(!ShapeFileName.IsEmpty()){\n          cadActiveDocument->LoadShapeFile(ShapeFileName);\n       }\n       cadActiveDocument->Linetypes->Load(LineTypeName, FileName);\n       return cadActiveDocument->Linetypes->Item(Variant(LineTypeName));\n   }catch(...){\n       std::cerr << \"failed to get linetype '\" << AnsiString(LineTypeName).c_str() << \"'\";\n   }\n   return AcadLineTypePtr();\n}\n\nWideString AutoCADHelper::GetSignName(AnsiString signName)\n{\n   int i,length,count;\n   length = signName.Length();\n   count = 0;\n   for(i=1;i<=length;i++){\n      if(signName[i] == '.'){\n         if(count == 2){\n            return signName.SubString(1,i-1);\n         }\n         count++;\n      }\n   }\n   return signName;\n}\n\n\nvoid AutoCADHelper::SetSignLabels(AcadBlockReferencePtr block, WideString str)\n{\n  if(str.IsEmpty()) return;\n  vector<AnsiString> labels;\n  SplitString(AnsiString(str), '\\\\', labels);\n  for (int i = 0; i < labels.size(); ++i) {\n     SetAttribute(block,\"LABEL\"+(i==0?AnsiString(\"\"):IntToStr(i)),labels[i]);\n  }\n}\n\nvoid AutoCADHelper::ResetBlocksCollection()\n{\n   existingBlocks.clear();\n}\n\nvoid AutoCADHelper::waitForIdle()\n{\n    while(!Application->GetAcadState()->IsQuiescent);\n}\n\nvoid AutoCADHelper::DisableAutoSave()\n{\n    iAutoSaveInterval = Application->Preferences->OpenSave->AutoSaveInterval;\n    ActiveDocument->SendCommand(WideString(\"SAVETIME 0\\n\"));\n}\n\nvoid AutoCADHelper::EnableAutoSave()\n{\n    if (iAutoSaveInterval != -1) {\n        ActiveDocument->SendCommand(WideString(\"SAVETIME \" + IntToStr(iAutoSaveInterval) + \"\\n\"));\n        iAutoSaveInterval = -1;\n    }\n}\n\nbool AutoCADHelper::IsLarger(AnsiString name)\n{\n  return false;\n}\n\n\nAcadBlockPtr AutoCADHelper::MakeCombineBlock(vector<WideString> &blocksNames, vector<WideString> &labels)\n{\n	AnsiString newBlockName;\n	AcadBlockPtr newBlock;\n	IAcadBlock* tempBlock;\n	vector<IAcadBlock*> blocks;\n    vector<WideString> labelsNew;\n\n	// ищем существующие блоки и формируем имя комбинированного\n	for(int i=0;i<blocksNames.size();++i) {\n		try {\n			tempBlock = cadActiveDocument->Blocks->Item(Variant(blocksNames[i]));\n		} catch(...) {\n			BUILDER_ERROR(\"Блок '\" << AnsiString(blocksNames[i]).c_str() << \"' не найден\");\n		}\n		if (newBlockName!=\"\") newBlockName+=\"_\";\n		newBlockName += blocksNames[i];\n		\n		AnsiString label = labels[i];\n		label = StringReplace(label, \" \", \"\", TReplaceFlags() << rfReplaceAll);\n		label = StringReplace(label, \"\\t\", \"\", TReplaceFlags() << rfReplaceAll);\n		label = StringReplace(label, \"\\n\", \"\", TReplaceFlags() << rfReplaceAll);\n		label = StringReplace(label, \":\", \"\", TReplaceFlags() << rfReplaceAll);\n        label = StringReplace(label, \"<\", \"\", TReplaceFlags() << rfReplaceAll);\n        label = StringReplace(label, \">\", \"\", TReplaceFlags() << rfReplaceAll);\n		if (!labels[i].IsEmpty()) {\n			newBlockName += \"[\" + label + \"]\";\n		}\n		\n		labelsNew.push_back(labels[i]);\n		blocks.push_back(tempBlock);\n	}\n	\n	// пробуем возвратить ново-созданный блок, вдруг он уже существует\n	if (std::find(existingBlocks.begin(), existingBlocks.end(), newBlockName) != existingBlocks.end()) {\n		return cadActiveDocument->Blocks->Item(Variant(newBlockName));\n	}\n	\n	// ищем размеры блоков\n    double subBlockHeight;\n    double blockGap = gMakeBlockGap;\n	vector<double> blockHeights(blocks.size());\n	for(int i=0;i<blocks.size();++i) {\n		int subBlocksCount = blocks[i]->Count;\n        subBlockHeight = -1;\n		for(int j=0;j<subBlocksCount;j++){\n		   AcadEntityPtr entity = blocks[i]->Item(Variant(j));\n		   if(entity->EntityType == 7){\n			  AcadBlockReferencePtr subBlock = entity;\n			  if(GetPropertyDouble(subBlock, \"Height\", subBlockHeight)){\n				  //if(GetPropertyDouble(subBlock,\"Width\",width)){\n					float scale = subBlock->XScaleFactor;\n					subBlockHeight *= scale;\n					break;\n				  //}\n			  }\n		   }\n		}\n		blockHeights[i] = subBlockHeight + blockGap;\n	}\n	\n	// формируем суммарную высоту блоков\n	double fullHeight = 0;\n	for (int i=0;i<blocks.size();++i)\n		if (blockHeights[i] != -1) fullHeight += blockHeights[i];\n	\n	//	формируем новый блок\n	int yOffset = 0;\n	newBlock = cadActiveDocument->Blocks->Add(cadPoint(0, 0), WideString(newBlockName));\n	for(int i=0;i<blocks.size();++i) {\n		if(blockHeights[i] != -1) {\n            WideString subBlockName = blocks[i]->Name;\n			IAcadBlockReference *subBlock =\n            newBlock->InsertBlock(cadPoint(0, fullHeight/2 - yOffset - blockHeights[i] / 2), \n						subBlockName,1, 1, 1, 0, TNoParam());\n            SetSignLabels(subBlock, SignLabelParser(subBlockName, labelsNew[i]));\n            yOffset += blockHeights[i];\n		}		\n	}\n\n    // добавляем блок в коллекцию блоков,\n    // чтобы в дальнейшем сразу находить нужный блок\n    // если он уже существует\n	existingBlocks.push_back(newBlock->Name);\n	return newBlock;\n}\n\nvoid AutoCADHelper::DrawRepeatTextInterval(WideString str, float sPosX, float ePosX,\n                                 float PosY, float TextHeight, float step)\n{\n   if(sPosX<0) sPosX = 0;\n   if(ePosX<0||ePosX == sPosX) return;\n\n   int iMax = (int)(ePosX/step)+1;\n   int iMin = (int)(sPosX/step)+1;\n\n   if(iMin!=iMax){\n     // draw repeat text\n     // draw head\n     if(sPosX<iMin*step){\n         DrawText(str, TextHeight, acAlignmentMiddle, sPosX + (iMin*step-sPosX)/2, PosY);\n     }\n     // draw body\n     for(int i=iMin;i<iMax-1;i++){\n         DrawText(str, TextHeight, acAlignmentMiddle, i*step + step/2, PosY);\n     }\n     // draw tail\n     if(ePosX>(iMax-1)*step){\n        DrawText(str, TextHeight, acAlignmentMiddle, (iMax-1)*step + (ePosX-(iMax-1)*step)/2, PosY);\n     }\n   }else{\n     // draw text only once\n     DrawText(str, TextHeight, acAlignmentMiddle, sPosX + (ePosX - sPosX)/2, PosY);\n   }\n}\n\n/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */\n\nAutoCADTable::~AutoCADTable()\n{\n    if(emptyMin) delete[] emptyMin;\n    emptyMin = 0;\n}\n\n\nAutoCADTable::AutoCADTable(AutoCADHelper *Owner, float _TableWidth, int _RowsCount,\n                                float _RowHeight, AutoCADPoint _LeftTop, float _HeaderWidth)\n{\n  gOwner = Owner;\n  emptyMin = 0;\n  gFillGapsBegin = 0;\n  MinViewFontSize = 0;    \n  gaps = 0;  \n  gFillGaps = 0;\n  LeftTop = _LeftTop;\n  RowslEnd = 0;\n  RowsCount = _RowsCount;\n  FillGaps[-1] = true;\n  RowHeight = _RowHeight;\n  HeaderWidth = _HeaderWidth;\n  TableWidth = _TableWidth;\n  gRepeatInterval = 0;\n  gIsHI = false;\n\n  kPadding = 0.9;\n}\n\nvoid OrderGaps(AutoCADPoint p1,AutoCADPoint p2)\n{\n   if(p1.x>p2.x){}\n}\n\nvoid AutoCADTable::FillLastGaps(float step, int iRow)\n{\n   AutoCADPointGapGreater great;\n  // stable_sort(gaps[iRow].begin(),gaps[iRow].end(),great);\n   if(iRow==-1){\n     for(int i=0;i<RowsCount;i++){\n        if(gFillGaps[i]) DrawRepeatEmptyInterval(i,RowslEnd[i],TableWidth,step,true);\n     }\n   }else{\n     DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],TableWidth,step,true);\n   }\n}\n\nvoid AutoCADTable::DrawSnakeBorder(int iRow, float *xOffsets, int count)\n{\n   int iTemp,i,odd;\n   double yTop,yBottom,yPos,*points;\n\n   yTop = gLeftTop.y - RowOffsetY(iRow);\n   yBottom = gLeftTop.y - RowOffsetY(iRow+1);\n\n   points = new double[count*4];\n\n   for(i=0;i<count;i++){\n      odd = i%2;\n      iTemp = i*4;\n      points[iTemp] = points[iTemp + 2] = xOffsets[i]<0?0:xOffsets[i];\n      points[iTemp+1] = odd?yTop:yBottom;\n      points[iTemp+3] = odd?yBottom:yTop;\n   }\n\n   gOwner->DrawPolyLine(points,count*2,2);\n\n   delete[] points;\n}\n\nvoid AutoCADTable::DrawSnakeBorder(int iRow, float sPos, float ePos)\n{\n   float pos[2] = {sPos, ePos};\n   DrawSnakeBorder(iRow,pos,2);\n}\n\nvoid AutoCADTable::DrawTable()\n{\n   int count;\n   double *points = 0;\n\n    /*ROWS */\n   if(gRowsCount%2==0){\n     count = (7+(gRowsCount/2-1)*4);\n     points = new double[count*2+2 + (gHeaderWidth>0?4:0)];\n\n     double xPosLeft = -(gIsHI?0:gHeaderWidth);\n     double xPos = xPosLeft;\n     double yPos = gLeftTop.y;\n\n     points[0] = gLeftTop.x + gTableWidth;\n     points[1] = gLeftTop.y - iRowsFullHeight;\n\n     points[2] = gLeftTop.x + gTableWidth;\n     points[3] = gLeftTop.y;\n\n     for(int i=2;i<count;i++){\n        points[i*2] = xPos + gLeftTop.x;\n        if(i%2==1){\n           yPos-=gRowHeight;\n           if(xPos==gTableWidth){\n             xPos = xPosLeft;\n           }else{\n             xPos = gTableWidth;\n           }\n        }\n        points[i*2+1] = yPos;\n     }\n\n     points[count*2] =  points[4];\n     points[count*2+1] = points[5];\n\n     if(gHeaderWidth){\n        points[count*2+2] = gLeftTop.x+(gIsHI?gHeaderWidth:0);\n        points[count*2+3] = gLeftTop.y;\n\n        points[count*2+4] = gLeftTop.x+(gIsHI?gHeaderWidth:0);\n        points[count*2+5] = gLeftTop.y - iRowsFullHeight;\n     }\n     \n     gOwner->DrawPolyLine(points, count+1+(gHeaderWidth>0?2:0), 2);\n   \n     delete[] points;\n   }else{\n     count = (7+(gRowsCount/2)*4);\n     points = new double[count*2+2 + (gHeaderWidth>0?4:0)];\n\n     double xPosLeft = -(gIsHI?0:gHeaderWidth);\n     double xPos = xPosLeft;\n     double yPos = gLeftTop.y - iRowsFullHeight;\n\n     points[0] = gLeftTop.x + xPosLeft;\n     points[1] = yPos;\n\n     points[2] = gLeftTop.x + xPosLeft;\n     points[3] = gLeftTop.y;\n\n     points[4] = gLeftTop.x + gTableWidth;\n     points[5] = gLeftTop.y;\n\n     points[6] = gLeftTop.x + gTableWidth;\n     points[7] = yPos;\n\n     for(int i=4;i<count;i++){\n        points[i*2] = xPos + gLeftTop.x;\n        if(i%2==1){\n           yPos+=gRowHeight;\n           if(xPos==gTableWidth){\n             xPos = xPosLeft;\n           }else{\n             xPos = gTableWidth;\n           }\n        }\n        points[i*2+1] = yPos;\n     }\n\n     points[count*2] =  points[4];\n     points[count*2+1] = points[5];\n\n     if(gHeaderWidth){\n        points[count*2+2] = gLeftTop.x+(gIsHI?gHeaderWidth:0);\n        points[count*2+3] = gLeftTop.y;\n\n        points[count*2+4] = gLeftTop.x+(gIsHI?gHeaderWidth:0);\n        points[count*2+5] = gLeftTop.y - iRowsFullHeight;\n     }\n     \n     gOwner->DrawPolyLine(points, count+1+(gHeaderWidth>0?2:0), 2);\n   \n     delete[] points;\n   }\n\n}\n\nAcadLinePtr AutoCADTable::DrawBorder(int offset, int iRow)\n{\n   if(offset>TableWidth) return AcadLinePtr();\n   int iS = iRow==-1?gLeftTop.y:gLeftTop.y-iRow*gRowHeight;\n   int iE = iRow==-1?gLeftTop.y-iRowsFullHeight:gLeftTop.y-(iRow+1)*gRowHeight;\n   \n   return gOwner->DrawLine(gLeftTop.x + offset, iS, gLeftTop.x +offset,iE);\n}\n\nAcadHatchPtr AutoCADTable::FillArea(int iRow, float offsetBegin, float offsetEnd, AnsiString strHatch,\n                                float scale, int color)\n{\n    double dblPL[10];\n\n    dblPL[0] = offsetBegin;\n    dblPL[1] = gLeftTop.y - RowOffsetY(iRow);\n\n    dblPL[2] = offsetEnd;\n    dblPL[3] = gLeftTop.y - RowOffsetY(iRow);\n\n    dblPL[4] = offsetEnd;\n    dblPL[5] = gLeftTop.y - RowOffsetY(iRow+1);\n\n    dblPL[6] = offsetBegin;\n    dblPL[7] = gLeftTop.y - RowOffsetY(iRow+1);\n\n    dblPL[8] = offsetBegin;\n    dblPL[9] = gLeftTop.y - RowOffsetY(iRow);\n\n    AcadPolylinePtr pl[1];\n    pl[0] = gOwner->DrawPolyLine(dblPL, 5, 2);\n\n    AcadHatchPtr hatch = gOwner->FillArea((IDispatch**)pl, 1, 0, strHatch);\n    \n    AcadAcCmColor *_color =  hatch->TrueColor;\n    _color->set_ColorIndex(color);\n    hatch->set_TrueColor(_color);\n\n    hatch->PatternScale = scale;\n\n    return hatch;\n}\n\nAcadHatchPtr AutoCADTable::FillArea(int iRow, float offsetBegin, float offsetEnd, AnsiString strHatch,\n                                float scale, long colorR, long colorG, long colorB)\n{\n    AcadHatchPtr hatch = FillArea(iRow, offsetBegin, offsetEnd, strHatch, scale, 0);\n    \n    AcadAcCmColor *color =  hatch->TrueColor;\n    color->SetRGB(colorR, colorG, colorB);\n    hatch->set_TrueColor(color);\n\n    return hatch;    \n}\n\nvoid AutoCADTable::DrawEmpty(int iRow, float offsetBegin, float offsetEnd,\n                             bool fWithBorders, bool fWithoutFill, bool fInc )\n{\n   if(offsetBegin<0) offsetBegin = 0;\n   if(offsetEnd<0) offsetEnd = 0;\n   if(EmptyFill.IsEmpty() || fWithoutFill) {  // draw cross line if EmptyFIll is not set, or forced fWithoutFill\n      DrawLine(iRow,offsetBegin,fInc?0:1,offsetEnd,fInc?1:0);\n   } else {\n      FillArea(iRow, offsetBegin, offsetEnd, EmptyFill, EmptyFillScale);\n   }\n   if(fWithBorders){\n      DrawSnakeBorder(iRow, offsetBegin, offsetEnd);\n   }\n}\n\n\nAcadTextPtr AutoCADTable::DrawText(int row, float offset,\n                                 AnsiString str, float kProp)\n{\n   kProp = kProp>1?1:kProp;\n   float xOffset = gLeftTop.x + offset;\n   float yOffset = gLeftTop.y-(RowOffsetY(row) + gRowHeight*0.5);\n   AcadTextPtr text = gOwner->DrawText(WideString(str),\n                                       kProp*gRowHeight,\n                                       acAlignmentMiddleLeft,\n                                       xOffset,\n                                       yOffset);\n   return text;\n}\n\n\nvoid AutoCADTable::DrawHeaderText(int row,AnsiString str, float kProp)\n{\n   DrawTextInBorders(row,gIsHI?0:-gHeaderWidth,\n                         gIsHI?gHeaderWidth:0,WideString(str),false, kProp);\n}\n\n\nvoid AutoCADTable::DrawRepeatEmptyInterval(int iRow,\n                                float sPos, float ePos, float step,\n                                bool fWithBorders, bool fWithoutFill, bool fInc)\n{\n   if(emptyMin) {\n      if ( emptyMin[iRow] > ePos ) {\n         return;\n      }\n      if ( emptyMin[iRow] > sPos ) {\n         sPos = emptyMin[iRow];\n         if (sPos > ePos) {\n            return;\n         }\n      }\n   }\n\n   if(step==0){\n     if(gRepeatInterval!=0)\n       step=gRepeatInterval;\n     else\n       return;\n   }\n\n   if(sPos<0) sPos = 0;\n   if(ePos<0||ePos == sPos){\n      if(fWithBorders){\n         DrawBorder(sPos,iRow);\n      }\n      return;\n   }\n\n   int iMin = (int)(sPos/step) + 1;\n   int iMax = (int)(ePos/step) + 1;\n\n   int count = abs(iMax - iMin)+2;\n   int counter = 1;\n   float *pos = new float[count];\n   pos[0] = sPos;   \n\n   if(iMin!=iMax){\n     if(sPos<iMin*step){\n         DrawEmpty(iRow,sPos,iMin*step,false,fWithoutFill, fInc);\n         pos[counter++] = iMin*step;\n     }\n     for(int i=iMin;i<iMax-1;i++){\n         DrawEmpty(iRow,i*step,(i+1)*step,false,fWithoutFill, fInc);\n         pos[counter++] = (i+1)*step;\n     }\n     if(ePos>(iMax-1)*step){\n        DrawEmpty(iRow,(iMax-1)*step,ePos,false,fWithoutFill, fInc);\n        pos[counter++] = ePos;\n     }\n     if(fWithBorders)DrawSnakeBorder(iRow,pos,counter);\n   }else{\n     DrawEmpty(iRow, sPos, ePos, false, fWithoutFill, fInc);\n     if(fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n   }\n   delete[] pos;\n}\n\n\nvoid AutoCADTable::DrawRepeatTextInterval(int iRow, AnsiString str,\n                                float sPos, float ePos,\n                                AnsiString (*func)(float, float),\n                                float step, bool fWithBorders, float kProp)\n{\n   if(iRow<0) return;\n\n   if(step==0){\n     if(gRepeatInterval!=0)\n       step=gRepeatInterval;\n     else\n       return;\n   }\n\n   AnsiString tStr;\n\n   if(sPos<0) sPos = 0;\n   if(ePos<0||ePos == sPos) return;\n\n   int iMax = (int)(ePos/step)+1;\n   int iMin = (int)(sPos/step)+1;\n\n   int count = abs(iMax - iMin)+2;\n   int counter = 1;\n   float *pos = new float[count];\n   pos[0] = sPos;\n\n\n   if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n     DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n   }\n\n   emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n\n   float min,max;\n\n   if(iMin!=iMax){\n     if(sPos<iMin*step){\n         if(func){\n             min = sPos;\n             max = iMin*step;\n             if(!str.IsEmpty()){\n                tStr = str+\"\\n\"+func(min,max);\n             }else{\n                tStr=func(min,max);\n             }\n             DrawTextInBorders(iRow,min,max,tStr,false,kProp);\n         }else{\n             if(!str.IsEmpty())DrawTextInBorders(iRow,sPos,iMin*step,str,false,kProp);\n         }\n         pos[counter++] = iMin*step;\n     }\n     for(int i=iMin;i<iMax-1;i++){\n         if(func){\n           min = i*step;\n           max = (i+1)*step;\n           if(!str.IsEmpty()){\n              tStr = str+\"\\n\"+func(min,max);\n           }else{\n              tStr=func(min,max);\n           }\n           DrawTextInBorders(iRow,min,max,tStr,false,kProp);\n         }else{\n           if(!str.IsEmpty())DrawTextInBorders(iRow,i*step,(i+1)*step,str,false,kProp);\n         }\n         pos[counter++] = (i+1)*step;\n     }\n     if(ePos>(iMax-1)*step){\n        if(func){\n           min = (iMax-1)*step;\n           max = ePos;\n           if(!str.IsEmpty()){\n              tStr = str+\"\\n\"+func(min,max);\n           }else{\n              tStr=func(min,max);\n           }\n           DrawTextInBorders(iRow,min,max,tStr,false,kProp);\n        }else{\n           if(!str.IsEmpty())DrawTextInBorders(iRow,(iMax-1)*step,ePos,str,false,kProp);\n        }\n        pos[counter++] = ePos;\n     }\n     if(fWithBorders) DrawSnakeBorder(iRow,pos,counter);\n\n   }else{\n     if(func){\n        min = sPos;\n        max = ePos;\n        if(!str.IsEmpty()){\n           tStr = str+\"\\n\"+func(min,max);\n        }else{\n           tStr=func(min,max);\n        }\n        DrawTextInBorders(iRow,min,max,tStr,false,kProp);\n     }else{\n        if(!str.IsEmpty())DrawTextInBorders(iRow,sPos,ePos,str,false,kProp);\n     }\n     if(gFillGaps[iRow]&&fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n   }\n\n   RowslEnd[iRow] = ePos;\n   delete[] pos;\n}\n\n\n\n\nvoid AutoCADTable::DrawRepeatTextIntervalSpec2(int iRow, AnsiString str,\n                                float sPos, float ePos,bool fTop,\n                                float step, bool fWithBorders, float kProp)\n{\n\n   if(iRow<0) return;\n\n   if(step==0){\n     if(gRepeatInterval!=0)\n       step=gRepeatInterval;\n     else\n       return;\n   }\n\n   AnsiString tStr;\n\n   if(sPos<0) sPos = 0;\n   if(ePos<0||ePos == sPos) return;\n\n   int iMax = (int)(ePos/step)+1;\n   int iMin = (int)(sPos/step)+1;\n\n   int count = abs(iMax - iMin)+2;\n   int counter = 1;\n   float *pos = new float[count];\n   pos[0] = sPos;\n\n\n   if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n     DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n   }\n\n   emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n   float min,max;\n   if(iMin!=iMax){\n     if(sPos<iMin*step){\n         if(!str.IsEmpty())DrawTextInBordersSpec2(iRow,sPos,iMin*step,str,fTop,false,kProp);\n         pos[counter++] = iMin*step;\n     }\n     for(int i=iMin;i<iMax-1;i++){\n         if(!str.IsEmpty())DrawTextInBordersSpec2(iRow,i*step,(i+1)*step,str,fTop,false,kProp);\n         pos[counter++] = (i+1)*step;\n     }\n     if(ePos>(iMax-1)*step){\n        if(!str.IsEmpty())DrawTextInBordersSpec2(iRow,(iMax-1)*step,ePos,str,fTop,false,kProp);\n        pos[counter++] = ePos;\n     }\n     if(fWithBorders) DrawSnakeBorder(iRow,pos,counter);\n\n   }else{\n     if(!str.IsEmpty())DrawTextInBordersSpec2(iRow,sPos,ePos,str,fTop,false,kProp);\n     if(gFillGaps[iRow]&&fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n   }\n\n   RowslEnd[iRow] = ePos;\n   delete[] pos;\n}\n\n\nvoid AutoCADTable::DrawRepeatTextIntervalMoundHeight(int iRow,float sPos, float ePos,\n                                float sHeight, float eHeight,\n                                float step,float kProp)\n{\n   if(iRow<0) return;\n\n   if(step==0){\n     if(gRepeatInterval!=0)\n       step=gRepeatInterval;\n     else\n       return;\n   }\n\n   AnsiString str;\n\n   if(sPos<0) sPos = 0;\n   if(ePos<0||ePos == sPos) return;\n   emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n   int curHeight;\n   float k,temp,temp2,xoffset;\n   float width  = ePos-sPos;\n\n   int iMax = (int)(ePos/step)+1;\n   int iMin = (int)(sPos/step)+1;\n\n   int count = abs(iMax - iMin)+2;\n   int counter = 1;\n   xoffset = kProp*gRowHeight*0.1;\n   float *pos = new float[count];\n   pos[0] = sPos;\n   float min,max;\n   float subKProp = 0.75;\n\n\n   if(iMin!=iMax){\n     if(sPos<iMin*step&&int(sPos)%(int)step == 0){\n         if((int)sHeight%100==0){\n            str.sprintf(\"%i м\",(int)sHeight/100);\n         }else{\n            if((int)sHeight%10==0){\n              str.sprintf(\"%.1f м\",(float)sHeight/100.0f);\n            }else{\n              str.sprintf(\"%.2f м\",(float)sHeight/100.0f);\n            }\n         }\n         temp2 = DrawTextInBordersMoundHeight(iRow,str,sPos+xoffset,0.875,acAlignmentMiddleLeft,step/2,kProp);\n         DrawTextInBordersMoundHeight(iRow,(int)sPos%int(step)/100,sPos+xoffset,0.625,acAlignmentMiddleLeft,0,(!temp2?kProp*subKProp:temp2*subKProp));\n         pos[counter++] = iMin*step;\n     }\n\n     temp = iMin*step;\n     k = ((temp-sPos)/width);\n     curHeight = sHeight +  (eHeight-sHeight)*k;\n\n     if((int)curHeight%100==0){\n        str.sprintf(\"%i м\",curHeight/100);\n     }else{\n        if((int)curHeight%10==0){\n          str.sprintf(\"%.1f м\",(float)curHeight/100.0f);\n        }else{\n          str.sprintf(\"%.2f м\",(float)curHeight/100.0f);\n        }\n     }\n\n\n     temp2 = DrawTextInBordersMoundHeight(iRow,str,temp-xoffset,0.875,acAlignmentMiddleRight,temp - sPos,kProp);\n     DrawTextInBordersMoundHeight(iRow,1000,temp-xoffset,0.625,acAlignmentMiddleRight,0,(!temp2?kProp*subKProp:temp2*subKProp));\n\n     for(int i=iMin;i<iMax-1;i++){\n         temp = i*step;\n         k = ((temp-sPos)/width);\n         curHeight = sHeight +  (eHeight-sHeight)*k;\n         if((int)curHeight%100==0){\n            str.sprintf(\"%i м\",curHeight/100);\n         }else{\n            if((int)curHeight%10==0){\n              str.sprintf(\"%.1f м\",(float)curHeight/100.0f);\n            }else{\n              str.sprintf(\"%.2f м\",(float)curHeight/100.0f);\n            }\n         }\n         temp2 = DrawTextInBordersMoundHeight(iRow,str,temp+xoffset,0.875,acAlignmentMiddleLeft,step/2,kProp);\n         DrawTextInBordersMoundHeight(iRow,0,temp+xoffset,0.625,acAlignmentMiddleLeft,0,(!temp2?kProp*subKProp:temp2*subKProp));\n\n         temp += step;\n         k = (temp-sPos)/width;\n         curHeight = sHeight +  (eHeight-sHeight)*k;\n         if((int)curHeight%100==0){\n            str.sprintf(\"%i м\",curHeight/100);\n         }else{\n            if((int)curHeight%10==0){\n              str.sprintf(\"%.1f м\",(float)curHeight/100.0f);\n            }else{\n              str.sprintf(\"%.2f м\",(float)curHeight/100.0f);\n            }\n         }\n         temp2 = DrawTextInBordersMoundHeight(iRow,str,temp-xoffset,0.875,acAlignmentMiddleRight,step/2,kProp);\n         DrawTextInBordersMoundHeight(iRow,1000,temp-xoffset,0.625,acAlignmentMiddleRight,0,(!temp2?kProp*subKProp:temp2*subKProp));\n\n         pos[counter++] = (i+1)*step;\n     }\n     if(ePos>(iMax-1)*step){\n        temp = ePos - (iMax-1)*step;\n        k = (float)((iMax-1)*step-sPos)/width;\n        curHeight = sHeight +  (eHeight-sHeight)*k;\n        if((int)curHeight%100==0){\n           str.sprintf(\"%i м\",curHeight/100);\n        }else{\n           if((int)curHeight%10==0){\n             str.sprintf(\"%.1f м\",(float)curHeight/100.0f);\n           }else{\n             str.sprintf(\"%.2f м\",(float)curHeight/100.0f);\n           }\n        }\n        temp2 = DrawTextInBordersMoundHeight(iRow,str,(iMax-1)*step+xoffset,0.875,acAlignmentMiddleLeft,temp/2,kProp);\n        DrawTextInBordersMoundHeight(iRow,0,(iMax-1)*step+xoffset,0.625,acAlignmentMiddleLeft,0,(!temp2?kProp*subKProp:temp2*subKProp));\n\n        if((int)eHeight%100==0){\n           str.sprintf(\"%i м\",(int)eHeight/100);\n        }else{\n           if((int)eHeight%10==0){\n             str.sprintf(\"%.1f м\",(float)eHeight/100.0f);\n           }else{\n             str.sprintf(\"%.2f м\",(float)eHeight/100.0f);\n           }\n        }\n\n        temp2 = DrawTextInBordersMoundHeight(iRow,str,ePos-xoffset,0.875,acAlignmentMiddleRight,temp/2,kProp);\n        DrawTextInBordersMoundHeight(iRow,(int)ePos%int(step)/100,ePos-xoffset,0.625,acAlignmentMiddleRight,0,(!temp2?kProp*subKProp:temp2*subKProp));\n\n        pos[counter++] = ePos;\n     }\n     DrawSnakeBorder(iRow,pos,counter);\n\n   }else{\n     if(sPos==iMin*step){\n\n        if((int)sHeight%100==0){\n           str.sprintf(\"%i м\",(int)sHeight/100);\n        }else{\n           if((int)sHeight%10==0){\n             str.sprintf(\"%.1f м\",(float)sHeight/100.0f);\n           }else{\n             str.sprintf(\"%.2f м\",(float)sHeight/100.0f);\n           }\n        }\n        temp2 = DrawTextInBordersMoundHeight(iRow,str,sPos+xoffset,0.875,acAlignmentMiddleLeft,width,kProp);\n        DrawTextInBordersMoundHeight(iRow,(int)sPos%int(step)/100,sPos+xoffset,0.625,acAlignmentMiddleLeft,0,(!temp2?kProp*subKProp:temp2*subKProp));\n     }\n\n     if((int)eHeight%100==0){\n        str.sprintf(\"%i м\",(int)eHeight/100);\n     }else{\n        if((int)eHeight%10==0){\n          str.sprintf(\"%.1f м\",(float)eHeight/100.0f);\n        }else{\n          str.sprintf(\"%.2f м\",(float)eHeight/100.0f);\n        }\n     }\n\n     temp2 = DrawTextInBordersMoundHeight(iRow,str,ePos-xoffset,0.875,acAlignmentMiddleRight,width,kProp);\n     DrawTextInBordersMoundHeight(iRow,(int)ePos%int(step)/100,ePos-xoffset,0.625,acAlignmentMiddleRight,0,(!temp2?kProp*subKProp:temp2*subKProp));\n     DrawSnakeBorder(iRow,sPos,ePos);\n   }\n\n   RowslEnd[iRow] = ePos;\n   delete[] pos;\n}\n\nvoid AutoCADTable::DrawRepeatVerticalTextInterval(int iRow,\n                                float sPos, float ePos,float kyPos,\n                                float step, bool fWithBorders, float kProp)\n{\n  int iMin = (int)(sPos/step) + 1;\n  int iMax = (int)(ePos/step) + 1;\n\n  for (int i = iMin; i < iMax; ++i) {\n    int pos = i * step;\n    int leftValue = pos % 100000 / 100;\n    int rightValue = leftValue == 0 ? 1000 : leftValue;\n    DrawVerticalText(leftValue, iRow, pos, 1 - kyPos, true, kProp);\n    DrawVerticalText(rightValue, iRow, pos, kyPos, false, kProp);\n  }\n\n  if (ePos != step * (iMax - 1)) {\n    int value = int(ePos) % 100000 / 100;\n    DrawVerticalText(value, iRow, ePos, kyPos, false, kProp);\n  }\n}\n\n\nAcadBlockReferencePtr AutoCADTable::DrawBlock(WideString BlockName, int iRow, float Pos, float yOffset)\n{\n   return gOwner->DrawBlock(BlockName,gLeftTop.x+Pos,gLeftTop.y-RowOffsetY(iRow) - gRowHeight*yOffset);\n}\n\nAcadLinePtr AutoCADTable::DrawLine(int iRow, float sPos, float ePos)\n{\n   if(iRow==-1 || !gOwner) return AcadLinePtr();\n   float y = gLeftTop.y - RowOffsetY(iRow) - gRowHeight/2;\n   return gOwner->DrawLine(gLeftTop.x+sPos,y,gLeftTop.x+ePos,y);\n}\n\nAcadLinePtr AutoCADTable::DrawLine(int iRow, float sPos,\n                                 float yk1, float ePos, float yk2)\n{\n   if(iRow==-1 || !gOwner) return AcadLinePtr();\n   yk1 = gLeftTop.y - RowOffsetY(iRow) - gRowHeight*(1-yk1);\n   yk2 = gLeftTop.y - RowOffsetY(iRow) - gRowHeight*(1-yk2);\n   return gOwner->DrawLine(gLeftTop.x+sPos,yk1,gLeftTop.x+ePos,yk2);\n}\n\nAcadEllipsePtr AutoCADTable::DrawRightArcEllipse(int iRow, float sPos, float ePos)\n{\n    return gOwner->DrawEllipse(sPos,gLeftTop.y - RowOffsetY(iRow+1),abs((int)(ePos-sPos)),gRowHeight/2);\n}\n\nAcadEllipsePtr AutoCADTable::DrawLeftArcEllipse(int iRow, float sPos, float ePos)\n{\n    return gOwner->DrawEllipse(sPos,gLeftTop.y - RowOffsetY(iRow),abs((int)(ePos-sPos)),gRowHeight/2);\n}\n\nAcadTextPtr AutoCADTable::DrawVerticalText(AnsiString txt, int iRow, float Pos,\n                                         float kyPos,bool fRight, float kProp)\n{\n   float xOffset = gLeftTop.x + Pos;\n   float _Height;\n   float yOffset = gLeftTop.y- RowOffsetY(iRow)-gRowHeight*(1-kyPos);\n\n   // if kProp less then 10 then we use height according to row height\n   if(kProp>10)\n     _Height = kProp;\n   else\n     _Height = gRowHeight*kProp;\n\n   AcadTextPtr text;\n   if(fRight){\n     text = gOwner->DrawText(txt,_Height,acAlignmentTopCenter, xOffset + 0.35*_Height,yOffset,M_PI_2);\n   } else {\n     text = gOwner->DrawText(txt,_Height,acAlignmentBottomCenter, xOffset,yOffset,M_PI_2);\n   }\n   return text;\n}\n\n// returns the rest of words started from index\nAnsiString GetRestOfStringAfter(int index, vector<AnsiString> words, AnsiString delimiter = \" \")\n{\n   AnsiString str;\n   for(int i=index;i<words.size(); ++i ) {\n      if (i!=index) str += delimiter;\n      str += words[i];\n   }\n   return str;\n}\n\n// returns the rest of words started from index\nAnsiString GetRestOfStringBefore(int index, vector<AnsiString> words, AnsiString delimiter = \" \")\n{\n   AnsiString str;\n   for(int i=index;i>=0; --i ) {\n      str += words[i];\n      if (i!=index) str += delimiter;\n   }\n   return str;\n}\n\nvoid AutoCADTable::SplitTextForRoadMark(AnsiString str, int RectHeight, int RectWidth, vector<LineInfo> &lines)\n{\n#define GETK(str) (float)RectWidth / (str.Length()* LetterWidth)\n\n    WARNING_AND_RETURN_ON_0(str.Length());\n\n    int width, minLinesCount;\n    int LetterWidth = gLetterWidth / 4;\n    int LetterHeight;\n    int linesCount;\n    float kOffset, k, kTitle, k0 = 0, k1 = 0, k2 = 0;\n    vector<AnsiString> strs;\n\n    // for each subline check is it possible to increase size of letters\n    linesCount = 1; // at least we have one line\n\n    kTitle = k = GETK(str); //(float)RectWidth / (); // get relation between RectWidth and text width\n    LetterHeight = kTitle * RectHeight;  // recalculate LetterHeight\n\n    // let's split string on words\n    vector<AnsiString> words;\n    gOwner->SplitString(str, ' ', words); // split line with spaces\n    // check is text box wide enough\n    if (k <= 0.5 && words.size() > 1) {\n       AnsiString rest;\n       // try to split string on two lines\n       linesCount = 2;\n       rest = GetRestOfStringAfter(1, words);\n       kTitle = GETK( words[0] );\n       k0 = std::min<float>( kTitle, GETK( rest ) ) / linesCount;\n       k0 = std::min<float> ( k0, 1.0 / linesCount);\n       // is it use?\n       if ( kTitle > k && words.size() > 2 ) {\n         // try to split string on three lines\n         linesCount = 3;\n         rest = GetRestOfStringAfter(2, words);\n         k1 = std::min<float>( std::min<float>( GETK(words[0]), GETK(words[1]) ), GETK(rest) ) / linesCount;\n         k1 = std::min<float> ( k1, 1.0 / linesCount);\n         // is it use?\n         if ( k1 > 1.35*k0) { // that cause overall text size is more important then size of just one header\n           strs.push_back(words[0]);\n           strs.push_back(words[1]);\n           strs.push_back(GetRestOfStringAfter(2, words));\n           k = k1;\n           kTitle = std::min<float> ( (GETK( words[0] )) / 3, 1.0 / 3);\n         } else {\n           strs.push_back(words[0]);\n           strs.push_back(GetRestOfStringAfter(1, words));\n           k = k0;\n           kTitle = std::min<float> ( (GETK( words[0] )) / 2, 1.0 / 2);\n         }\n       } else { // if spliting only spoils result revert to one line\n         strs.push_back(str);\n         kTitle = k;\n       }\n    } else { // perfect solution, no dividig is needed\n       strs.push_back(str); // otherwise just push string to lines array\n       kTitle = k;\n    }\n\n    // loop over string lines\n    kOffset =  1.0 / ( strs.size() + 1);\n    for (int i=0;i<strs.size() ;++i) {\n       LineInfo li;\n\n       if (i == 0) { // fot title or first substring we have special case\n          if ( strs.size() > 1 ) { // move title a bit higher\n            li.kOffset = kOffset - kTitle*0.1;\n          }  else {\n            li.kOffset = kOffset;\n          }\n          li.Height = min( RectHeight, kTitle * RectHeight);\n       } else { // if not title\n          li.Height = min( RectHeight, k * RectHeight);\n          li.kOffset = (i+1)*kOffset + kTitle*0.1;\n       }\n\n       li.Text = strs[i];\n       // push lineInfo to array\n       lines.push_back(li);\n    }\n#undef GETK\n}\n\n\nvoid AutoCADTable::DrawTextInBordersRoadMark(int row, float offBeg,\n                            float offEnd,AnsiString str,\n                            bool fWithBorders ,float kProp)\n{\n  if (RowslEnd[row] > offBeg) offBeg = RowslEnd[row];\n  if(offEnd <= offBeg) return;\n\n  float xOffset, yOffset;\n  float width = fabs(offEnd-offBeg);\n\n  vector<LineInfo> strings;\n  SplitTextForRoadMark(str, gRowHeight, offEnd - offBeg, strings);\n\n  xOffset = gLeftTop.x + offBeg + width/2;\n  yOffset = gLeftTop.y - RowOffsetY(row);\n\n  for(int i=0;i<strings.size();i++){\n     gOwner->DrawText(strings[i].Text,\n        kProp*strings[i].Height,\n        acAlignmentMiddle,\n        xOffset,\n        yOffset - strings[i].kOffset * gRowHeight);\n  }\n\n  if(fWithBorders){\n      DrawSnakeBorder(row,offBeg,offEnd);\n  }\n}\n\n void AutoCADTable::DrawRepeatTextIntervalRoadMark(int iRow, AnsiString str,\n                                float sPos, float ePos,\n                                AnsiString (*func)(float, float),\n                                float step, bool fWithBorders, float kProp)\n{\n#define DRAWTEXT(min, max)  \\\n        if(func){ \\\n           AnsiString tStr; \\\n           if(!str.IsEmpty()){ \\\n              tStr = str+func(min,max); \\\n           }else{ \\\n              tStr=func(min,max); \\\n           } \\\n           DrawTextInBordersRoadMark(iRow,min,max,tStr,false,kProp); \\\n        }else{ \\\n           if(!str.IsEmpty())DrawTextInBordersRoadMark(iRow,min,max,str,false,kProp); \\\n        }     \n\n   if(iRow<0) return;\n   if(step==0){\n     if(gRepeatInterval!=0)\n       step=gRepeatInterval;\n     else\n       return;\n   }\n\n   if(sPos<0) sPos = 0;\n   if(ePos<0||ePos == sPos) return;\n   \n   if(sPos>ePos){\n      int temp =  sPos;\n      sPos = ePos;\n      ePos = temp;\n   }\n\n   int iMax = (int)(ePos/step)+1;\n   int iMin = (int)(sPos/step)+1;\n\n   int count = abs(iMax - iMin)+2;\n   int counter = 1;\n   float *pos = new float[count];\n   pos[0] = sPos;\n\n   if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n     DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n   }\n   emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n\n   float min,max;\n   if(iMin!=iMax){\n     if(sPos<iMin*step){\n        min = sPos;\n        max = iMin*step;\n        DRAWTEXT(min, max);\n        pos[counter++] = max; \n     }\n     for(int i=iMin;i<iMax-1;i++){\n        min = i*step;\n        max = (i+1)*step;\n        DRAWTEXT(min, max);\n        pos[counter++] = max; \n     }\n     if(ePos>(iMax-1)*step){\n        min = (iMax-1)*step;\n        max = ePos;\n        DRAWTEXT(min, max);\n        pos[counter++] = max; \n     }\n     if(fWithBorders) DrawSnakeBorder(iRow,pos,counter);\n   }else{\n     DRAWTEXT(sPos, ePos);\n     if(/*gFillGaps[iRow]&&*/fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n   }\n   delete[] pos;\n   RowslEnd[iRow] = ePos;\n   \n#undef DRAWTEXT\n}\n\n\nvoid AutoCADTable::DrawTextInBorders(int row, float offBeg,\n                            float offEnd,AnsiString str,\n                            bool fWithBorders ,float kProp)\n{\n  if(row<0 || offEnd == offBeg) return;\n\n  int count = 1;\n  int strLenght = str.Length();\n\n  vector<AnsiString> strings;\n  gOwner->SplitString(str, '\\n', strings);\n  count = strings.size();\n\n  float Height = gRowHeight/(float)count;\n\n  float xOffset = gLeftTop.x + offBeg + (offEnd - offBeg)/2;\n  float yOffset = gLeftTop.y- RowOffsetY(row)+Height/2;\n\n  if(kProp<=1) { /*если в пропорциях от высоты строки*/\n    for(int i=0;i<count;i++){     \n       yOffset-=Height;\n       gOwner->DrawText(strings[i],kProp*Height,acAlignmentMiddle, xOffset,yOffset);\n    }\n  } else {  /*иначе абсолютное значение*/\n    for(int i=0;i<count;i++){\n       yOffset-=Height;\n       gOwner->DrawText(strings[i],kProp, acAlignmentMiddle, xOffset,yOffset);\n    }\n  }\n\n  if(fWithBorders){\n      DrawSnakeBorder(row,offBeg,offEnd);\n  }\n}\n\nvoid AutoCADTable::DrawTextInBordersSpec2(int row, float offBeg,\n                            float offEnd,AnsiString str, bool fTop,\n                            bool fWithBorders,float kProp)\n{\n   AcadTextPtr text;\n   AcAlignment align;\n   float width  = (float)abs(int(offEnd - offBeg))/2;\n   float xOffset = gLeftTop.x + offBeg + width*1.5;\n   float yOffset;\n   float scale;\n\n   scale = (float)width/(float)(str.Length()*(gLetterWidth*kProp));\n\n   if(scale>=1)\n     scale = kProp;\n   else{\n      scale = (float)abs(int(offEnd-offBeg))/(float)(str.Length()*gLetterWidth);\n      scale *= kPadding;\n      if(scale>kProp)scale = kProp;\n   }\n\n   yOffset = gLeftTop.y- RowOffsetY(row+1)+ 0.5*gRowHeight + gRowHeight*kBottomEmptyPadding*0.5;\n   if(fTop){\n     align = acAlignmentBottomCenter;\n     scale*=(0.5-kBottomEmptyPadding/2);\n   }else{\n     align = acAlignmentTopCenter;\n     scale*=(kBottomEmptyPadding/2+0.5);\n   }\n\n   text = gOwner->DrawText(str,scale*gRowHeight,align, xOffset,yOffset);\n}\n\n\n\n\nfloat AutoCADTable::DrawTextInBordersMoundHeight(int iRow, AnsiString text,\n                         float Pos, float yPos, AcAlignment align, float width, float kProp)\n{\n   AcadTextPtr aText;\n   bool fwas = false;\n   float scale;\n   if(yPos>1) yPos = 1;\n   float xOffset = gLeftTop.x+Pos;\n   float yOffset = gLeftTop.y-RowOffsetY(iRow)-gRowHeight*(1-yPos);\n\n   if(width>0){\n     scale = (float)width/(float)(text.Length()*(gLetterWidth*kProp));\n\n     if(scale>=1)\n       scale = kProp;\n     else{\n        fwas = true;\n        scale = width/(float)(text.Length()*gLetterWidth);\n        if(scale>kProp)scale = kProp;\n     }\n   }else{\n      scale = kProp;\n   }\n\n   aText = gOwner->DrawText(text,scale*gRowHeight,align,xOffset,yOffset);\n\n   return fwas?scale:0;\n}\n\n\n#endif // WITHOUT_AUTOCAD\n",
			"file": "AutoCADHelper.cpp",
			"file_size": 71415,
			"file_write_time": 130921674238296463,
			"settings":
			{
				"buffer_size": 69070,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AutoCADHelper.h",
			"settings":
			{
				"buffer_size": 20963,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Helpers.cpp",
			"settings":
			{
				"buffer_size": 4073,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 157.0,
		"last_filter": "Package Control: ins",
		"selected_items":
		[
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"Package Control: Ins",
				"Package Control: Install Package"
			]
		],
		"width": 560.0
	},
	"console":
	{
		"height": 160.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/_DISTR/_ASUDOR/RSign"
	],
	"file_history":
	[
		"/D/_DISTR/_ASUDOR/RSign/MainUnit.cpp",
		"/D/_DISTR/_ASUDOR/RSign/AutoCADPrintForm.cpp",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Package Control/Package Control.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Package Control.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Default/Default (Windows).sublime-keymap",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/D/_DISTR/_ASUDOR/RSign/AutoCADPrintForm.h",
		"/D/_DISTR/_ASUDOR/RSign/rsign.sublime-project",
		"/D/_DISTR/_ASUDOR/RSign/RoadMark.cpp",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/SublimeAStyleFormatter/Default (Windows).sublime-keymap",
		"/E/Projects/RSign/AutoCADExportHelper.cpp",
		"/E/Projects/RSign/AutoCADPrintForm.cpp",
		"/E/Projects/RSign/AutoCADPrintForm.h"
	],
	"find":
	{
		"height": 38.0
	},
	"find_in_files":
	{
		"height": 126.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"GetCenterOnPolyline",
			"int",
			"DrawTextOverPoly",
			"GetAngle",
			"GetAngle2",
			",",
			" / 100",
			"step",
			"iStep",
			"DrawEmpty",
			"RowslEnd",
			"minS",
			"minE",
			"DrawVerticalText",
			"DrawRepeatVerticalTextInterval",
			"ExportSlope",
			"GetAngle2",
			"GetLength",
			"StringConvert",
			"StringConvertSignals",
			"StringConvertSignalsHelpr",
			"SignLabelParser",
			"compareSigns",
			"GetAngle",
			"spCount",
			"lessForVerticalLabels",
			"TRoadSign",
			"TRoadSignn",
			"package"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": true,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Helpers.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1032,
						"regions":
						{
						},
						"selection":
						[
							[
								329,
								338
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "acadexport.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 135211,
						"regions":
						{
						},
						"selection":
						[
							[
								51423,
								51423
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 32978.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "AcadExportThread.cpp",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 40106,
						"regions":
						{
						},
						"selection":
						[
							[
								27654,
								27654
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 19435.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 76826,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										133,
										144
									],
									[
										490,
										501
									],
									[
										865,
										876
									],
									[
										1113,
										1124
									],
									[
										1197,
										1208
									],
									[
										1389,
										1400
									],
									[
										1520,
										1531
									],
									[
										1886,
										1897
									],
									[
										2280,
										2291
									],
									[
										2698,
										2709
									],
									[
										2990,
										3001
									],
									[
										3163,
										3174
									],
									[
										3365,
										3376
									],
									[
										3567,
										3578
									],
									[
										3737,
										3748
									],
									[
										3916,
										3927
									],
									[
										4092,
										4103
									],
									[
										4268,
										4279
									],
									[
										4440,
										4451
									],
									[
										4616,
										4627
									],
									[
										4774,
										4785
									],
									[
										4944,
										4955
									],
									[
										5121,
										5132
									],
									[
										5288,
										5299
									],
									[
										5472,
										5483
									],
									[
										5652,
										5663
									],
									[
										5828,
										5839
									],
									[
										6010,
										6021
									],
									[
										6193,
										6204
									],
									[
										6383,
										6394
									],
									[
										6548,
										6559
									],
									[
										6916,
										6946
									],
									[
										7207,
										7237
									],
									[
										7654,
										7684
									],
									[
										7946,
										7976
									],
									[
										8411,
										8441
									],
									[
										8728,
										8758
									],
									[
										8936,
										8966
									],
									[
										9213,
										9243
									],
									[
										9811,
										9827
									],
									[
										10133,
										10149
									],
									[
										10451,
										10467
									],
									[
										10774,
										10790
									],
									[
										11063,
										11079
									],
									[
										11385,
										11401
									],
									[
										11703,
										11719
									],
									[
										12026,
										12042
									],
									[
										12298,
										12314
									],
									[
										12416,
										12432
									],
									[
										12615,
										12631
									],
									[
										12716,
										12732
									],
									[
										12870,
										12886
									],
									[
										12973,
										12989
									],
									[
										13203,
										13219
									],
									[
										13321,
										13337
									],
									[
										13407,
										13423
									],
									[
										13556,
										13572
									],
									[
										13943,
										13959
									],
									[
										14534,
										14538
									],
									[
										14656,
										14660
									],
									[
										14926,
										14930
									],
									[
										15336,
										15340
									],
									[
										15679,
										15683
									],
									[
										15889,
										15893
									],
									[
										16018,
										16022
									],
									[
										16377,
										16381
									],
									[
										16844,
										16848
									],
									[
										17361,
										17365
									],
									[
										17704,
										17708
									],
									[
										17914,
										17918
									],
									[
										18043,
										18047
									],
									[
										18368,
										18372
									],
									[
										18854,
										18858
									],
									[
										19093,
										19097
									],
									[
										19431,
										19435
									],
									[
										19586,
										19590
									],
									[
										19886,
										19890
									],
									[
										20373,
										20377
									],
									[
										20825,
										20829
									],
									[
										21380,
										21384
									],
									[
										21712,
										21716
									],
									[
										22190,
										22194
									],
									[
										22768,
										22772
									],
									[
										23155,
										23159
									],
									[
										23473,
										23477
									],
									[
										23834,
										23838
									],
									[
										24029,
										24033
									],
									[
										24242,
										24246
									],
									[
										24490,
										24494
									],
									[
										24706,
										24710
									],
									[
										24941,
										24945
									],
									[
										25243,
										25247
									],
									[
										25554,
										25558
									],
									[
										25907,
										25911
									],
									[
										26294,
										26298
									],
									[
										26819,
										26823
									],
									[
										27393,
										27397
									],
									[
										27757,
										27761
									],
									[
										28013,
										28017
									],
									[
										28331,
										28335
									],
									[
										28651,
										28655
									],
									[
										28977,
										28981
									],
									[
										29303,
										29307
									],
									[
										29629,
										29633
									],
									[
										29955,
										29959
									],
									[
										30287,
										30291
									],
									[
										30633,
										30637
									],
									[
										30889,
										30893
									],
									[
										31177,
										31181
									],
									[
										31563,
										31567
									],
									[
										31886,
										31890
									],
									[
										32218,
										32222
									],
									[
										32587,
										32591
									],
									[
										32987,
										32991
									],
									[
										33260,
										33264
									],
									[
										33581,
										33585
									],
									[
										33999,
										34003
									],
									[
										34315,
										34319
									],
									[
										34750,
										34754
									],
									[
										35171,
										35175
									],
									[
										35410,
										35414
									],
									[
										35748,
										35752
									],
									[
										35903,
										35907
									],
									[
										36203,
										36207
									],
									[
										36690,
										36694
									],
									[
										37142,
										37146
									],
									[
										37697,
										37701
									],
									[
										38029,
										38033
									],
									[
										38507,
										38511
									],
									[
										39085,
										39089
									],
									[
										39472,
										39476
									],
									[
										39790,
										39794
									],
									[
										40151,
										40155
									],
									[
										40346,
										40350
									],
									[
										40559,
										40563
									],
									[
										40807,
										40811
									],
									[
										41023,
										41027
									],
									[
										41258,
										41262
									],
									[
										41560,
										41564
									],
									[
										41871,
										41875
									],
									[
										42224,
										42228
									],
									[
										42611,
										42615
									],
									[
										43136,
										43140
									],
									[
										43710,
										43714
									],
									[
										44074,
										44078
									],
									[
										44330,
										44334
									],
									[
										44648,
										44652
									],
									[
										44968,
										44972
									],
									[
										45294,
										45298
									],
									[
										45620,
										45624
									],
									[
										45946,
										45950
									],
									[
										46272,
										46276
									],
									[
										46604,
										46608
									],
									[
										46950,
										46954
									],
									[
										47206,
										47210
									],
									[
										47494,
										47498
									],
									[
										47880,
										47884
									],
									[
										48203,
										48207
									],
									[
										48535,
										48539
									],
									[
										48904,
										48908
									],
									[
										49304,
										49308
									],
									[
										49577,
										49581
									],
									[
										49898,
										49902
									],
									[
										50316,
										50320
									],
									[
										50632,
										50636
									],
									[
										51067,
										51071
									],
									[
										51493,
										51497
									],
									[
										51933,
										51937
									],
									[
										52373,
										52377
									],
									[
										52769,
										52773
									],
									[
										52891,
										52895
									],
									[
										53306,
										53310
									],
									[
										53458,
										53462
									],
									[
										53878,
										53886
									],
									[
										54085,
										54093
									],
									[
										54192,
										54200
									],
									[
										54303,
										54311
									],
									[
										54367,
										54375
									],
									[
										54455,
										54463
									],
									[
										54563,
										54571
									],
									[
										54627,
										54635
									],
									[
										54715,
										54723
									],
									[
										54807,
										54815
									],
									[
										54899,
										54907
									],
									[
										55050,
										55058
									],
									[
										55083,
										55091
									],
									[
										55213,
										55221
									],
									[
										55277,
										55285
									],
									[
										55437,
										55445
									],
									[
										55654,
										55662
									],
									[
										55814,
										55822
									],
									[
										55833,
										55841
									],
									[
										55866,
										55874
									],
									[
										56138,
										56146
									],
									[
										56331,
										56339
									],
									[
										56688,
										56697
									],
									[
										56919,
										56928
									],
									[
										57092,
										57101
									],
									[
										57262,
										57271
									],
									[
										57467,
										57476
									],
									[
										57737,
										57746
									],
									[
										58351,
										58356
									],
									[
										58619,
										58624
									],
									[
										58811,
										58816
									],
									[
										59003,
										59008
									],
									[
										59265,
										59270
									],
									[
										59376,
										59381
									],
									[
										59511,
										59516
									],
									[
										59535,
										59540
									],
									[
										59783,
										59788
									],
									[
										59806,
										59811
									],
									[
										60103,
										60108
									],
									[
										60396,
										60401
									],
									[
										60763,
										60768
									],
									[
										60942,
										60947
									],
									[
										61072,
										61077
									],
									[
										61252,
										61257
									],
									[
										61330,
										61335
									],
									[
										61449,
										61454
									],
									[
										61598,
										61603
									],
									[
										61827,
										61832
									],
									[
										61971,
										61976
									],
									[
										62091,
										62096
									],
									[
										62260,
										62265
									],
									[
										62347,
										62352
									],
									[
										62557,
										62562
									],
									[
										62957,
										62962
									],
									[
										63278,
										63283
									],
									[
										63461,
										63466
									],
									[
										63548,
										63553
									],
									[
										63841,
										63846
									],
									[
										64072,
										64077
									],
									[
										64374,
										64379
									],
									[
										64605,
										64610
									],
									[
										64925,
										64930
									],
									[
										65235,
										65240
									],
									[
										65466,
										65471
									],
									[
										65618,
										65623
									],
									[
										65859,
										65864
									],
									[
										66181,
										66186
									],
									[
										66499,
										66504
									],
									[
										66822,
										66827
									],
									[
										67111,
										67116
									],
									[
										67433,
										67438
									],
									[
										67751,
										67756
									],
									[
										68074,
										68079
									],
									[
										68337,
										68342
									],
									[
										68458,
										68463
									],
									[
										68625,
										68630
									],
									[
										68752,
										68757
									],
									[
										68940,
										68945
									],
									[
										69107,
										69112
									],
									[
										69276,
										69281
									],
									[
										69398,
										69403
									],
									[
										69565,
										69570
									],
									[
										69693,
										69698
									],
									[
										69880,
										69885
									],
									[
										70046,
										70051
									],
									[
										70335,
										70340
									],
									[
										70655,
										70660
									],
									[
										70827,
										70832
									],
									[
										70916,
										70921
									],
									[
										71241,
										71246
									],
									[
										71514,
										71519
									],
									[
										71742,
										71747
									],
									[
										72025,
										72030
									],
									[
										72237,
										72242
									],
									[
										72751,
										72760
									],
									[
										72932,
										72941
									],
									[
										73218,
										73227
									],
									[
										73478,
										73487
									],
									[
										74054,
										74063
									],
									[
										74235,
										74244
									],
									[
										74521,
										74530
									],
									[
										74874,
										74883
									],
									[
										75341,
										75357
									],
									[
										75673,
										75689
									],
									[
										75907,
										75923
									],
									[
										76079,
										76095
									],
									[
										76249,
										76265
									],
									[
										76500,
										76516
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								75346,
								75346
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 12,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 35398.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "AutoCADHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 69070,
						"regions":
						{
						},
						"selection":
						[
							[
								57874,
								57875
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 42846.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "AutoCADHelper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20963,
						"regions":
						{
						},
						"selection":
						[
							[
								10023,
								10023
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4895.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "Helpers.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4073,
						"regions":
						{
						},
						"selection":
						[
							[
								597,
								597
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 89.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 36.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.CppYCM.2":
	{
		"height": 0.0
	},
	"output.astyle_error_message":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "rsign.sublime-project",
	"replace":
	{
		"height": 68.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 625.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 475.0
	},
	"select_symbol":
	{
		"height": 297.0,
		"last_filter": "pause",
		"selected_items":
		[
			[
				"pause",
				"PauseLastFramePrint"
			],
			[
				"Paus",
				"PauseLastFramePrint"
			],
			[
				"Last",
				"PauseLastFramePrint"
			]
		],
		"width": 490.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 339.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
