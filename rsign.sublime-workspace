{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"cmb",
				"cmbAutoCADVersion"
			],
			[
				"SetA",
				"setAutoCADVersion"
			],
			[
				"lef",
				"leftPos"
			],
			[
				"Tp",
				"TPoint"
			],
			[
				"las",
				"lastI"
			],
			[
				"sca",
				"ScaleY"
			],
			[
				"va",
				"value"
			]
		]
	},
	"buffers":
	[
		{
			"file": "acadexport.cpp",
			"settings":
			{
				"buffer_size": 135462,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AutoCADExportForm.cpp",
			"settings":
			{
				"buffer_size": 27924,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AutoCADPrintForm.cpp",
			"settings":
			{
				"buffer_size": 25862,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Program Files (x86)/Borland/CBuilder6/Imports/AutoCAD_TLB.h",
			"settings":
			{
				"buffer_size": 12601258,
				"line_ending": "Windows"
			}
		},
		{
			"file": "acadexport.h",
			"settings":
			{
				"buffer_size": 9673,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AcadExportThread.cpp",
			"settings":
			{
				"buffer_size": 40172,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 2114 files for \"ExportSlope\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2906  }\n 2907  \n 2908: bool __fastcall TAcadExport::ExportSlope(TDangerSlope *s, int fase, bool fEnd) {\n 2909      if (fEnd) {\n 2910          return true;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n  153        bool __fastcall ExportSignal(TExtPolyline *Poly,TRoadSignal *s,bool exist, bool fEnd = false);\n  154        bool __fastcall ExportCurve(TDangerCurve *c, bool fEnd = false);\n  155:       bool __fastcall ExportSlope(TDangerSlope *s, int fase = 1, bool fEnd = false);\n  156        bool __fastcall ExportBusStop(TExtPolyline *Poly,TBusStop *s, bool fEnd = false);\n  157        bool __fastcall ExportLighting(TExtPolyline *Poly,TRoadLighting *s, bool exist, bool fEnd = false);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AcadExportThread.cpp:\n  903  }\n  904  \n  905: int __fastcall AcadExportThread::ExportSlope(TDtaSource* data, TAcadExport* aexp)\n  906  {\n  907  	SET_PROGRESS_FORM_POSITION(0)\n  ...\n  914              TDangerSlope *t=dynamic_cast<TDangerSlope*>(data->Objects->Items[i]);\n  915              if (t) {\n  916:                 aexp->ExportSlope(t);\n  917              }\n  918          }\n  919      }\n  920:     aexp->ExportSlope(0,0,true);\n  921      return 0;\n  922  }\n  ...\n 1174          // Участки уклонов выводим из слоя с профилем\n 1175          if (ProfilData) {\n 1176:             if (FAutoCADExport->ExportSlope) {\n 1177                  SET_PROGRESS_FORM_MINMAX(0,ProfilData->Objects->Count-1);\n 1178:                 EXPORT_ITEM(ExportSlope(ProfilData, aexp), \"Выводим участки уклонов ...\");\n 1179              }\n 1180          }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AcadExportThread.h:\n   80          int __fastcall ExportLamps(vector<pair<int,wpbar> > &data, TAcadExport* aexp);\n   81          int __fastcall ExportBorders(vector<pair<int,wpbar> > &data, TAcadExport* aexp);\n   82:         int __fastcall ExportSlope(TDtaSource* data, TAcadExport* aexp);\n   83          int __fastcall ExportCurves(TDtaSource* data, TAcadExport* aexp);        \n   84  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADExportForm.cpp:\n   90     ini->WriteBool(\"AutoCAD\",\"ExportSignalExistToo\",chkSignalExistToo->Checked);\n   91     ini->WriteBool(\"AutoCAD\",\"ExportTubes\",chkTubes->Checked);\n   92:    ini->WriteBool(\"AutoCAD\",\"ExportSlopes\",chkSlope->Checked);\n   93     ini->WriteBool(\"AutoCAD\",\"ExportCurves\",chkCurves->Checked);\n   94     ini->WriteBool(\"AutoCAD\",\"ExportMoundHeights\",chkMoundHeights->Checked);\n   ..\n  183     chkSignalExistToo->Checked = ini->ReadBool(\"AutoCAD\",\"ExportSignalExistToo\",false);\n  184     chkTubes->Checked = ini->ReadBool(\"AutoCAD\",\"ExportTubes\",true);\n  185:    chkSlope->Checked = ini->ReadBool(\"AutoCAD\",\"ExportSlopes\",true);\n  186     chkMoundHeights->Checked = ini->ReadBool(\"AutoCAD\",\"ExportMoundHeights\",true);\n  187     chkCurves->Checked = ini->ReadBool(\"AutoCAD\",\"ExportCurves\",true);\n  ...\n  761      count += ExportBusstops;\n  762      count += ExportRoadSideObjects;\n  763:     count += ExportSlope;\n  764      count += ExportCurves;\n  765      count += ExportMoundHeights;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign.ini:\n   42  ExportSignal=1\n   43  ExportTubes=1\n   44: ExportSlopes=1\n   45  ExportCurves=1\n   46  ExportTable=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.ini:\n   42  ExportSignal=1\n   43  ExportTubes=1\n   44: ExportSlopes=1\n   45  ExportCurves=1\n   46  ExportTable=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ОДН.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ОДН_петя.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД (область) А3.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД (область).ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город-175.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД-город_250.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ПОДД.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\ТП-город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\журнал для ПОДД.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\новый.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\техпаспорт А4 - насыпи.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=0\n   13: ExportSlopes=0\n   14  ExportCurves=0\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт - только знаки.ini:\n   10  ExportSignal=0\n   11  ExportTubes=0\n   12: ExportSlopes=0\n   13  ExportCurves=0\n   14  ExportMoundHeights=0\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_город.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=0\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_1-2000.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=1\n   13: ExportSlopes=1\n   14  ExportCurves=1\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт A4_1-2000_насыпи.ini:\n   11  ExportSignalExistToo=0\n   12  ExportTubes=0\n   13: ExportSlopes=0\n   14  ExportCurves=0\n   15  ExportMoundHeights=1\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Tех Паспорт.ini:\n   10  ExportSignal=1\n   11  ExportTubes=1\n   12: ExportSlopes=1\n   13  ExportCurves=1\n   14  ExportMoundHeights=1\n\n71 matches across 27 files\n\n\nSearching 2114 files for \"DrawRepeatVerticalTextInterval\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2923          if (iTopSlopes >= 0) {\n 2924              tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2925:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2926          }\n 2927          if (iBottomSlopes >= 0) {\n 2928              tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2929:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2930          }\n 2931          if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n ....\n 2934          if (iTopSlopes >= 0) {\n 2935              tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2936:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2937          }\n 2938          if (iBottomSlopes >= 0) {\n 2939              tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2940:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2941          }\n 2942          if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n ....\n 2945          if (iTopSlopes >= 0) {\n 2946              tableTop.DrawLine(iTopSlopes, s->LMin, tableTop.kBottomEmptyPadding, s->LMax, tableTop.kBottomEmptyPadding);\n 2947:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2948          }\n 2949          if (iBottomSlopes >= 0) {\n 2950              tableBottom.DrawLine(iBottomSlopes, s->LMin, tableBottom.kBottomEmptyPadding, s->LMax, tableBottom.kBottomEmptyPadding);\n 2951:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2952          }\n 2953      }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1955  }\n 1956  \n 1957: void AutoCADTable::DrawRepeatVerticalTextInterval(int iRow,\n 1958                                  float sPos, float ePos,float kyPos,\n 1959                                  float step, bool fWithBorders, float kProp)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  237  \n  238  \n  239:         void DrawRepeatVerticalTextInterval(int iRow,float sPos, float ePos,\n  240                                  float step = 0,float kyPos = 0.75,\n  241                                  bool fWithBorders = true, float kProp = 0.43);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n19 matches across 5 files\n\n\nSearching 2114 files for \"DrawVerticalText\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 2789                      }\n 2790                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2791:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2792                  }\n 2793                  if (iBottomCurves >= 0) {\n ....\n 2801                      }\n 2802                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2803:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2804                  }\n 2805              } else if (lKind == ckCircle) {\n ....\n 2814                      }\n 2815                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2816:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2817                  }\n 2818                  if (iBottomCurves >= 0) {\n ....\n 2826                      }\n 2827                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2828:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2829                  }\n 2830              }\n ....\n 2845                      }\n 2846                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2847:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2848                  }\n 2849                  if (iBottomCurves >= 0) {\n ....\n 2857                      }\n 2858                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2859:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2860                  }\n 2861              } else if (lKind == ckCircle) {\n ....\n 2870                      }\n 2871                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2872:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2873                  }\n 2874                  if (iBottomCurves >= 0) {\n ....\n 2882                      }\n 2883                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2884:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2885                  }\n 2886              }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1985       if(sPos<iMin*step){\n 1986           if(int(sPos)%int(step) == 0){\n 1987:              DrawVerticalText(0,iRow,sPos,1-kyPos,true,kProp);\n 1988           }\n 1989           temp = iMin*step;\n 1990:          DrawVerticalText(1000,iRow,temp,kyPos,false,kProp);\n 1991           pos[counter++] = iMin*step;\n 1992       }\n 1993       for(int i=iMin;i<iMax-1;i++){\n 1994           temp = i*step;\n 1995:          DrawVerticalText(0,iRow,temp,1-kyPos,true,kProp);\n 1996           temp = (i+1)*step;\n 1997:          DrawVerticalText(1000,iRow,temp,kyPos,false,kProp);\n 1998       }\n 1999       if(ePos>(iMax-1)*step){\n 2000          temp = (iMax-1)*step;\n 2001:         DrawVerticalText(0,iRow,temp,1-kyPos,true,kProp);\n 2002          pos[counter++] = ePos;\n 2003:         DrawVerticalText(int(ePos)%int(step)/100,iRow,ePos,kyPos,false,kProp);\n 2004       }\n 2005       if(fWithBorders) DrawSnakeBorder(iRow,pos,counter);\n ....\n 2007     }else{\n 2008       if(int(sPos)%int(step) == 0){\n 2009:          DrawVerticalText(0,iRow,sPos,1-kyPos,true,kProp);\n 2010       }\n 2011       if(int(ePos)%int(step)==0){\n 2012:        DrawVerticalText(1000,iRow,ePos,1-kyPos,true,kProp);\n 2013       }else{\n 2014:        DrawVerticalText(int(ePos)%int(step)/100,iRow,ePos,kyPos,false,kProp);\n 2015       }\n 2016  \n ....\n 2054  }\n 2055  \n 2056: AcadTextPtr AutoCADTable::DrawVerticalText(AnsiString txt, int iRow, float Pos,\n 2057                                           float kyPos,bool fRight, float kProp)\n 2058  {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  166                                      bool fWithBorders = true,float kProp = 0.43);\n  167          void DrawHeaderText(int row,AnsiString str, float kProp = 0.34);\n  168:         AcadTextPtr DrawVerticalText(AnsiString txt, int iRow, float Pos, float kyPos = 0.5,\n  169                                          bool fRight = true, float kProp = 0.2);\n  170          /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n30 matches across 5 files\n\n\nSearching 2114 files for \"minE\"\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  138            }\n  139            minS = -1;\n  140:           minE = -1;          \n  141          }        \n  142  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\DBDataSource.cpp:\n 2129  DB->Connection=FConnection;\n 2130  DB->CommandText=String(\"insert into ListDataSources (FullTitle,NumRoad,NumType,\\\n 2131:         NumOrganization,Executor,Examiner,DateCreate,DateBegin)\\\n 2132          values ('\")+PrjName+String(\"',\")+String(RoadId)+String(\",3,\")+String(OrgNum)+\n 2133          String(\",'\")+ExecName+String(\"','\")+ExamName+\n\nD:\\_DISTR\\_ASUDOR\\RSign\\GdiEdit.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\LICENSE:\n  102  \n  103    An interactive user interface displays \"Appropriate Legal Notices\"\n  104: to the extent that it includes a convenient and prominently visible\n  105  feature that (1) displays an appropriate copyright notice, and (2)\n  106  tells the user that there is no warranty for the work (except to the\n  ...\n  108  work under this License, and how to view a copy of this License.  If\n  109  the interface presents a list of user commands or options, such as a\n  110: menu, a prominent item in the list meets this criterion.\n  111  \n  112    1. Source Code.\n  ...\n  212  terms of section 4, provided that you also meet all of these conditions:\n  213  \n  214:     a) The work must carry prominent notices stating that you modified\n  215      it, and giving a relevant date.\n  216  \n  217:     b) The work must carry prominent notices stating that it is\n  218      released under this License and any conditions added under section\n  219      7.  This requirement modifies the requirement in section 4 to\n\nD:\\_DISTR\\_ASUDOR\\RSign\\OpenSource.cpp:\n   18  {\n   19  if(ADODataSet1->Active) ADODataSet1->Active=false;\n   20: ADODataSet1->CommandText=\"select id_,FullTitle,Executor,Examiner,DateCreate,NumType\\\n   21   from ListDataSources where NumRoad=\"+String(RoadId)+\" or id_<10 order by id_\";\n   22  if(!ADODataSet1->Active) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\ActiveX\\MediaPlayer_TLB.h:\n 1026    // [2010] Opens the given filename asynchronously\n 1027    virtual HRESULT STDMETHODCALLTYPE Open(BSTR bstrFileName/*[in]*/) = 0;\n 1028:   // [53] Determines whether the sound card is enabled on the machine\n 1029    virtual HRESULT STDMETHODCALLTYPE IsSoundCardEnabled(VARIANT_BOOL* pbSoundCard/*[out,retval]*/) = 0;\n 1030    // [2023] Jumps to the next item\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\_old\\_decimal.pyd:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\packages\\iTextSharp.5.5.5\\AGPL.txt:\n   90  \n   91    An interactive user interface displays \"Appropriate Legal Notices\"\n   92: to the extent that it includes a convenient and prominently visible\n   93  feature that (1) displays an appropriate copyright notice, and (2)\n   94  tells the user that there is no warranty for the work (except to the\n   ..\n   96  work under this License, and how to view a copy of this License.  If\n   97  the interface presents a list of user commands or options, such as a\n   98: menu, a prominent item in the list meets this criterion.\n   99  \n  100    1. Source Code.\n  ...\n  200  terms of section 4, provided that you also meet all of these conditions:\n  201  \n  202:     a) The work must carry prominent notices stating that you modified\n  203      it, and giving a relevant date.\n  204  \n  205:     b) The work must carry prominent notices stating that it is\n  206      released under this License and any conditions added under section\n  207      7.  This requirement modifies the requirement in section 4 to\n  ...\n  541  \n  542    Notwithstanding any other provision of this License, if you modify the\n  543: Program, your modified version must prominently offer all users\n  544  interacting with it remotely through a computer network (if your version\n  545  supports such interaction) an opportunity to receive the Corresponding\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\packages\\iTextSharp.5.5.5\\lib\\iTextSharp.xml:\n  427              Applies the properties of the Anchor to a Chunk.\n  428              @param chunk			the Chunk (part of the Anchor)\n  429:             @param notGotoOK		if true, this chunk will determine the local destination\n  430              @param localDestination	true if the chunk is a local goto and the reference a local destination\n  431:             @return	the value of notGotoOK or false, if a previous Chunk was used to determine the local destination\n  432          </member>\n  433          <member name=\"P:iTextSharp.text.Anchor.Chunks\">\n  ...\n 9463              These are applied later in the line-based phase of the algorithm.\n 9464          </member>\n 9465:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineParagraphEmbeddingLevel\" проигнорирован -->\n 9466:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineExplicitEmbeddingLevels\" проигнорирован -->\n 9467          <member name=\"M:iTextSharp.text.pdf.BidiOrder.RemoveExplicitCodes\">\n 9468              Rules X9.\n ....\n 9487              \n 9488               The interaction of these rules makes handling them a bit complex.\n 9489:              This examines resultTypes but does not modify it.  It returns embedding and\n 9490               override information in the result array.  The low 7 bits are the level, the high\n 9491               bit is set if the level is an override, and clear if it is an embedding.\n ....\n 14827               a binary tree but a lot less than a trie. Performance is\n 14828               comparable with a hash table, sometimes it outperforms a hash\n 14829:              function (most of the time can determine a miss faster than a hash).</p>\n 14830              \n 14831               <p>The main purpose of this java port is to serve as a base for\n .....\n 15725          </member>\n 15726          <member name=\"M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk,iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)\">\n 15727:             Determines if a space character should be inserted between a previous chunk and the current chunk.\n 15728              This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.\n 15729              By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the\n .....\n 15848          </member>\n 15849          <member name=\"M:iTextSharp.text.pdf.parser.MarkedContentInfo.HasMcid\">\n 15850:             Determine if an MCID is available\n 15851              @return true if the MCID is available, false otherwise\n 15852          </member>\n .....\n 16424              being a true representation of how it appears in the PDF.\n 16425              \n 16426:             This renderer also uses a simple strategy based on the font metrics to determine if\n 16427              a blank space should be inserted into the output.\n 16428              \n .....\n 16641          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.GetRise\">\n 16642              The rise represents how far above the nominal baseline the text should be rendered.  The {@link #getBaseline()}, {@link #getAscentLine()} and {@link #getDescentLine()} methods already include Rise.\n 16643:             This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)\n 16644              @return The Rise for the text draw operation, in user space units (Ts value, scaled to user space)\n 16645              @since 5.3.3\n .....\n 16710          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.Decode(iTextSharp.text.pdf.PdfString)\">\n 16711              Decodes a PdfString (which will contain glyph ids encoded in the font's encoding)\n 16712:             based on the active font, and determine the unicode equivalent\n 16713              @param in	the String that needs to be encoded\n 16714              @return	    the encoded String\n .....\n 17296          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Clip\">\n 17297              Modify the current clipping path by intersecting it with the current path, using the\n 17298:             nonzero winding number rule to determine which regions lie inside the clipping\n 17299              path.\n 17300          </member>\n 17301          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoClip\">\n 17302              Modify the current clipping path by intersecting it with the current path, using the\n 17303:             even-odd rule to determine which regions lie inside the clipping path.\n 17304          </member>\n 17305          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.SetGrayFill(System.Single)\">\n .....\n 17462          </member>\n 17463          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Fill\">\n 17464:             Fills the path, using the non-zero winding number rule to determine the region to fill.\n 17465          </member>\n 17466          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFill\">\n 17467:             Fills the path, using the even-odd rule to determine the region to fill.\n 17468          </member>\n 17469          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.FillStroke\">\n 17470:             Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.\n 17471          </member>\n 17472          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathFillStroke\">\n 17473:             Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.\n 17474          </member>\n 17475          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFillStroke\">\n 17476:             Fills the path, using the even-odd rule to determine the region to fill and strokes it.\n 17477          </member>\n 17478          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathEoFillStroke\">\n 17479:             Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.\n 17480          </member>\n 17481          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image)\">\n .....\n 20281          </member>\n 20282          <member name=\"P:iTextSharp.text.pdf.PdfGState.TextKnockout\">\n 20283:             Determines the behaviour of overlapping glyphs within a text object\n 20284              in the transparent imaging model.\n 20285              @param v\n .....\n 24560          </member>\n 24561          <member name=\"M:iTextSharp.text.pdf.PdfPTable.GetFittingRows(System.Single,System.Int32)\">\n 24562:             Determine which rows fit on the page, respecting isSplitLate().\n 24563              Note: sets max heights of the inspected rows as a side effect,\n 24564              just like PdfPTable.getRowHeight(int, boolean) does.\n .....\n 25486          </member>\n 25487          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FormFlattening\">\n 25488:             Determines if the fields are flattened on close. The fields added with\n 25489              {@link #addAnnotation(PdfAnnotation,int)} will never be flattened.\n 25490              @param flat <CODE>true</CODE> to flatten the fields, <CODE>false</CODE>\n .....\n 25492          </member>\n 25493          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FreeTextFlattening\">\n 25494:             Determines if the FreeText annotations are flattened on close. \n 25495              @param flat <CODE>true</CODE> to flatten the FreeText annotations, <CODE>false</CODE>\n 25496              (the default) to keep the FreeText annotations as active content.\n .....\n 26002          <member name=\"M:iTextSharp.text.pdf.PRTokeniser.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)\">\n 26003              Creates a PRTokeniser for the specified {@link RandomAccessSource}.\n 26004:             The beginning of the file is read to determine the location of the header, and the data source is adjusted\n 26005              as necessary to account for any junk that occurs in the byte source before the header\n 26006              @param file the source\n .....\n 29237                 rejection              (2), -- you don't get it, more information elsewhere in the message\n 29238                 waiting                (3), -- the request body part has not yet been processed, expect to hear more later\n 29239:                revocationWarning      (4), -- this message contains a warning that a revocation is imminent\n 29240                 revocationNotification (5), -- notification that a revocation has occurred\n 29241                 keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg\n .....\n 34802          </member>\n 34803          <member name=\"P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse\">\n 34804:             determines whether or not strings should be processed and printed\n 34805              from back to front.\n 34806          </member>\n .....\n 38099               Convenience Method for data exchange with the cipher.\n 38100              \n 38101:              Determines blocksize and splits data to blocksize.\n 38102              \n 38103               @param data the data to be processed\n .....\n 38267               word <em>x</em> is rotated left by <em>y</em> bits.\n 38268               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38269:              are used to determine the rotation amount. Here it is\n 38270               assumed that the wordsize used is a power of 2.\n 38271              \n .....\n 38277               word <em>x</em> is rotated left by <em>y</em> bits.\n 38278               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38279:              are used to determine the rotation amount. Here it is\n 38280               assumed that the wordsize used is a power of 2.\n 38281              \n .....\n 38320               word <em>x</em> is rotated left by <em>y</em> bits.\n 38321               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38322:              are used to determine the rotation amount. Here it is\n 38323               assumed that the wordsize used is a power of 2.\n 38324              \n .....\n 38330               word <em>x</em> is rotated left by <em>y</em> bits.\n 38331               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38332:              are used to determine the rotation amount. Here it is\n 38333               assumed that the wordsize used is a power of 2.\n 38334              \n .....\n 38360               word <em>x</em> is rotated left by <em>y</em> bits.\n 38361               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38362:              are used to determine the rotation amount. Here it is\n 38363               assumed that the wordsize used is a power of 2.\n 38364              \n .....\n 38370               word <em>x</em> is rotated left by <em>y</em> bits.\n 38371               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38372:              are used to determine the rotation amount. Here it is\n 38373               assumed that the wordsize used is a power of 2.\n 38374              \n .....\n 41283          <member name=\"M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])\">\n 41284              <summary>\n 41285:             Reports the session ID once it has been determined.\n 41286              </summary>\n 41287              <param name=\"sessionID\">\n .....\n 42928              Open a literal data packet, returning a stream to store the data inside the packet,\n 42929              as an indefinite length stream. The stream is written out as a series of partial\n 42930:             packets with a chunk size determined by the size of the passed in buffer.\n 42931              </p>\n 42932              <p>\n .....\n 47227               RestoreAfterInsert\n 47228               Additions to red-black trees usually destroy the red-black \n 47229:              properties. Examine the tree and restore. Rotations are normally \n 47230               required to restore it\n 47231              </summary>\n .....\n 47257               RestoreAfterDelete\n 47258               Deletions from red-black trees may destroy the red-black \n 47259:              properties. Examine the tree and restore. Rotations are normally \n 47260               required to restore it\n 47261              </summary>\n .....\n 47268          <member name=\"M:System.util.collections.OrderedTreeEnumerator.#ctor(System.util.collections.OrderedTreeNode,System.Boolean,System.Boolean,System.util.collections.OrderedTreeNode)\">\n 47269              <summary>\n 47270:              Determine order, walk the tree and push the nodes onto the stack\n 47271              </summary>\n 47272          </member>\n .....\n 47808          </member>\n 47809          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.sources\">\n 47810:             The underlying sources (along with some meta data to quickly determine where each source begins and ends)\n 47811          </member>\n 47812          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.currentSourceEntry\">\n .....\n 47938          <member name=\"P:iTextSharp.text.io.RAFRandomAccessSource.Length\">\n 47939              {@inheritDoc}\n 47940:             Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes\n 47941              after construction, that change will not be reflected in this call.\n 47942          </member>\n .....\n 47959          </member>\n 47960          <member name=\"M:iTextSharp.text.io.RandomAccessSourceFactory.SetForceRead(System.Boolean)\">\n 47961:             Determines whether the full content of the source will be read into memory\n 47962              @param forceRead true if the full content will be read, false otherwise\n 47963              @return this object (this allows chaining of method calls)\n .....\n 50439          </member>\n 50440          <member name=\"T:iTextSharp.text.xml.simpleparser.INewLineHandler\">\n 50441:              A NewLineHandler determines if an encountered tag should result in a new line\n 50442               in a document.\n 50443              \n .....\n 51741          <member name=\"M:iTextSharp.xmp.impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)\">\n 51742              <summary>\n 51743:             Determines the ID for a certain RDF Term.\n 51744              Arranged to hopefully minimize the parse time for large XMP.\n 51745              </summary>\n .....\n 53509          <member name=\"M:iTextSharp.xmp.IXmpSchemaRegistry.ResolveAlias(System.String,System.String)\">\n 53510              <summary>\n 53511:             Determines if a name is an alias, and what it is aliased to.\n 53512              </summary>\n 53513              <param name=\"aliasNs\">\n .....\n 55933                                  -- a brief description or identifier of the encValue content\n 55934                                  -- (may be meaningful only to the sending entity, and used only\n 55935:                                 -- if EncryptedValue might be re-examined by the sending entity\n 55936                                  -- in the future)\n 55937                                  encValue       BIT STRING }\n .....\n 56502          </member>\n 56503          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.ContainsKey(`0)\">\n 56504:             <summary>Determines whether the <see cref=\"T:ReadOnlyDictionary`2\" />\n 56505              contains the specified key.</summary>\n 56506              <returns>\n .....\n 56550          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})\">\n 56551              <summary>\n 56552:             Determines whether the <see cref=\"T:ICollection`1\"/> contains a\n 56553              specific value.\n 56554              </summary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\PDFBinder\\src\\PDFBinder\\PDFBinder\\bin\\Release\\itextsharp.xml:\n  427              Applies the properties of the Anchor to a Chunk.\n  428              @param chunk			the Chunk (part of the Anchor)\n  429:             @param notGotoOK		if true, this chunk will determine the local destination\n  430              @param localDestination	true if the chunk is a local goto and the reference a local destination\n  431:             @return	the value of notGotoOK or false, if a previous Chunk was used to determine the local destination\n  432          </member>\n  433          <member name=\"P:iTextSharp.text.Anchor.Chunks\">\n  ...\n 9463              These are applied later in the line-based phase of the algorithm.\n 9464          </member>\n 9465:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineParagraphEmbeddingLevel\" проигнорирован -->\n 9466:         <!-- Некорректный комментарий в формате XML для члена \"M:iTextSharp.text.pdf.BidiOrder.DetermineExplicitEmbeddingLevels\" проигнорирован -->\n 9467          <member name=\"M:iTextSharp.text.pdf.BidiOrder.RemoveExplicitCodes\">\n 9468              Rules X9.\n ....\n 9487              \n 9488               The interaction of these rules makes handling them a bit complex.\n 9489:              This examines resultTypes but does not modify it.  It returns embedding and\n 9490               override information in the result array.  The low 7 bits are the level, the high\n 9491               bit is set if the level is an override, and clear if it is an embedding.\n ....\n 14827               a binary tree but a lot less than a trie. Performance is\n 14828               comparable with a hash table, sometimes it outperforms a hash\n 14829:              function (most of the time can determine a miss faster than a hash).</p>\n 14830              \n 14831               <p>The main purpose of this java port is to serve as a base for\n .....\n 15725          </member>\n 15726          <member name=\"M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk,iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)\">\n 15727:             Determines if a space character should be inserted between a previous chunk and the current chunk.\n 15728              This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.\n 15729              By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the\n .....\n 15848          </member>\n 15849          <member name=\"M:iTextSharp.text.pdf.parser.MarkedContentInfo.HasMcid\">\n 15850:             Determine if an MCID is available\n 15851              @return true if the MCID is available, false otherwise\n 15852          </member>\n .....\n 16424              being a true representation of how it appears in the PDF.\n 16425              \n 16426:             This renderer also uses a simple strategy based on the font metrics to determine if\n 16427              a blank space should be inserted into the output.\n 16428              \n .....\n 16641          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.GetRise\">\n 16642              The rise represents how far above the nominal baseline the text should be rendered.  The {@link #getBaseline()}, {@link #getAscentLine()} and {@link #getDescentLine()} methods already include Rise.\n 16643:             This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)\n 16644              @return The Rise for the text draw operation, in user space units (Ts value, scaled to user space)\n 16645              @since 5.3.3\n .....\n 16710          <member name=\"M:iTextSharp.text.pdf.parser.TextRenderInfo.Decode(iTextSharp.text.pdf.PdfString)\">\n 16711              Decodes a PdfString (which will contain glyph ids encoded in the font's encoding)\n 16712:             based on the active font, and determine the unicode equivalent\n 16713              @param in	the String that needs to be encoded\n 16714              @return	    the encoded String\n .....\n 17296          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Clip\">\n 17297              Modify the current clipping path by intersecting it with the current path, using the\n 17298:             nonzero winding number rule to determine which regions lie inside the clipping\n 17299              path.\n 17300          </member>\n 17301          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoClip\">\n 17302              Modify the current clipping path by intersecting it with the current path, using the\n 17303:             even-odd rule to determine which regions lie inside the clipping path.\n 17304          </member>\n 17305          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.SetGrayFill(System.Single)\">\n .....\n 17462          </member>\n 17463          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.Fill\">\n 17464:             Fills the path, using the non-zero winding number rule to determine the region to fill.\n 17465          </member>\n 17466          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFill\">\n 17467:             Fills the path, using the even-odd rule to determine the region to fill.\n 17468          </member>\n 17469          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.FillStroke\">\n 17470:             Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.\n 17471          </member>\n 17472          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathFillStroke\">\n 17473:             Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.\n 17474          </member>\n 17475          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.EoFillStroke\">\n 17476:             Fills the path, using the even-odd rule to determine the region to fill and strokes it.\n 17477          </member>\n 17478          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.ClosePathEoFillStroke\">\n 17479:             Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.\n 17480          </member>\n 17481          <member name=\"M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image)\">\n .....\n 20281          </member>\n 20282          <member name=\"P:iTextSharp.text.pdf.PdfGState.TextKnockout\">\n 20283:             Determines the behaviour of overlapping glyphs within a text object\n 20284              in the transparent imaging model.\n 20285              @param v\n .....\n 24560          </member>\n 24561          <member name=\"M:iTextSharp.text.pdf.PdfPTable.GetFittingRows(System.Single,System.Int32)\">\n 24562:             Determine which rows fit on the page, respecting isSplitLate().\n 24563              Note: sets max heights of the inspected rows as a side effect,\n 24564              just like PdfPTable.getRowHeight(int, boolean) does.\n .....\n 25486          </member>\n 25487          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FormFlattening\">\n 25488:             Determines if the fields are flattened on close. The fields added with\n 25489              {@link #addAnnotation(PdfAnnotation,int)} will never be flattened.\n 25490              @param flat <CODE>true</CODE> to flatten the fields, <CODE>false</CODE>\n .....\n 25492          </member>\n 25493          <member name=\"P:iTextSharp.text.pdf.PdfStamper.FreeTextFlattening\">\n 25494:             Determines if the FreeText annotations are flattened on close. \n 25495              @param flat <CODE>true</CODE> to flatten the FreeText annotations, <CODE>false</CODE>\n 25496              (the default) to keep the FreeText annotations as active content.\n .....\n 26002          <member name=\"M:iTextSharp.text.pdf.PRTokeniser.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)\">\n 26003              Creates a PRTokeniser for the specified {@link RandomAccessSource}.\n 26004:             The beginning of the file is read to determine the location of the header, and the data source is adjusted\n 26005              as necessary to account for any junk that occurs in the byte source before the header\n 26006              @param file the source\n .....\n 29237                 rejection              (2), -- you don't get it, more information elsewhere in the message\n 29238                 waiting                (3), -- the request body part has not yet been processed, expect to hear more later\n 29239:                revocationWarning      (4), -- this message contains a warning that a revocation is imminent\n 29240                 revocationNotification (5), -- notification that a revocation has occurred\n 29241                 keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg\n .....\n 34802          </member>\n 34803          <member name=\"P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse\">\n 34804:             determines whether or not strings should be processed and printed\n 34805              from back to front.\n 34806          </member>\n .....\n 38099               Convenience Method for data exchange with the cipher.\n 38100              \n 38101:              Determines blocksize and splits data to blocksize.\n 38102              \n 38103               @param data the data to be processed\n .....\n 38267               word <em>x</em> is rotated left by <em>y</em> bits.\n 38268               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38269:              are used to determine the rotation amount. Here it is\n 38270               assumed that the wordsize used is a power of 2.\n 38271              \n .....\n 38277               word <em>x</em> is rotated left by <em>y</em> bits.\n 38278               Only the <em>lg(32)</em> low-order bits of <em>y</em>\n 38279:              are used to determine the rotation amount. Here it is\n 38280               assumed that the wordsize used is a power of 2.\n 38281              \n .....\n 38320               word <em>x</em> is rotated left by <em>y</em> bits.\n 38321               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38322:              are used to determine the rotation amount. Here it is\n 38323               assumed that the wordsize used is a power of 2.\n 38324              \n .....\n 38330               word <em>x</em> is rotated left by <em>y</em> bits.\n 38331               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38332:              are used to determine the rotation amount. Here it is\n 38333               assumed that the wordsize used is a power of 2.\n 38334              \n .....\n 38360               word <em>x</em> is rotated left by <em>y</em> bits.\n 38361               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38362:              are used to determine the rotation amount. Here it is\n 38363               assumed that the wordsize used is a power of 2.\n 38364              \n .....\n 38370               word <em>x</em> is rotated left by <em>y</em> bits.\n 38371               Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>\n 38372:              are used to determine the rotation amount. Here it is\n 38373               assumed that the wordsize used is a power of 2.\n 38374              \n .....\n 41283          <member name=\"M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])\">\n 41284              <summary>\n 41285:             Reports the session ID once it has been determined.\n 41286              </summary>\n 41287              <param name=\"sessionID\">\n .....\n 42928              Open a literal data packet, returning a stream to store the data inside the packet,\n 42929              as an indefinite length stream. The stream is written out as a series of partial\n 42930:             packets with a chunk size determined by the size of the passed in buffer.\n 42931              </p>\n 42932              <p>\n .....\n 47227               RestoreAfterInsert\n 47228               Additions to red-black trees usually destroy the red-black \n 47229:              properties. Examine the tree and restore. Rotations are normally \n 47230               required to restore it\n 47231              </summary>\n .....\n 47257               RestoreAfterDelete\n 47258               Deletions from red-black trees may destroy the red-black \n 47259:              properties. Examine the tree and restore. Rotations are normally \n 47260               required to restore it\n 47261              </summary>\n .....\n 47268          <member name=\"M:System.util.collections.OrderedTreeEnumerator.#ctor(System.util.collections.OrderedTreeNode,System.Boolean,System.Boolean,System.util.collections.OrderedTreeNode)\">\n 47269              <summary>\n 47270:              Determine order, walk the tree and push the nodes onto the stack\n 47271              </summary>\n 47272          </member>\n .....\n 47808          </member>\n 47809          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.sources\">\n 47810:             The underlying sources (along with some meta data to quickly determine where each source begins and ends)\n 47811          </member>\n 47812          <member name=\"F:iTextSharp.text.io.GroupedRandomAccessSource.currentSourceEntry\">\n .....\n 47938          <member name=\"P:iTextSharp.text.io.RAFRandomAccessSource.Length\">\n 47939              {@inheritDoc}\n 47940:             Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes\n 47941              after construction, that change will not be reflected in this call.\n 47942          </member>\n .....\n 47959          </member>\n 47960          <member name=\"M:iTextSharp.text.io.RandomAccessSourceFactory.SetForceRead(System.Boolean)\">\n 47961:             Determines whether the full content of the source will be read into memory\n 47962              @param forceRead true if the full content will be read, false otherwise\n 47963              @return this object (this allows chaining of method calls)\n .....\n 50439          </member>\n 50440          <member name=\"T:iTextSharp.text.xml.simpleparser.INewLineHandler\">\n 50441:              A NewLineHandler determines if an encountered tag should result in a new line\n 50442               in a document.\n 50443              \n .....\n 51741          <member name=\"M:iTextSharp.xmp.impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)\">\n 51742              <summary>\n 51743:             Determines the ID for a certain RDF Term.\n 51744              Arranged to hopefully minimize the parse time for large XMP.\n 51745              </summary>\n .....\n 53509          <member name=\"M:iTextSharp.xmp.IXmpSchemaRegistry.ResolveAlias(System.String,System.String)\">\n 53510              <summary>\n 53511:             Determines if a name is an alias, and what it is aliased to.\n 53512              </summary>\n 53513              <param name=\"aliasNs\">\n .....\n 55933                                  -- a brief description or identifier of the encValue content\n 55934                                  -- (may be meaningful only to the sending entity, and used only\n 55935:                                 -- if EncryptedValue might be re-examined by the sending entity\n 55936                                  -- in the future)\n 55937                                  encValue       BIT STRING }\n .....\n 56502          </member>\n 56503          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.ContainsKey(`0)\">\n 56504:             <summary>Determines whether the <see cref=\"T:ReadOnlyDictionary`2\" />\n 56505              contains the specified key.</summary>\n 56506              <returns>\n .....\n 56550          <member name=\"M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})\">\n 56551              <summary>\n 56552:             Determines whether the <see cref=\"T:ICollection`1\"/> contains a\n 56553              specific value.\n 56554              </summary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net35\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net40\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCAD\\Scripts\\src\\SQL2Word\\packages\\CommandLineParser.1.9.71\\lib\\net45\\CommandLine.xml:\n  535          <member name=\"P:CommandLine.Text.HelpText.MaximumDisplayWidth\">\n  536              <summary>\n  537:             Gets or sets the maximum width of the display.  This determines word wrap when displaying the text.\n  538              </summary>\n  539              <value>The maximum width of the display.</value>\n\n124 matches across 15 files\n\n\nSearching 2114 files for \"minE\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  138            }\n  139            minS = -1;\n  140:           minE = -1;          \n  141          }        \n  142  public:\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n6 matches across 3 files\n\n\nSearching 2114 files for \"minS\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd, minS, minE;\n   71  \n   72          float iRowsFullHeight;\n   ..\n  137                 RowslEnd[i] = gFillGapsBegin;\n  138            }\n  139:           minS = -1;\n  140            minE = -1;          \n  141          }        \n\nD:\\_DISTR\\_ASUDOR\\RSign\\GdiEdit.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n14 matches across 4 files\n\n\nSearching 2114 files for \"RowslEnd\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1309    gFillGaps = 0;\n 1310    LeftTop = _LeftTop;\n 1311:   RowslEnd = 0;\n 1312    RowsCount = _RowsCount;\n 1313    FillGaps[-1] = true;\n ....\n 1332     if(iRow==-1){\n 1333       for(int i=0;i<RowsCount;i++){\n 1334:         if(gFillGaps[i]) DrawRepeatEmptyInterval(i,RowslEnd[i],TableWidth,step,true);\n 1335       }\n 1336     }else{\n 1337:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],TableWidth,step,true);\n 1338     }\n 1339  }\n ....\n 1648  \n 1649  \n 1650:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 1651:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 1652     }\n 1653  \n ....\n 1720     }\n 1721  \n 1722:    RowslEnd[iRow] = ePos;\n 1723     delete[] pos;\n 1724  }\n ....\n 1755  \n 1756  \n 1757:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 1758:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 1759     }\n 1760  \n ....\n 1781     }\n 1782  \n 1783:    RowslEnd[iRow] = ePos;\n 1784     delete[] pos;\n 1785  }\n ....\n 1951     }\n 1952  \n 1953:    RowslEnd[iRow] = ePos;\n 1954     delete[] pos;\n 1955  }\n ....\n 2018     }\n 2019  \n 2020:    RowslEnd[iRow] = ePos;\n 2021     delete[] pos;\n 2022  }\n ....\n 2187                              bool fWithBorders ,float kProp)\n 2188  {\n 2189:   if (RowslEnd[row] > offBeg) offBeg = RowslEnd[row];\n 2190    if(offEnd <= offBeg) return;\n 2191  \n ....\n 2255     pos[0] = sPos;\n 2256  \n 2257:    if(gFillGaps[iRow]&&RowslEnd[iRow]<=sPos){\n 2258:      DrawRepeatEmptyInterval(iRow,RowslEnd[iRow],sPos,step,true);\n 2259     }\n 2260     emptyMin[iRow] = max(max(emptyMin[iRow], sPos),ePos);\n ....\n 2286     }\n 2287     delete[] pos;\n 2288:    RowslEnd[iRow] = ePos;\n 2289     \n 2290  #undef DRAWTEXT\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n   68          bool gIsHI,*gFillGaps,gAutoShrink, fFirst;\n   69          AutoCADPoint gLeftTop;\n   70:         float *RowslEnd;\n   71  \n   72          float iRowsFullHeight;\n   ..\n   80  \n   81                  iRowsFullHeight = gRowsCount*gRowHeight;\n   82:                 if(RowslEnd) delete[] RowslEnd;\n   83:                 RowslEnd = new float[value];\n   84                  SetFillGapsBegin(gFillGapsBegin);\n   85                  /*if(gFillGaps)\n   ..\n  126              if(gFillGapsBegin!=value) gFillGapsBegin = value;\n  127              for(int i=0;i<gRowsCount;i++){\n  128:                RowslEnd[i] = value;\n  129                 emptyMin[i] = value;\n  130              }\n  ...\n  135            fFirst = true;\n  136            for(int i=0;i<gRowsCount;i++){\n  137:                RowslEnd[i] = gFillGapsBegin;\n  138            }      \n  139          }        \n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n26 matches across 4 files\n\n\nSearching 2114 files for \"DrawEmpty\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n 1521  }\n 1522  \n 1523: void AutoCADTable::DrawEmpty(int iRow, float offsetBegin, float offsetEnd,\n 1524                               bool fWithBorders, bool fWithoutFill, bool fInc )\n 1525  {\n ....\n 1600     if(iMin!=iMax){\n 1601       if(sPos<iMin*step){\n 1602:          DrawEmpty(iRow,sPos,iMin*step,false,fWithoutFill, fInc);\n 1603           pos[counter++] = iMin*step;\n 1604       }\n 1605       for(int i=iMin;i<iMax-1;i++){\n 1606:          DrawEmpty(iRow,i*step,(i+1)*step,false,fWithoutFill, fInc);\n 1607           pos[counter++] = (i+1)*step;\n 1608       }\n 1609       if(ePos>(iMax-1)*step){\n 1610:         DrawEmpty(iRow,(iMax-1)*step,ePos,false,fWithoutFill, fInc);\n 1611          pos[counter++] = ePos;\n 1612       }\n 1613       if(fWithBorders)DrawSnakeBorder(iRow,pos,counter);\n 1614     }else{\n 1615:      DrawEmpty(iRow, sPos, ePos, false, fWithoutFill, fInc);\n 1616       if(fWithBorders)DrawSnakeBorder(iRow,sPos,ePos);\n 1617     }\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.h:\n  182          void DrawSnakeBorder(int iRow, float sPos, float ePos);\n  183  \n  184:         void DrawEmpty(int Row, float offsetBegin, float offsetEnd,\n  185                          bool fWithBorders, bool fWithoutFill, bool fInc);\n  186  \n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n22 matches across 4 files\n\n\nSearching 2114 files for \"iStep\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  360                                  + \"\\r\\n\" + IntToStr((int)tableBottom.FillGapsBegin)\n  361                                  + \"\\r\\n\" + IntToStr((int)tableBottom.TableWidth)\n  362:                                 + \"\\r\\n\" + IntToStr((int)iStep)\n  363                                  + \"\\r\\n# высота верхней таблицы\"\n  364                                  + \"\\r\\n# высота нижней таблицы\"\n  ...\n  563      tableGraphic.LeftTop = AutoCADPoint(0, -form->RCenter - tableBottom.TableHeight);\n  564  \n  565:     iStep = form->Step;\n  566      return true;\n  567  }\n  ...\n 1313      float posOffset = 0.25 * ScaleY;\n 1314      if (!fUnderRoad && !fDrawMap) {\n 1315:         int framePos = (LPos / 100) % (iStep / 100);\n 1316          if (framePos <= 30 * posOffset) {\n 1317              tyOffset += (rotationHandle == -M_PI / 2) ? 3000 * posOffset : -3000 * posOffset;\n 1318:         } else if ( (iStep / 100) - framePos <= 30 * posOffset ) {\n 1319              tyOffset += (rotationHandle == -M_PI / 2) ? -3000 * posOffset : 3000 * posOffset;\n 1320          }\n ....\n 1524  \n 1525      if (!fDrawMap) {\n 1526:         curStep = lastStep = Poly->Points[0].x / iStep;\n 1527          for (int i = 1; i < Poly->Count; ++i) {\n 1528:             curStep = Poly->Points[i].x / iStep;\n 1529  \n 1530              if (curStep != lastStep) {\n 1531:                 centerPoint = GetCenterOnPolyline(Poly, lastStep * iStep, (lastStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n 1532                  if (centerPoint.x != -1) {\n 1533                      str = text;\n ....\n 1547              }\n 1548          }\n 1549:         centerPoint = GetCenterOnPolyline(Poly, curStep * iStep, (curStep + 1) * iStep, &angle, &width_of_sector, &pStart, &pEnd);\n 1550      } else {\n 1551          centerPoint = GetCenterOnPolyline(Poly, -1, -1, &angle, &width_of_sector, &pStart, &pEnd);\n ....\n 1603                       angle);\n 1604  \n 1605:     if (length >= 15 && start != 0 && start != 1000 && start != iStep / 100) {\n 1606          AutoCAD.DrawText(IntToStr(start),\n 1607                           kPositionMarksHeight * UnderTextHeight * ScaleYBlock / 3.5,\n ....\n 1611                           M_PI_2 + angle);\n 1612      }\n 1613:     /*if (length >= 15 && end != 0 && end != 1000 && start != iStep / 100) {\n 1614          AutoCAD.DrawText(IntToStr(end),\n 1615                           kPositionMarksHeight * UnderTextHeight,\n ....\n 1662              // fill rows in tables\n 1663              if (table && line != 0) { // if we draw lines over central\n 1664:                 table->DrawRepeatTextIntervalRoadMark(iRow, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1665              } else { // if we draw central line\n 1666:                 tableTop.DrawRepeatTextIntervalRoadMark(iTop0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1667:                 tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0, name, Min, Max, Helpers::StringConvert, iStep, 0.25);\n 1668              }\n 1669              if ( line >= 0 ) {\n ....\n 1768      try {\n 1769          if (fEnd) {\n 1770:             if (iTop0 != -1)tableTop.FillLastGaps(iStep, iTop0);\n 1771:             if (iBottom0 != -1)tableBottom.FillLastGaps(iStep, iBottom0);\n 1772              for (i = 0; i < iTopAxeCount; i++) {\n 1773:                 tableTop.FillLastGaps(iStep, iTopAxe - i);\n 1774              }\n 1775              for (i = 0; i < iBottomAxeCount; i++) {\n 1776:                 tableBottom.FillLastGaps(iStep, iBottomAxe + i);\n 1777              }\n 1778              return true;\n ....\n 1855  \n 1856                  if(table&&line){\n 1857:                     table->DrawRepeatTextIntervalRoadMark(iRow,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1858                  }else{\n 1859:                     tableTop.DrawRepeatTextIntervalRoadMark(iTop0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1860:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottom0,\"1.4\",Min,Max,StringConvert,iStep,0.25);\n 1861                  } */\n 1862  \n ....\n 2311      if (fEnd) {\n 2312          if (!fDrawMap) {\n 2313:             if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n 2314:             if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n 2315          }\n 2316          return true;\n ....\n 2475          lastStep = -9999;\n 2476          for (int i = 0; i < points.size(); i++) {\n 2477:             int step = points[i].x / iStep;\n 2478              if (step != lastStep\n 2479                      || (i == points.size() - 1 && abs(points.front().x - points.back().x) > 10000)) {\n ....\n 2547              if (block.IsBound()) lBlockLeft = block;\n 2548              lPropLeft = curProp;\n 2549:             tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2550              break;\n 2551          case opRight:\n 2552              if (block.IsBound()) lBlockRight = block;\n 2553              lPropRight = curProp;\n 2554:             tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2555              break;\n 2556          }\n ....\n 2566      if (fEnd) {\n 2567          if (!fDrawMap) {\n 2568:             if (~iTopBarriers)tableTop.FillLastGaps(iStep, iTopBarriers);\n 2569:             if (~iBottomBarriers)tableBottom.FillLastGaps(iStep, iBottomBarriers);\n 2570          }\n 2571          return true;\n ....\n 2589                  switch (s->Placement) {\n 2590                  case opLeft:\n 2591:                     tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n 2592                      break;\n 2593                  case opRight:\n 2594:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"1\", s->LMin, s->LMin + 100, Helpers::StringConvert, iStep, true, 0.43);\n 2595                      break;\n 2596                  }\n ....\n 2648                  switch (s->Placement) {\n 2649                  case opLeft:\n 2650:                     tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n 2651                      break;\n 2652                  case opRight:\n 2653:                     tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, \"\", s->LMin, s->LMax, Helpers::StringConvertSignals, iStep, true, 0.43);\n 2654                      break;\n 2655                  }\n ....\n 2695                          tableTop.DrawLine(iTopMoundH, lLeftL, 0.5, m->L, 0.5);\n 2696                      }\n 2697:                     tableTop.DrawRepeatTextIntervalMoundHeight(iTopMoundH, lLeftL, m->L, lLeftHeight, m->Height, iStep);\n 2698                  }\n 2699              }\n ....\n 2714                          tableBottom.DrawLine(iBottomMoundH, lRightL, 0.5, m->L, 0.5);\n 2715                      }\n 2716:                     tableBottom.DrawRepeatTextIntervalMoundHeight(iBottomMoundH, lRightL, m->L, lRightHeight, m->Height, iStep);\n 2717                  }\n 2718              }\n ....\n 2773                  }\n 2774              }\n 2775:             tableTop.DrawRepeatTextIntervalRoadMark(iTopCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n 2776:             tableBottom.DrawRepeatTextIntervalRoadMark(iBottomCurves, \"R=\" + IntToStr((int)c->Radius), c->LMin, c->LMax, 0, iStep, false, 0.33);\n 2777              break;\n 2778  \n ....\n 2789                      }\n 2790                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2791:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2792                  }\n 2793                  if (iBottomCurves >= 0) {\n ....\n 2801                      }\n 2802                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2803:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2804                  }\n 2805              } else if (lKind == ckCircle) {\n ....\n 2814                      }\n 2815                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2816:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2817                  }\n 2818                  if (iBottomCurves >= 0) {\n ....\n 2826                      }\n 2827                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2828:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2829                  }\n 2830              }\n ....\n 2845                      }\n 2846                      tableTop.DrawLine(iTopCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2847:                     tableTop.DrawVerticalText(c->LMin % iStep / 100, iTopCurves, c->LMin, 0.75, true, 0.15);\n 2848                  }\n 2849                  if (iBottomCurves >= 0) {\n ....\n 2857                      }\n 2858                      tableBottom.DrawLine(iBottomCurves, c->LMin, 0.25, c->LMin, 0.75);\n 2859:                     tableBottom.DrawVerticalText(c->LMin % iStep / 100, iBottomCurves, c->LMin, 0.75, true, 0.15);\n 2860                  }\n 2861              } else if (lKind == ckCircle) {\n ....\n 2870                      }\n 2871                      tableTop.DrawLine(iTopCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2872:                     tableTop.DrawVerticalText(c->LMax % iStep / 100, iTopCurves, c->LMax, 0.75, false, 0.15);\n 2873                  }\n 2874                  if (iBottomCurves >= 0) {\n ....\n 2882                      }\n 2883                      tableBottom.DrawLine(iBottomCurves, c->LMax, 0.25, c->LMax, 0.75);\n 2884:                     tableBottom.DrawVerticalText(c->LMax % iStep / 100, iBottomCurves, c->LMax, 0.75, false, 0.15);\n 2885                  }\n 2886              }\n ....\n 2922      if (s->Promille > 0) {\n 2923          if (iTopSlopes >= 0) {\n 2924:             tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2925:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2926          }\n 2927          if (iBottomSlopes >= 0) {\n 2928:             tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, true);\n 2929:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.33, iStep, false, 0.15);\n 2930          }\n 2931:         if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n 2932:         if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, false, iStep);\n 2933      } else if (s->Promille < 0) {\n 2934          if (iTopSlopes >= 0) {\n 2935:             tableTop.DrawRepeatEmptyInterval(iTopSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2936:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2937          }\n 2938          if (iBottomSlopes >= 0) {\n 2939:             tableBottom.DrawRepeatEmptyInterval(iBottomSlopes, s->LMin, s->LMax, iStep, true, true, false);\n 2940:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2941          }\n 2942:         if (iTopSlopes >= 0)tableTop.DrawRepeatTextIntervalSpec2(iTopSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n 2943:         if (iBottomSlopes >= 0)tableBottom.DrawRepeatTextIntervalSpec2(iBottomSlopes, \"l=\" + IntToStr(abs(s->Promille)) + \"‰\", s->LMin, s->LMax, true, iStep);\n 2944      } else {\n 2945          if (iTopSlopes >= 0) {\n 2946              tableTop.DrawLine(iTopSlopes, s->LMin, tableTop.kBottomEmptyPadding, s->LMax, tableTop.kBottomEmptyPadding);\n 2947:             tableTop.DrawRepeatVerticalTextInterval(iTopSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2948          }\n 2949          if (iBottomSlopes >= 0) {\n 2950              tableBottom.DrawLine(iBottomSlopes, s->LMin, tableBottom.kBottomEmptyPadding, s->LMax, tableBottom.kBottomEmptyPadding);\n 2951:             tableBottom.DrawRepeatVerticalTextInterval(iBottomSlopes, s->LMin, s->LMax, 0.66, iStep, false, 0.15);\n 2952          }\n 2953      }\n ....\n 2985      if (fEnd) {\n 2986          if (!fDrawMap) {\n 2987:             if (~iTopSidewalks)tableTop.FillLastGaps(iStep, iTopSidewalks);\n 2988:             if (~iBottomSidewalks)tableBottom.FillLastGaps(iStep, iBottomSidewalks);\n 2989          }\n 2990          return true;\n ....\n 3017              case spLeft:\n 3018                  tableTop.DrawRepeatTextIntervalRoadMark(iTopSidewalks, str,\n 3019:                                                         sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n 3020                  break;\n 3021              case spRight:\n 3022                  tableBottom.DrawRepeatTextIntervalRoadMark(iBottomSidewalks, str,\n 3023:                         sidewalksGroup->min(), sidewalksGroup->max(), Helpers::StringConvert, iStep, true, 0.43);\n 3024                  break;\n 3025              }\n ....\n 3208          delete paramsValues;\n 3209      } else { // просто текст\n 3210:         table->DrawRepeatTextIntervalRoadMark(iRow, str, iPos, iEnd, 0, iStep, true);\n 3211      }\n 3212  }\n ....\n 3327  \n 3328                          ExportAddRowLine(table, startCount + iRow - 1, sPos, ePos, line.Trim());\n 3329:                         //table->DrawRepeatTextIntervalSpec(startCount+iRow-1, AnsiString(s.c_str()).Trim(), sPos, ePos,0,iStep,true);\n 3330                      } catch (...) {\n 3331                          OutInfoLog(\"Ошибка вывода: \" + str2 + \" - \" + line);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n   71  \n   72  \n   73:       int iStep;   //шаг в сантиметрах   \n   74  \n   75        AutoCADTable tableTop,tableBottom, tableGraphic;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n70 matches across 4 files\n\n\nSearching 2114 files for \"GetAngle2\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  818                           pMin.x + (pMax.x - pMin.x) / 2,\n  819                           -ScaleY * (pMin.y + (pMax.y - pMin.y) / 2),\n  820:                          Helpers::GetAngle2(pMin, pMax, ScaleY)\n  821                          );\n  822      }\n  ...\n 1840  \n 1841              case ma3: /*двойная сплошная*/\n 1842:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n 1843                  DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n 1844                  for (int i = 0; i < count - 1; i++) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.cpp:\n   23  }\n   24  \n   25: float Helpers::GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length) {\n   26  \n   27      float yoffset = -ScaleY * (p2.y - p1.y);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.h:\n   11  public:\n   12      static float GetAngle(TPoint vec1, TPoint vec2);\n   13:     static float GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length=NULL);\n   14      static float GetLength(TPoint p1, TPoint p2, float ScaleY);\n   15      static bool compareSigns(const TRoadSign* s1, const TRoadSign* s2);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n11 matches across 4 files\n\n\nSearching 2114 files for \"GetAngle2\" (case sensitive)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  818                           pMin.x + (pMax.x - pMin.x) / 2,\n  819                           -ScaleY * (pMin.y + (pMax.y - pMin.y) / 2),\n  820:                          Helpers::GetAngle2(pMin, pMax, ScaleY)\n  821                          );\n  822      }\n  ...\n 1840  \n 1841              case ma3: /*двойная сплошная*/\n 1842:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n 1843                  DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n 1844                  for (int i = 0; i < count - 1; i++) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.cpp:\n   24  }\n   25  \n   26: float Helpers::GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length) {\n   27      /* Возвращает угол между вектором образованым точками p1 и p2 и осью X\n   28       * Если указан параметр length в него попадет длина вектора\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Helpers.h:\n   11  public:\n   12      static float GetAngle(TPoint vec1, TPoint vec2);\n   13:     static float GetAngle2(TPoint &p1, TPoint &p2, float ScaleY, float *length=NULL);\n   14      static float GetLength(TPoint p1, TPoint p2, float ScaleY);\n   15      static bool compareSigns(const TRoadSign* s1, const TRoadSign* s2);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n11 matches across 4 files\n\n\nSearching 2114 files for \"DrawTextOverPoly\" (case sensitive, whole word)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n 1491  }\n 1492  \n 1493: void __fastcall TAcadExport::DrawTextOverPoly(TExtPolyline *Poly, AnsiString text,\n 1494          AnsiString(__closure *textControlFunction)(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data), void* data)\n 1495  {\n ....\n 1660                  kUnderTextHeight = 0.6 * ScaleY / 3.5;\n 1661              }\n 1662:             DrawTextOverPoly(Poly, label_under_mark, RoadMarkTextDraw, m);\n 1663  \n 1664          } else { // if we draw road mark on attachments\n ....\n 1680                  Max += 0.5 * UnderTextYOffset;\n 1681              }\n 1682:             DrawTextOverPoly(Poly, name, RoadMarkTextDraw, m);\n 1683          }\n 1684          if (Max - Min >= 1000) {\n ....\n 1850                  }\n 1851  \n 1852:                 //DrawTextOverPoly(Poly, \"1.4\", RoadMarkTextDraw);\n 1853                  break;\n 1854  \n ....\n 1917                      }\n 1918                  }\n 1919:                 DrawTextOverPoly(Poly, \"1.11\", RoadMarkTextDraw);\n 1920                  break;\n 1921  \n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.h:\n  189        void __fastcall DrawTextUnderLine(TPoint p1, TPoint p2, AnsiString text);\n  190  \n  191:       void __fastcall DrawTextOverPoly(TExtPolyline *Poly, AnsiString text,\n  192                AnsiString(__closure *textControlFunction)(AnsiString text, TPoint pStart, TPoint pEnd, TPoint centerPoint, float angle, void* data)=0,\n  193                void* data=0);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\n15 matches across 3 files\n\n\nSearching 2114 files for \"Poly->Points\" (case sensitive, whole word)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\acadexport.cpp:\n  117  \n  118      for (int i = 0; i < Poly->Count; ++i) {\n  119:         points.push_back(Poly->Points[i].x);\n  120:         points.push_back(-ScaleY * Poly->Points[i].y);\n  121          codes.push_back(Poly->Codes[i].Visible());\n  122      }\n  ...\n  163      } else {\n  164          if (fLockGaps && Poly->Count > 2) {\n  165:             points.push_back(Poly->Points[0].x);\n  166:             points.push_back(-ScaleY * Poly->Points[0].y);\n  167          }\n  168          pl = DrawPolyLine(points);\n  ...\n  657      int step = 50;\n  658      for (i = 0; i < count; i += step) {\n  659:         points[2 * i] = Poly->Points[i].x;\n  660:         points[2 * i + 1] = Poly->Points[i].y + tableTop.LeftTop.y - tableTop.RowOffsetY(iProfileTop); // - tableTop.RowHeight;\n  661          pts.push_back(TPoint(points[2 * i], points[2 * i + 1]));\n  662      }\n  663  \n  664:     points[2 * count] = Poly->Points[0].x;\n  665:     points[2 * count + 1] = Poly->Points[0].y;\n  666  \n  667      float angle;\n  ...\n  700      //if (kind==mkBrovka)\n  701      //   Poly->Count\n  702:     //   Poly->Points[i].X -- координата по ширине\n  703:     //   Poly->Points[i].L -- координата по длине\n  704      //   Poly->Codes[i]&1  Код видимости до i-той точки 1 - видимый, 0 - невидимый\n  705      //   Координаты целые в сантиметрах!\n  ...\n  744  \n  745      // ищем минимальную и максимальную точку по Y у примыкания\n  746:     int maxY = abs(Poly->Points[0].y);\n  747:     int minY = abs(Poly->Points[0].y);\n  748      int iLast, i;\n  749:     TPoint pMax = Poly->Points[0], pMin = Poly->Points[0];\n  750      for (i = 1; i < Poly->Count; ++i) {\n  751:         if (abs(Poly->Points[i].y) > maxY ) {\n  752:             maxY = abs(Poly->Points[i].y);\n  753:             pMax = Poly->Points[i];\n  754          }\n  755:         if (abs(Poly->Points[i].y) < minY ) {\n  756:             minY = abs(Poly->Points[i].y);\n  757:             pMin = Poly->Points[i];\n  758          }\n  759      }\n  ...\n  814  \n  815      if (~iStart) {\n  816:         if (Poly->Points[0].x < iStart) return true;\n  817      }\n  818      if (~iEnd) {\n  819:         if (Poly->Points[0].x > iEnd) return true;\n  820      }\n  821      if (count == 0) {\n  ...\n 1032                  break;\n 1033              default:\n 1034:                 BUILDER_ERROR(\"Не могу определить угол поворота знака \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x);\n 1035              }\n 1036              break;\n ....\n 1079                  break;\n 1080              default:\n 1081:                 BUILDER_ERROR(\"Не могу определить угол поворота знака \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x);\n 1082              }\n 1083              break;\n ....\n 1110      if (fDrawMap) {\n 1111          if (Poly->Count == 2) {\n 1112:             double angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n 1113  \n 1114              rotationHandle += angle;\n ....\n 1165                      signs[0]->OldTitle + (signs[0]->ViewKind == 0 ? sEmpty : AnsiString(\".\" + IntToStr(signs[0]->ViewKind))),\n 1166                      signs[0]->Label,\n 1167:                     AutoCADPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y),\n 1168                      signs[0]->L,\n 1169                      signSpotOffset,\n ....\n 1189                  DrawSign(block->Name,\n 1190                           \"\",\n 1191:                          AutoCADPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y),\n 1192                           signs[0]->L,\n 1193                           signSpotOffset,\n ....\n 1202          }\n 1203      } catch (...) {\n 1204:         BUILDER_ERROR(\"Ошибка вывода знака: \" << signs[0]->OldTitle.c_str() << \" на позиции \" << Poly->Points[0].x );\n 1205          return false;\n 1206      }\n ....\n 1504  \n 1505      if (!fDrawMap) {\n 1506:         curStep = lastStep = Poly->Points[0].x / iStep;\n 1507          std::vector<int> points_indexs;\n 1508          // формируем разбиение полилинии\n 1509          // for (int i = 0; i < Poly->Count; ++i) {\n 1510:         //     curStep = Poly->Points[i].x / iStep;\n 1511          //     if (i == 0 || i == Poly->Count - 1 || curStep != lastStep) {\n 1512          //         points_indexs.push_back(i);\n ....\n 1516          // проходим по всем выделеным отрезкам полилинии\n 1517          // for (int i = 1; i < points_indexs.size(); ++i) {\n 1518:         int xLeft = Poly->Points[0].x;\n 1519:         int xRight = Poly->Points[Poly->Points->Count-1].x;\n 1520          if (xLeft > xRight) {\n 1521              Helpers::swap(xLeft, xRight);\n ....\n 1658          }\n 1659  \n 1660:         if (Poly->Points[0].x > Poly->Points[count - 1].x) {\n 1661:             Min = Poly->Points[count - 1].x;\n 1662:             Max = Poly->Points[0].x;\n 1663          } else {\n 1664:             Max = Poly->Points[count - 1].x;\n 1665:             Min = Poly->Points[0].x;\n 1666          }\n 1667:         if (abs(Poly->Points[0].y) > abs(Poly->Points[count - 1].y)) {\n 1668              iMaxY = 0;\n 1669          } else {\n ....\n 1681              }\n 1682              if ( line >= 0 ) {\n 1683:                 yOffset = -ScaleY * (Poly->Points[(Poly->Count) / 2 - (Poly->Count % 2 ? 0 : 1)].y) + UnderTextYOffset;\n 1684              } else {\n 1685:                 yOffset = -ScaleY * (Poly->Points[(Poly->Count) / 2 - (Poly->Count % 2 ? 0 : 1)].y) - UnderTextYOffset;\n 1686              }\n 1687  \n ....\n 1698              // we should recalculate angle of text, to draw it properly\n 1699              if (iMaxY > 0) {\n 1700:                 angle = Helpers::GetAngle2(Poly->Points[iMaxY], Poly->Points[iMaxY - 1], ScaleY);\n 1701:                 Max = Poly->Points[iMaxY].x + (Poly->Points[iMaxY - 1].x - Poly->Points[iMaxY].x) / 2;\n 1702:                 MaxY = Poly->Points[iMaxY].y + (Poly->Points[iMaxY - 1].y - Poly->Points[iMaxY].y) / 2;\n 1703              } else {\n 1704:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n 1705:                 Max = Poly->Points[0].x + (Poly->Points[1].x - Poly->Points[0].x) / 2;\n 1706:                 MaxY = Poly->Points[0].y + (Poly->Points[1].y - Poly->Points[0].y) / 2;\n 1707              }\n 1708  \n 1709:             if (Poly->Points[iMaxY].y > 0) {\n 1710                  Max -= 0.5 * UnderTextYOffset;\n 1711              } else {\n ....\n 1715          }\n 1716          if (Max - Min >= 1000) {\n 1717:             AcadLinePtr line = AutoCAD.DrawLine(Poly->Points[0].x, -ScaleY * (Poly->Points[0].y) - UnderTextYOffset * kEdgeLines,\n 1718:                                                 Poly->Points[0].x, -ScaleY * (Poly->Points[0].y) + UnderTextYOffset * kEdgeLines);\n 1719:             line->Rotate(AutoCAD.cadPoint(Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0),\n 1720:                          Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY));\n 1721  \n 1722:             line = AutoCAD.DrawLine(Poly->Points[Poly->Count - 1].x, -ScaleY * (Poly->Points[Poly->Count - 1].y) - UnderTextYOffset * kEdgeLines,\n 1723:                                     Poly->Points[Poly->Count - 1].x, -ScaleY * (Poly->Points[Poly->Count - 1].y) + UnderTextYOffset * kEdgeLines);\n 1724:             line->Rotate(AutoCAD.cadPoint(Poly->Points[Poly->Count - 1].x, -ScaleY * Poly->Points[Poly->Count - 1].y, 0),\n 1725:                          Helpers::GetAngle2(Poly->Points[Poly->Count - 2], Poly->Points[Poly->Count - 1], ScaleY));\n 1726          }\n 1727      }\n ....\n 1816          if (count > 1) {\n 1817  \n 1818:             if (Poly->Points[0].x > Poly->Points[count - 1].x) {\n 1819:                 Min = Poly->Points[count - 1].x;\n 1820:                 Max = Poly->Points[0].x;\n 1821              } else {\n 1822:                 Max = Poly->Points[count - 1].x;\n 1823:                 Min = Poly->Points[0].x;\n 1824              }\n 1825  \n ....\n 1837              case ma1_park: /*сплошная на парковке*/\n 1838                  for (int i = 0; i < count - 1; i++) {\n 1839:                     DrawBlockOnLine(\"r_1.1_park\", Poly->Points[i + 1], Poly->Points[i], \"Length\", ScaleYBlock / 4);\n 1840                  }\n 1841                  break;\n ....\n 1853  \n 1854              case ma3: /*двойная сплошная*/\n 1855:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY, &length);\n 1856                  DrawRoadMark(m, Poly, \"1.3\", iRow, line, table, true);\n 1857                  for (int i = 0; i < count - 1; i++) {\n 1858:                     DrawBlockOnLine(\"r_1.3\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n 1859                  }\n 1860                  break;\n ....\n 1936              case ma11r:  /*Движение с одной стороны (прерывистая справа)*/\n 1937                  for (int i = 0; i < count - 1; i++) {\n 1938:                     block = DrawBlockOnLine(\"r_1.11\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n 1939:                     int px =  Poly->Points[i + 1].x - Poly->Points[i].x;\n 1940:                     int py =  Poly->Points[i + 1].y - Poly->Points[i].y;\n 1941                      length = sqrt(px * px + py * py * ScaleY * ScaleY);\n 1942                      if (block.IsBound() ) {\n ....\n 1954              case ma12:  /*Стоп линия*/\n 1955                  /*for(int i=0;i<count-1;i++){\n 1956:                     DrawBlockOnLine(\"r_1.12\", Poly->Points[i], Poly->Points[i+1], \"Length\");\n 1957                  } */\n 1958                  pl1 = DrawRoadMark(m, Poly, \"1.12\", iRow, line, table);\n ....\n 1964              case ma13: /*Обозначение места, где водитель обязан уступить дорогу*/\n 1965                  for (int i = 0; i < count - 1; i++) {\n 1966:                     DrawBlockOnLine(\"r_1.13\", Poly->Points[i], Poly->Points[i + 1], \"Length\");\n 1967                  }\n 1968                  break;\n ....\n 1972              case ma14_3:\n 1973                  for (int i = 0; i < count - 1; i++) {\n 1974:                     DrawBlockOnLine(\"r_1.14.1\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n 1975                  }\n 1976                  break;\n 1977              case ma14_1e:\n 1978                  for (int i = 0; i < count - 1; i++) {\n 1979:                     DrawBlockOnLine(\"r_1.14.1_e\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n 1980                  }\n 1981                  break;\n 1982              case ma14_2e:\n 1983                  for (int i = 0; i < count - 1; i++) {\n 1984:                     DrawBlockOnLine(\"r_1.14.2_e\", Poly->Points[i], Poly->Points[i + 1], \"Width\", ScaleYBlock / 4);\n 1985                  }\n 1986                  break;\n ....\n 1988              case ma15: /*Обозначение переезда для велосипедистов*/\n 1989                  BUILDER_ERROR(\"Разметка 1.15 не реализована\");\n 1990:                 //tableBottom.DrawRepeatTextInterval(0,\"1.15\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 1991                  break;\n 1992  \n ....\n 2003                  p.x = 0;\n 2004                  for (i = 0; i < Poly->Count; i++) {\n 2005:                     p.x += Poly->Points[i].x;\n 2006:                     p.y += Poly->Points[i].y;\n 2007                  }\n 2008  \n ....\n 2022                  }\n 2023  \n 2024:                 //tableBottom.DrawRepeatTextInterval(0,\"1.16\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2025                  break;\n 2026  \n ....\n 2028              {\n 2029                  float scale = ScaleYBlock / 4;\n 2030:                 block = DrawBlockOnLine(\"r_1.17\", Poly->Points[0], Poly->Points[count - 1], \"Length Length2\", scale);\n 2031  \n 2032                  // чтобы выводить разметку так чтобы правая ножка не отрывалась от общего контура\n 2033                  // в случае изменения размеров блока разметки, надо поменять значение 582 на значение шага повторения\n 2034                  float blockDefaultLength = 582 * scale;\n 2035:                 float length = Helpers::GetLength(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2036                  int realLength = ((int)length / (int)blockDefaultLength) * blockDefaultLength;\n 2037                  AutoCAD.SetPropertyDouble(block, \"Length\",  realLength);\n ....\n 2039  \n 2040              }\n 2041:                 //tableBottom.DrawRepeatTextInterval(0,\"1.17\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2042              break;\n 2043  \n 2044              case ma18l: /*Направление движения(налево)*/\n 2045:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2046:                 block = AutoCAD.DrawBlock(\"r_1.18_3\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2047                  AutoCAD.SetPropertyList(block, \"Flip\", 1);\n 2048                  break;\n 2049              case ma18p: /*Направление движения(прямо)*/\n 2050:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2051:                 block = AutoCAD.DrawBlock(\"r_1.18_1\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2052                  break;\n 2053              case ma18pl: /*Направление движения(прямо,налево)*/\n 2054:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2055:                 block = AutoCAD.DrawBlock(\"r_1.18_2\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2056                  AutoCAD.SetPropertyList(block, \"Flip\", 1);\n 2057                  break;\n 2058              case ma18pr: /*Направление движения(прямо,направо)*/\n 2059:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2060:                 block = AutoCAD.DrawBlock(\"r_1.18_2\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2061                  break;\n 2062              case ma18prl: /*Направление движения(прямо,направо,налево)*/\n ....\n 2065  \n 2066              case ma18r: /*Направление движения(направо)*/\n 2067:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2068:                 block = AutoCAD.DrawBlock(\"r_1.18_3\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2069                  break;\n 2070              case ma18rl: /*Направление движения(направо,налево)*/\n 2071                  BUILDER_ERROR(\"Разметка 1.8rl не реализована\");\n 2072:                 //tableBottom.DrawRepeatTextInterval(0,\"1.18\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2073                  break;\n 2074  \n 2075              case ma19_1:  /*Направление перестроения(направо)*/\n 2076:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2077:                 block = AutoCAD.DrawBlock(\"r_1.19\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2078                  break;\n 2079              case ma19_2:  /*Направление перестроения(налево)*/\n 2080:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2081:                 block = AutoCAD.DrawBlock(\"r_1.19\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2082                  AutoCAD.SetPropertyList(block, \"Flip\", 1);\n 2083:                 //tableBottom.DrawRepeatTextInterval(0,\"1.19\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2084                  break;\n 2085  \n 2086              case ma20: /*Приближение к поперечной линии 1.13*/\n 2087:                 angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[count - 1], ScaleY);\n 2088:                 block = AutoCAD.DrawBlock(\"r_1.20\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 4);\n 2089                  break;\n 2090  \n 2091              case ma21: /*Приближение к поперечной линии 1.12*/\n 2092:                 //tableBottom.DrawRepeatTextInterval(0,\"1.21\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2093                  BUILDER_ERROR(\"Разметка 1.21 не реализована\");\n 2094                  break;\n ....\n 2096              case ma22:  /*Обозначение номера дороги*/\n 2097                  BUILDER_ERROR(\"Разметка 1.22 не реализована\");\n 2098:                 //tableBottom.DrawRepeatTextInterval(0,\"1.22\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2099                  break;\n 2100  \n 2101              case ma23:  /*Обозначение полосы движения только для маршрутных транспортных средств*/\n 2102                  block = AutoCAD.DrawBlock(\"r_1.23\",\n 2103:                                           Poly->Points[0].x,\n 2104:                                           -ScaleY * Poly->Points[0].y,\n 2105                                            m->Direction == roDirect ? 0 : M_PI,\n 2106                                            ScaleYBlock / 4);\n 2107:                 //tableBottom.DrawRepeatTextInterval(0,\"1.23\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2108                  break;\n 2109  \n ....\n 2111              case ma24_2: /*Дублирование запрещающих дорожных знаков*/\n 2112              case ma24_3: /*Дублирование дорожного знака Инвалиды*/\n 2113:                 BUILDER_ERROR(\"Разметка 1.24 на позиции \" << Poly->Points[0].x << \" не реализована\");\n 2114:                 //tableBottom.DrawRepeatTextInterval(0,\"1.24\",Poly->Points[0].x,Poly->Points[count-1].x,StringConvert,100000,0.25);\n 2115                  break;\n 2116              case ma24_4: /*Дублирование дорожного знака Инвалиды*/\n 2117:                 block = AutoCAD.DrawBlock(\"r_1.24_4\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y,\n 2118                                            m->Direction == roDirect ? 0 : M_PI);\n 2119                  break;\n 2120              case ma25:  /*Обозначение искусственных неровностей*/\n 2121:                 x = Poly->Points[0].x;\n 2122:                 y = Poly->Points[0].y;\n 2123:                 height = ScaleY * (Poly->Points[count - 1].y - y);\n 2124                  if (height < 0) {\n 2125                      rot = M_PI / 2;\n ....\n 2136          }\n 2137      } catch (...) {\n 2138:         BUILDER_ERROR( (\"Ошибка вывода разметки \" + IntToStr((int)m->Kind) + \" на позиции \" + IntToStr(Poly->Points[0].x)).c_str() );\n 2139          return false;\n 2140      }\n ....\n 2152      }\n 2153  \n 2154:     if (Poly->Points[0].y > Poly->Points[1].y) {\n 2155:         pE = Poly->Points[1];\n 2156:         pS = Poly->Points[0];\n 2157      } else {\n 2158:         pE = Poly->Points[0];\n 2159:         pS = Poly->Points[1];\n 2160      }\n 2161  \n 2162:     if (Poly->Points[0].x < Poly->Points[1].x) {\n 2163:         min = Poly->Points[0].x;\n 2164:         max = Poly->Points[1].x;\n 2165      } else {\n 2166:         min = Poly->Points[1].x;\n 2167:         max = Poly->Points[0].x;\n 2168      }\n 2169  \n ....\n 2199          return true;\n 2200      }\n 2201:     yMin = Poly->Points[0].y;\n 2202:     yMax = Poly->Points[2].y;\n 2203:     xMin = Poly->Points[0].x;\n 2204:     xMax = Poly->Points[2].x;\n 2205      width = yMax - yMin;\n 2206      if (width < 0) width = - width;\n ....\n 2332      dir = b->Placement == opLeft ? 1 : -1;\n 2333  \n 2334:     lPointBarrier.x = Poly->Points[Poly->Count - 1].x;\n 2335  \n 2336      vector<TPoint> points;\n 2337      for (int i = 0; i < Poly->Count; i++) {\n 2338:         points.push_back(Poly->Points[i]);\n 2339      }\n 2340      if (iMinBarrierSegmentLength != -1)\n ....\n 2560              if (block.IsBound()) lBlockLeft = block;\n 2561              lPropLeft = curProp;\n 2562:             tableTop.DrawRepeatTextIntervalRoadMark(iTopBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2563              break;\n 2564          case opRight:\n 2565              if (block.IsBound()) lBlockRight = block;\n 2566              lPropRight = curProp;\n 2567:             tableBottom.DrawRepeatTextIntervalRoadMark(iBottomBarriers, str, Poly->Points[0].x, lPointBarrier.x, Helpers::StringConvert, iStep, true, 0.43);\n 2568              break;\n 2569          }\n ....\n 2609                  }\n 2610              }\n 2611:             block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0, scale);\n 2612              if (!exist) block->color = NotExistColor;\n 2613          } else if (s->Count > 1 && count > 1) {\n ....\n 2621              length[0] = 0;\n 2622              for (i = 0; i < count - 1; i++) {\n 2623:                 tx = Poly->Points[i + 1].x - Poly->Points[i].x;\n 2624:                 ty = Poly->Points[i + 1].y - Poly->Points[i].y;\n 2625                  length[iCur++] = length[iCur - 1] + sqrt(tx * tx + ty * ty);\n 2626                  if (!Poly->Codes[i].Visible()) {\n ....\n 2646  \n 2647                  k = 1 - (length[iCur] - curL) / (length[iCur] - length[iCur - 1]);\n 2648:                 tx = Poly->Points[iCur].x - Poly->Points[iCur - 1].x;\n 2649:                 ty = -ScaleY * (Poly->Points[iCur].y - Poly->Points[iCur - 1].y);\n 2650:                 signalsPos[signalsPosCount] = Poly->Points[iCur - 1].x + k * tx;\n 2651:                 block = AutoCAD.DrawBlock(\"signalpost\", signalsPos[signalsPosCount], -ScaleY * Poly->Points[iCur - 1].y + k * ty, 0, scale);\n 2652                  if (!exist) block->color = NotExistColor;\n 2653                  signalsPosCount++;\n ....\n 2669              }\n 2670  \n 2671:             block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, 0, scale);\n 2672              if (!exist) block->color = NotExistColor;\n 2673:             block = AutoCAD.DrawBlock(\"signalpost\", Poly->Points[count - 1].x, -ScaleY * Poly->Points[count - 1].y, 0, scale);\n 2674              if (!exist) block->color = NotExistColor;\n 2675              delete[] length;\n ....\n 2975  \n 2976      if (~iStart) {\n 2977:         if (Poly->Points[0].x < iStart) return true;\n 2978      }\n 2979      if (~iEnd) {\n 2980:         if (Poly->Points[0].x > iEnd) return true;\n 2981      }\n 2982  \n 2983      rotation = s->GetPlacement() == spLeft ? M_PI : 0;\n 2984:     AutoCAD.DrawBlock(\"busstop\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, rotation, ScaleY / 2);\n 2985      return true;\n 2986  }\n ....\n 3114  \n 3115      if (~iStart) {\n 3116:         if (Poly->Points[0].x < iStart) return true;\n 3117      }\n 3118      if (~iEnd) {\n 3119:         if (Poly->Points[0].x > iEnd) return true;\n 3120      }\n 3121  \n ....\n 3124      double angle;\n 3125      if (Poly->Count == 2) {\n 3126:         angle = Helpers::GetAngle2(Poly->Points[0], Poly->Points[1], ScaleY);\n 3127      } else {\n 3128          if (s->Placement == rsRight) {\n ....\n 3133      }\n 3134  \n 3135:     block = AutoCAD.DrawBlock(\"lamp\", Poly->Points[0].x, -ScaleY * Poly->Points[0].y, angle, ScaleYBlock / 2);\n 3136      if (block.IsBound()) {\n 3137          switch (s->Kind) {\n\nD:\\_DISTR\\_ASUDOR\\RSign\\DataSour.cpp:\n  625                  for (int i=0;i<mark->Poly->Count;i++)\n  626                      {\n  627:                     int absA=abs(mark->Poly->Points[i].X);\n  628                      if (absA>maxA)\n  629                          {\n  630                          maxA=absA;\n  631:                         if (mark->Poly->Points[i].X>0)\n  632                              signA=1;\n  633                          else\n  634                              signA=-1;\n  635:                         posL=mark->Poly->Points[i].L;\n  636                          }\n  637                      }\n  ...\n  648                      for (int i=1;i<mark->Poly->Count;i++)\n  649                          {\n  650:                         double dl=mark->Poly->Points[i].L-mark->Poly->Points[i-1].L;\n  651:                         double dx=mark->Poly->Points[i].X-mark->Poly->Points[i-1].X;\n  652                          len+=sqrt(dl*dl+dx*dx);\n  653                          }\n  ...\n  658                      long long s=0;\n  659                      for (int i=2;i<mark->Poly->Count;i++) {\n  660:                        long long dl1=mark->Poly->Points[i-1].L-mark->Poly->Points[0].L;\n  661:                        long long dx1=mark->Poly->Points[i-1].X-mark->Poly->Points[0].X;\n  662:                        long long dl2=mark->Poly->Points[i].L-mark->Poly->Points[0].L;\n  663:                        long long dx2=mark->Poly->Points[i].X-mark->Poly->Points[0].X;\n  664                         s+=dl1*dx2-dl2*dx1;\n  665                      }\n  ...\n  898                       int sind=1,eind=a->Poly->Count;\n  899                       // В начале проверим конечные точки примыкания\n  900:                      if (t->Poly->LenTo(a->Poly->Points[0],p1,h)<2.0)\n  901                          n1=h+1,sind++;\n  902:                      if (t->Poly->LenTo(a->Poly->Points[a->Poly->Count-1],p2,h)<2.0) {\n  903                          eind--;\n  904                          if (n1)\n  ...\n  908                       }\n  909                       for (k=sind;n2==0 && k<eind;k++) {\n  910:                         (n1==0?n1:n2)=t->Poly->CrossLine(a->Poly->Points[k-1],a->Poly->Points[k],(n1==0?p1:p2));\n  911                          if (n2 && abs (p2.L-p1.L)<100)\n  912                             n2=0;\n  ...\n  923                             swap(p1,p2);\n  924                          }\n  925:                         if (p1.X==t->Poly->Points[n1-1].X && p1.L==t->Poly->Points[n1-1].L)\n  926                             n1--;\n  927:                         else if (p1.X==t->Poly->Points[n1].X && p1.L==t->Poly->Points[n1].L)\n  928                              {}\n  929                          else {\n  ...\n  931                             n2++;\n  932                          }\n  933:                         if (p2.X==t->Poly->Points[n2-1].X && p2.L==t->Poly->Points[n2-1].L)\n  934                             n2--;\n  935:                         else if (p2.X==t->Poly->Points[n2].X && p2.L==t->Poly->Points[n2].L)\n  936                              {}\n  937                          else {\n  ...\n  939                          }\n  940                          for (int i=n1+1;i<=n2;i++)\n  941:                            t->Poly->Points[i].Code.SetVisible(0);\n  942                       }\n  943                    }\n  ...\n 1876           }\n 1877           if (ob->Poly) {\n 1878:             TRoadPoint *p=ob->Poly->Points;\n 1879              for (int i=0;i<ob->Poly->Count;i++) {\n 1880                  int BaseL,BaseX;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\DesignPattern.cpp:\n   83        int pos;  // Ищем точку с фиксированным углом от предыдущей точки\n   84        for (pos=1;pos<=last;pos++)\n   85:          if (Att->Poly->Points[pos].Code()&0x17300==0x17300 &&\n   86:            (Att->Poly->Points[pos].Code.Leep()==5 || Att->Poly->Points[pos].Code.Leep()==6))\n   87                break;\n   88        if (pos<last) {\n   89:          ang=abs(Att->Poly->Points[pos].BasePar1)%360000;\n   90           if (ang>180000)\n   91             ang=360000-ang;\n   92           angle=(ang+500)/1000;\n   93:          elength=abs(Att->Poly->Points[pos].X-Att->Poly->Points[0].X);\n   94:          ewidth=abs(Att->Poly->Points[pos+1].L-Att->Poly->Points[pos].L)*sin(ang*M_PI/180000)+0.5;\n   95        }\n   96:       bwidth=abs(Att->Poly->Points[0].L-Att->Poly->Points[last].L);\n   97  \n   98      }\n   ..\n  132           double x=-bwidth/2+rad*sin(alf);\n  133           double y=/*elength*(1-cos(alf))/maxa*/  rad*(1-cos(alf));\n  134:          Att->Poly->Points[i].Code=Codes[i];\n  135:          Att->Poly->Points[i].LeepPar=0;\n  136:          Att->Poly->Points[i].BasePar1=x;\n  137:          Att->Poly->Points[i].BasePar2=sign*y;\n  138           alf=(180-angle)*i*M_PI/(180*last);\n  139           x=bwidth/2-rad*sin(alf);\n  140           y=/*elength*(1-cos(alf))/maxa*/ rad*(1-cos(alf));\n  141:          Att->Poly->Points[PtCount-1-i].Code=Codes[PtCount-1-i];\n  142:          Att->Poly->Points[PtCount-1-i].LeepPar=0;\n  143:          Att->Poly->Points[PtCount-1-i].BasePar1=x;\n  144:          Att->Poly->Points[PtCount-1-i].BasePar2=sign*y;\n  145        }\n  146:       Att->Poly->Points[last+1].Code=Codes[last+1];\n  147:       Att->Poly->Points[last+1].LeepPar=0;\n  148:       Att->Poly->Points[last+2].Code=Codes[last+2];\n  149:       Att->Poly->Points[last+2].LeepPar=0;\n  150:       Att->Poly->Points[last+1].BasePar1=sign*angle*1000;\n  151:       Att->Poly->Points[last+2].BasePar1=sign*angle*1000;\n  152        // BasePar2 будет пересчитано автоматически далее\n  153        Data->Road->CalcPointsPos(Att->Poly,Att);\n  ...\n  168          if (Att->Poly->Count>1)\n  169              {\n  170:             L1=Att->Poly->Points[0].L;\n  171:             L2=Att->Poly->Points[Att->Poly->Count-1].L;\n  172              if (Att->Poly->Count==4)\n  173                  {\n  174:                 DX1=abs(Att->Poly->Points[1].X-Att->Poly->Points[0].X);\n  175:                 DX2=abs(Att->Poly->Points[2].X-Att->Poly->Points[3].X);\n  176:                 L3=Att->Poly->Points[1].L;\n  177:                 L4=Att->Poly->Points[2].L;\n  178                  }\n  179              else if (Att->Poly->Count==10)\n  180                  {\n  181:                 DX1=abs(Att->Poly->Points[3].X-Att->Poly->Points[0].X);\n  182:                 DX2=abs(Att->Poly->Points[6].X-Att->Poly->Points[9].X);\n  183:                 L3=Att->Poly->Points[3].L;\n  184:                 L4=Att->Poly->Points[6].L;\n  185                  }\n  186              }\n  ...\n  247      for (int i=0;i<PtCount;i++)\n  248          {\n  249:         Att->Poly->Points[i].Code=Codes[i];\n  250:         Att->Poly->Points[i].LeepPar=0;\n  251          }\n  252  // Устанавливаем не привязанные точки\n  253:     TRoadPoint *P=Att->Poly->Points;\n  254      P[0].BasePar1=L1-L;\n  255      P[0].BasePar2=0;\n  ...\n  303              TRoadSignal *Signal=(TRoadSignal*)Data->Factory->CreateRoadObj(Meta->ClassName,0,ROADSIGNALCODE);\n  304              Signal->Count=6;\n  305:             Signal->PutPosition(Att->Poly->Points[0].L,Att->Poly->Points[3].L);\n  306              Signal->Placement=(TObjPlacement)Att->Placement;\n  307              Signal->Kind=skStolb;\n  ...\n  311              //Data->PolyList->Add(Signal->Poly);\n  312              Signal->Poly->Count=SignalPointCount;\n  313:             TRoadPoint *AttP=Att->Poly->Points;\n  314:             TRoadPoint *P=Signal->Poly->Points;\n  315              const int *Codes;\n  316              if (Signal->Placement==opLeft)\n  ...\n  331              Signal=(TRoadSignal*)Data->Factory->CreateRoadObj(Meta->ClassName,0,ROADSIGNALCODE);\n  332              Signal->Count=6;\n  333:             Signal->PutPosition(Att->Poly->Points[6].L,Att->Poly->Points[9].L);\n  334              Signal->Placement=(TObjPlacement)Att->Placement;\n  335              Signal->Kind=skStolb;\n  ...\n  339              //Data->PolyList->Add(Signal->Poly);\n  340              Signal->Poly->Count=SignalPointCount;\n  341:             P=Signal->Poly->Points;\n  342              if (Signal->Placement==opLeft)\n  343                  Codes=SignalCodes2L;\n  ...\n  370        int pos;  // Ищем точку с фиксированным углом от предыдущей точки\n  371        for (pos=1;pos<=last-2;pos++)\n  372:          if (Att->Poly->Points[pos].Code()&0x17300==0x17300 &&\n  373:            (Att->Poly->Points[pos].Code.Leep()==5 || Att->Poly->Points[pos].Code.Leep()==6))\n  374                break;\n  375        if (pos<last) {\n  ...\n  379           mark->SetKind(ma2_1);\n  380           for (int i=0;i<pos;i++) {\n  381:             mark->Poly->Points[i].BasePar1=Att->Poly->Points[i].L+50;\n  382:             mark->Poly->Points[i].BasePar2=Att->Poly->Points[i].X;\n  383:             mark->Poly->Points[i].Code=(i==0?0:1);\n  384           }\n  385:          int left=mark->Poly->Points[0].BasePar1=((Att->Poly->Points[0].L+99)/100)*100;\n  386:          mark->Poly->Points[pos]=Att->Poly->Points[pos];\n  387           mark->DrwClassId=Dict->SelectDrwParam(mark,ROADMARKPAGE);\n  388           Data->Road->CalcPointsPos(mark->Poly,mark);\n  ...\n  395           mark->SetKind(ma2_1);\n  396           for (int i=0;i<last-pos-1;i++) {\n  397:             mark->Poly->Points[i].BasePar1=Att->Poly->Points[last-i].L-50;\n  398:             mark->Poly->Points[i].BasePar2=Att->Poly->Points[last-i].X;\n  399:             mark->Poly->Points[i].Code=(i==0?0:1);\n  400           }\n  401:          int right=mark->Poly->Points[0].BasePar1=((Att->Poly->Points[last].L)/100)*100;\n  402:          mark->Poly->Points[last-pos-1]=Att->Poly->Points[pos];\n  403           mark->DrwClassId=Dict->SelectDrwParam(mark,ROADMARKPAGE);\n  404           Data->Road->CalcPointsPos(mark->Poly,mark);\n  ...\n  410           mark->SetDirection((Att->Placement==opRight) ? roDirect:roUnDirect);\n  411           mark->SetKind(ma1);\n  412:          int center=mark->Poly->Points[0].BasePar1=((Att->Poly->Points[0].L+Att->Poly->Points[last].L+100)/200)*100;\n  413:          mark->Poly->Points[0].BasePar2=Att->Poly->Points[0].X;\n  414:          mark->Poly->Points[0].Code=0;\n  415:          if (abs(Att->Poly->Points[pos-1].X)>abs(Att->Poly->Points[pos+2].X)) {\n  416:             mark->Poly->Points[1].BasePar1=Att->Poly->Points[pos-1].L+(Att->Poly->Points[pos+1].L-Att->Poly->Points[pos].L)/2;\n  417:             mark->Poly->Points[1].BasePar2=Att->Poly->Points[pos-1].X;\n  418           } else {\n  419:             mark->Poly->Points[1].BasePar1=Att->Poly->Points[pos+2].L-(Att->Poly->Points[pos+1].L-Att->Poly->Points[pos].L)/2;\n  420:             mark->Poly->Points[1].BasePar2=Att->Poly->Points[pos+2].X;\n  421           }\n  422:          mark->Poly->Points[1].Code=1;\n  423:          mark->Poly->Points[2]=Att->Poly->Points[pos];\n  424           mark->DrwClassId=Dict->SelectDrwParam(mark,ROADMARKPAGE);\n  425           Data->Road->CalcPointsPos(mark->Poly,mark);\n  ...\n  463          int c2=0;\n  464          for (int i=1;i<Att->Poly->Count;i++)\n  465:             if (!Att->Poly->Points[i].Code.Visible())\n  466                  {\n  467                  c1=i+1;\n  ...\n  482                  mark->SetLMax(Att->LMax);\n  483                  for (int i=0;i<c1;i++)\n  484:                     mark->Poly->Points[i]=Att->Poly->Points[i];\n  485                  mark->DrwClassId=Dict->SelectDrwParam(mark,ROADMARKPAGE);\n  486                  Att->AddChild(mark);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\DrawMan.cpp:\n 1087  void __fastcall TDrawManager::CalcRect(TExtPolyline* Poly,RECT *r)\n 1088  {\n 1089: POINT *p=Poly->Points;\n 1090  int n=Poly->Count;\n 1091  if (n)\n ....\n 1300          if (Poly->Count>1)\n 1301              {\n 1302:             int dx=Poly->Points[1].x-Poly->Points[0].x;\n 1303:             int dy=Poly->Points[1].y-Poly->Points[0].y;\n 1304              int adx=abs(dx);\n 1305              int ady=abs(dy);\n ....\n 1316  //        TMetafile *mtf=Shared->Metas->Metas[par->MetaId];\n 1317          TMetafile *mtf=Shared->Metas->GetMetafile(par->MetaId,dir);\n 1318:         CalcMetaRect(Poly->Points,par,rct,dir,false);\n 1319          PlayEnhMetaFile(dc,(void*)mtf->Handle,rct);\n 1320          }\n ....\n 1779          SelectObject(dc,pen);\n 1780          int n=Poly->Count;\n 1781:         POINT *p=Poly->Points;\n 1782          if (n==2)  //Рисуем трубу\n 1783              {\n ....\n 2069  if (dc)\n 2070      {\n 2071:     POINT *p=Poly->Points;\n 2072      scale=(double)FBaseScaleX/FSclX*FDpsm/100;\n 2073      int size=(double)par->Length*scale+0.5;\n ....\n 2110  if (n>0)\n 2111      {\n 2112:     POINT *p=Poly->Points;\n 2113      int *Codes=(int*)Poly->Codes;\n 2114      double scale;\n ....\n 2882        int Count=Src->Count;\n 2883        TExtPolyline *Poly=new TExtPolyline(4,1);\n 2884:       POINT *P=Poly->Points;\n 2885        TRect R;\n 2886        TObjList<TDrwParamRec> *DrPar=Dict->DrwParams;\n ....\n 2942        int Count=Src->Count;\n 2943        TExtPolyline *Poly=new TExtPolyline(4,1);\n 2944:       POINT *P=Poly->Points;\n 2945        TRect R;\n 2946        TObjList<TDrwParamRec> *DrPar=Dict->DrwParams;\n ....\n 3067    //    TSlopesPart* Parts=Road->Geometry.BuildSlopesPart(Source->ProfilMinLen*100,Source->ProfilMaxDev,n);\n 3068                  TExtPolyline *Poly=new TExtPolyline(4,1);\n 3069:                 POINT *P=Poly->Points;\n 3070                  TRect R;\n 3071                  TObjList<TDrwParamRec> *DrPar=Dict->DrwParams;\n ....\n 3190                          if (FPlanKind==pkGorizontal)\n 3191                              {\n 3192:                             int outx=(Poly->Points[i+1].x+Poly->Points[PrevI+2].x-strsize.cx)>>1;\n 3193                              bool dodraw=false;\n 3194                              if (FPlanDirect==pdDirect)\n ....\n 3202                              if (dodraw)\n 3203                                  {\n 3204:                                 int outy=Poly->Points[i+1].y;\n 3205                                  if (newnapr>0)\n 3206                                      outy-=5+strsize.cy;\n ....\n 3216                          else\n 3217                              {\n 3218:                             int outy=(Poly->Points[i+1].y+Poly->Points[PrevI+2].y-strsize.cy)>>1;\n 3219                              bool dodraw=false;\n 3220                              if (FPlanDirect==pdUndirect)\n ....\n 3228                              if (dodraw)\n 3229                                  {\n 3230:                                 int outx=Poly->Points[i+1].x;\n 3231                                  if (newnapr>0)\n 3232                                      outx-=5+strsize.cx;\n\nD:\\_DISTR\\_ASUDOR\\RSign\\Metrics.cpp:\n   46  bool Res=false;\n   47  int n=Poly->Count;\n   48: TRoadPoint *p=Poly->Points;\n   49  if (n>0)\n   50      {\n   ..\n  939  int s=0;\n  940  FreePoints();\n  941: TRoadPoint *Sour=Poly->Points;\n  942  int n=Poly->Count;\n  943  // Здесь можно написать двоичный поиск.\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RoadObj.cpp:\n 1422          if (Poly->Count)\n 1423              {       // Ищем точку с мин координатой и если она далее 1 метра от края то текст не выводим\n 1424:             int MinL=Poly->Points[0].L;\n 1425              int MinInd=0;\n 1426              for (int i=1;i<Poly->Count;i++)\n 1427:                 if (MinL>Poly->Points[i].L)\n 1428                      {\n 1429:                     MinL=Poly->Points[i].L;\n 1430                      MinInd=i;\n 1431                      }\n ....\n 1435              else\n 1436                  RX=Road->RightLine.FindX(L);\n 1437:             int X=Poly->Points[MinInd].X;\n 1438              if (abs(X)>abs(RX)+100)\n 1439                  outbnd=false;\n ....\n 1471          if (Poly->Count)\n 1472              {       // Ищем точку с макс координатой и если она далее 1 метра от края то текст не выводим\n 1473:             int MaxL=Poly->Points[0].L;\n 1474              int MaxInd=0;\n 1475              for (int i=1;i<Poly->Count;i++)\n 1476:                 if (MaxL<Poly->Points[i].L)\n 1477                      {\n 1478:                     MaxL=Poly->Points[i].L;\n 1479                      MaxInd=i;\n 1480                      }\n ....\n 1484              else\n 1485                  RX=Road->RightLine.FindX(L);\n 1486:             int X=Poly->Points[MaxInd].X;\n 1487              if (abs(X)>abs(RX)+100)\n 1488                  outbnd=false;\n ....\n 2418  int i;\n 2419  int n=Poly->Count;\n 2420: TRoadPoint *p=Poly->Points;\n 2421  for (i=0;i<n;i++)\n 2422      if (p[i].Code.Undepended())\n ....\n 2454  __int32 BaseL,BaseX;\n 2455  int n=Poly->Count;\n 2456: TRoadPoint *p=Poly->Points;\n 2457  TPointCode Code=p[i].Code;\n 2458  //GetBase(Poly,i,RefObj,BaseL,BaseX);\n ....\n 2583      BaseL=0;\n 2584      int n=Poly->Count;\n 2585:     TRoadPoint *p=Poly->Points;\n 2586      TPointCode Code=p[i].Code;\n 2587      int pred_i=(i+n-1)%n;\n ....\n 2603  BaseX=0;\n 2604  int n=Poly->Count;\n 2605: TRoadPoint *p=Poly->Points;\n 2606  TPointCode Code=p[i].Code;\n 2607  int pred_i=(i+n-1)%n;\n ....\n 2628  BaseX=0;\n 2629  int n=Poly->Count;\n 2630: TRoadPoint *p=Poly->Points;\n 2631  TPointCode Code=p[i].Code;\n 2632  int pred_i=(i+n-1)%n;\n ....\n 2696  __int32 BaseL,BaseX;\n 2697  int n=Poly->Count;\n 2698: TRoadPoint *p=Poly->Points;\n 2699  //GetBase(Poly,i,RefObj,BaseL,BaseX);\n 2700  GetBaseL(Poly,i,RefObj,BaseL);\n\nD:\\_DISTR\\_ASUDOR\\RSign\\ShowRoad.cpp:\n 2442  				int minl=1<<30,maxl=1<<30,minr=1<<30,maxr=1<<30;\n 2443  				if (NL && NL->Poly)\n 2444: 				minl=min(NL->Poly->Points[0].L,NL->Poly->Points[NL->Poly->Count-1].L),\n 2445: 				maxl=max(NL->Poly->Points[0].L,NL->Poly->Points[NL->Poly->Count-1].L);\n 2446  				if (NR && NR->Poly)\n 2447: 				minr=min(NR->Poly->Points[0].L,NR->Poly->Points[NR->Poly->Count-1].L),\n 2448: 				maxr=max(NR->Poly->Points[0].L,NR->Poly->Points[NR->Poly->Count-1].L);\n 2449  				minl=((minl+99)/100)*100;\n 2450  				minr=((minr+99)/100)*100;\n\n384 matches across 7 files\n\n\nSearching 2115 files for \"BindToActive\" (case sensitive, whole word)\n\nD:\\_DISTR\\_ASUDOR\\RSign\\AutoCADHelper.cpp:\n  170  {\n  171  \n  172:    if(FAILED(cadApplication.BindToActive(ProgIDToClassID(this->AutoCADProgID)))) return 0;\n  173  \n  174     if(cadApplication->Documents->Count>0 && cadApplication->ActiveDocument){\n  ...\n  184      IAcadApplication *obj;\n  185      disp->QueryInterface(__uuidof(IAcadApplication), (void **)&obj);\n  186:     /*if(FAILED(cadApplication.BindToActive(ProgIDToClassID(this->AutoCADProgID)))){\n  187          if(FAILED(cadApplication.Bind(ProgIDToClassID(AutoCADProgID)))){\n  188             throw \"can't run AutoCAD\";\n\nD:\\_DISTR\\_ASUDOR\\RSign\\GdiEdit.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_misha.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSign_TLB.h:\n  191    HRESULT BindRunning()\n  192    {\n  193:     return BindToActive(CLSID_RoadView);\n  194    }\n  195  \n\nD:\\_DISTR\\_ASUDOR\\RSign\\RSignx64.tds:\n    <binary>\n\nD:\\_DISTR\\_ASUDOR\\RSign\\ActiveX\\MediaPlayer_TLB.h:\n 2682    HRESULT BindRunning()\n 2683    {\n 2684:     return BindToActive(CLSID_DirectControl);\n 2685    }\n 2686  \n ....\n 2811    HRESULT BindRunning()\n 2812    {\n 2813:     return BindToActive(CLSID_RadioView);\n 2814    }\n 2815  \n ....\n 3390    HRESULT BindRunning()\n 3391    {\n 3392:     return BindToActive(CLSID_MediaPlayer_);\n 3393    }\n 3394  \n ....\n 4515    HRESULT BindRunning()\n 4516    {\n 4517:     return BindToActive(CLSID_AsyncPProt);\n 4518    }\n 4519  \n ....\n 4579    HRESULT BindRunning()\n 4580    {\n 4581:     return BindToActive(CLSID_AsyncMHandler);\n 4582    }\n 4583  \n ....\n 4695    HRESULT BindRunning()\n 4696    {\n 4697:     return BindToActive(CLSID_RadioPlayer);\n 4698    }\n 4699  \n ....\n 4876    HRESULT BindRunning()\n 4877    {\n 4878:     return BindToActive(CLSID_RadioBand);\n 4879    }\n 4880  \n\nC:\\Program Files (x86)\\Borland\\CBuilder6\\Imports\\AutoCAD_TLB.h:\n 28037    HRESULT BindRunning()\n 28038    {\n 28039:     return BindToActive(CLSID_AcadObject);\n 28040    }\n 28041  \n .....\n 28243    HRESULT BindRunning()\n 28244    {\n 28245:     return BindToActive(CLSID_AcadDatabase);\n 28246    }\n 28247  \n .....\n 28768    HRESULT BindRunning()\n 28769    {\n 28770:     return BindToActive(CLSID_AcadModelSpace);\n 28771    }\n 28772  \n .....\n 29240    HRESULT BindRunning()\n 29241    {\n 29242:     return BindToActive(CLSID_AcadBlock);\n 29243    }\n 29244  \n .....\n 29802    HRESULT BindRunning()\n 29803    {\n 29804:     return BindToActive(CLSID_AcadEntity);\n 29805    }\n 29806  \n .....\n 30019    HRESULT BindRunning()\n 30020    {\n 30021:     return BindToActive(CLSID_AcadAcCmColor);\n 30022    }\n 30023  \n .....\n 30132    HRESULT BindRunning()\n 30133    {\n 30134:     return BindToActive(CLSID_AcadHyperlinks);\n 30135    }\n 30136  \n .....\n 30230    HRESULT BindRunning()\n 30231    {\n 30232:     return BindToActive(CLSID_AcadHyperlink);\n 30233    }\n 30234  \n .....\n 30344    HRESULT BindRunning()\n 30345    {\n 30346:     return BindToActive(CLSID_Acad3DFace);\n 30347    }\n 30348  \n .....\n 30596    HRESULT BindRunning()\n 30597    {\n 30598:     return BindToActive(CLSID_AcadPolygonMesh);\n 30599    }\n 30600  \n .....\n 30840    HRESULT BindRunning()\n 30841    {\n 30842:     return BindToActive(CLSID_Acad3DPolyline);\n 30843    }\n 30844  \n .....\n 31084    HRESULT BindRunning()\n 31085    {\n 31086:     return BindToActive(CLSID_AcadArc);\n 31087    }\n 31088  \n .....\n 31438    HRESULT BindRunning()\n 31439    {\n 31440:     return BindToActive(CLSID_AcadAttribute);\n 31441    }\n 31442  \n .....\n 31790    HRESULT BindRunning()\n 31791    {\n 31792:     return BindToActive(CLSID_Acad3DSolid);\n 31793    }\n 31794  \n .....\n 32049    HRESULT BindRunning()\n 32050    {\n 32051:     return BindToActive(CLSID_AcadRegion);\n 32052    }\n 32053  \n .....\n 32289    HRESULT BindRunning()\n 32290    {\n 32291:     return BindToActive(CLSID_AcadCircle);\n 32292    }\n 32293  \n .....\n 32630    HRESULT BindRunning()\n 32631    {\n 32632:     return BindToActive(CLSID_AcadDimAligned);\n 32633    }\n 32634  \n .....\n 33242    HRESULT BindRunning()\n 33243    {\n 33244:     return BindToActive(CLSID_AcadDimension);\n 33245    }\n 33246  \n .....\n 33984    HRESULT BindRunning()\n 33985    {\n 33986:     return BindToActive(CLSID_AcadDimAngular);\n 33987    }\n 33988  \n .....\n 34680    HRESULT BindRunning()\n 34681    {\n 34682:     return BindToActive(CLSID_AcadDimDiametric);\n 34683    }\n 34684  \n .....\n 35484    HRESULT BindRunning()\n 35485    {\n 35486:     return BindToActive(CLSID_AcadDimRotated);\n 35487    }\n 35488  \n .....\n 36212    HRESULT BindRunning()\n 36213    {\n 36214:     return BindToActive(CLSID_AcadDimOrdinate);\n 36215    }\n 36216  \n .....\n 36882    HRESULT BindRunning()\n 36883    {\n 36884:     return BindToActive(CLSID_AcadDimRadial);\n 36885    }\n 36886  \n .....\n 37417    HRESULT BindRunning()\n 37418    {\n 37419:     return BindToActive(CLSID_AcadEllipse);\n 37420    }\n 37421  \n .....\n 37707    HRESULT BindRunning()\n 37708    {\n 37709:     return BindToActive(CLSID_AcadLeader);\n 37710    }\n 37711  \n .....\n 38001    HRESULT BindRunning()\n 38002    {\n 38003:     return BindToActive(CLSID_AcadMText);\n 38004    }\n 38005  \n .....\n 38250    HRESULT BindRunning()\n 38251    {\n 38252:     return BindToActive(CLSID_AcadPoint);\n 38253    }\n 38254  \n .....\n 38498    HRESULT BindRunning()\n 38499    {\n 38500:     return BindToActive(CLSID_AcadLWPolyline);\n 38501    }\n 38502  \n .....\n 38786    HRESULT BindRunning()\n 38787    {\n 38788:     return BindToActive(CLSID_AcadPolyline);\n 38789    }\n 38790  \n .....\n 39032    HRESULT BindRunning()\n 39033    {\n 39034:     return BindToActive(CLSID_AcadRay);\n 39035    }\n 39036  \n .....\n 39258    HRESULT BindRunning()\n 39259    {\n 39260:     return BindToActive(CLSID_AcadShape);\n 39261    }\n 39262  \n .....\n 39488    HRESULT BindRunning()\n 39489    {\n 39490:     return BindToActive(CLSID_AcadSolid);\n 39491    }\n 39492  \n .....\n 39755    HRESULT BindRunning()\n 39756    {\n 39757:     return BindToActive(CLSID_AcadSpline);\n 39758    }\n 39759  \n .....\n 40072    HRESULT BindRunning()\n 40073    {\n 40074:     return BindToActive(CLSID_AcadText);\n 40075    }\n 40076  \n .....\n 40359    HRESULT BindRunning()\n 40360    {\n 40361:     return BindToActive(CLSID_AcadTolerance);\n 40362    }\n 40363  \n .....\n 40596    HRESULT BindRunning()\n 40597    {\n 40598:     return BindToActive(CLSID_AcadTrace);\n 40599    }\n 40600  \n .....\n 40807    HRESULT BindRunning()\n 40808    {\n 40809:     return BindToActive(CLSID_AcadXline);\n 40810    }\n 40811  \n .....\n 41071    HRESULT BindRunning()\n 41072    {\n 41073:     return BindToActive(CLSID_AcadBlockReference);\n 41074    }\n 41075  \n .....\n 41414    HRESULT BindRunning()\n 41415    {\n 41416:     return BindToActive(CLSID_AcadHatch);\n 41417    }\n 41418  \n .....\n 41753    HRESULT BindRunning()\n 41754    {\n 41755:     return BindToActive(CLSID_AcadRasterImage);\n 41756    }\n 41757  \n .....\n 42025    HRESULT BindRunning()\n 42026    {\n 42027:     return BindToActive(CLSID_AcadLine);\n 42028    }\n 42029  \n .....\n 42350    HRESULT BindRunning()\n 42351    {\n 42352:     return BindToActive(CLSID_AcadLayout);\n 42353    }\n 42354  \n .....\n 42556    HRESULT BindRunning()\n 42557    {\n 42558:     return BindToActive(CLSID_AcadPlotConfiguration);\n 42559    }\n 42560  \n .....\n 42778    HRESULT BindRunning()\n 42779    {\n 42780:     return BindToActive(CLSID_AcadMInsertBlock);\n 42781    }\n 42782  \n .....\n 43059    HRESULT BindRunning()\n 43060    {\n 43061:     return BindToActive(CLSID_AcadPolyfaceMesh);\n 43062    }\n 43063  \n .....\n 43273    HRESULT BindRunning()\n 43274    {\n 43275:     return BindToActive(CLSID_AcadMLine);\n 43276    }\n 43277  \n .....\n 43650    HRESULT BindRunning()\n 43651    {\n 43652:     return BindToActive(CLSID_AcadDim3PointAngular);\n 43653    }\n 43654  \n .....\n 44108    HRESULT BindRunning()\n 44109    {\n 44110:     return BindToActive(CLSID_AcadExternalReference);\n 44111    }\n 44112  \n .....\n 44976    HRESULT BindRunning()\n 44977    {\n 44978:     return BindToActive(CLSID_AcadTable);\n 44979    }\n 44980  \n .....\n 46076    HRESULT BindRunning()\n 46077    {\n 46078:     return BindToActive(CLSID_AcadDimArcLength);\n 46079    }\n 46080  \n .....\n 46858    HRESULT BindRunning()\n 46859    {\n 46860:     return BindToActive(CLSID_AcadDimRadialLarge);\n 46861    }\n 46862  \n .....\n 47404    HRESULT BindRunning()\n 47405    {\n 47406:     return BindToActive(CLSID_AcadSection);\n 47407    }\n 47408  \n .....\n 47662    HRESULT BindRunning()\n 47663    {\n 47664:     return BindToActive(CLSID_AcadSectionSettings);\n 47665    }\n 47666  \n .....\n 48187    HRESULT BindRunning()\n 48188    {\n 48189:     return BindToActive(CLSID_AcadMLeader);\n 48190    }\n 48191  \n .....\n 48554    HRESULT BindRunning()\n 48555    {\n 48556:     return BindToActive(CLSID_AcadPaperSpace);\n 48557    }\n 48558  \n .....\n 49178    HRESULT BindRunning()\n 49179    {\n 49180:     return BindToActive(CLSID_AcadPViewport);\n 49181    }\n 49182  \n .....\n 49531    HRESULT BindRunning()\n 49532    {\n 49533:     return BindToActive(CLSID_AcadView);\n 49534    }\n 49535  \n .....\n 49686    HRESULT BindRunning()\n 49687    {\n 49688:     return BindToActive(CLSID_AcadBlocks);\n 49689    }\n 49690  \n .....\n 49812    HRESULT BindRunning()\n 49813    {\n 49814:     return BindToActive(CLSID_AcadGroups);\n 49815    }\n 49816  \n .....\n 49963    HRESULT BindRunning()\n 49964    {\n 49965:     return BindToActive(CLSID_AcadGroup);\n 49966    }\n 49967  \n .....\n 50112    HRESULT BindRunning()\n 50113    {\n 50114:     return BindToActive(CLSID_AcadDimStyles);\n 50115    }\n 50116  \n .....\n 50231    HRESULT BindRunning()\n 50232    {\n 50233:     return BindToActive(CLSID_AcadDimStyle);\n 50234    }\n 50235  \n .....\n 50350    HRESULT BindRunning()\n 50351    {\n 50352:     return BindToActive(CLSID_AcadLayers);\n 50353    }\n 50354  \n .....\n 50532    HRESULT BindRunning()\n 50533    {\n 50534:     return BindToActive(CLSID_AcadLayer);\n 50535    }\n 50536  \n .....\n 50702    HRESULT BindRunning()\n 50703    {\n 50704:     return BindToActive(CLSID_AcadLineTypes);\n 50705    }\n 50706  \n .....\n 50825    HRESULT BindRunning()\n 50826    {\n 50827:     return BindToActive(CLSID_AcadLineType);\n 50828    }\n 50829  \n .....\n 50947    HRESULT BindRunning()\n 50948    {\n 50949:     return BindToActive(CLSID_AcadDictionaries);\n 50950    }\n 50951  \n .....\n 51091    HRESULT BindRunning()\n 51092    {\n 51093:     return BindToActive(CLSID_AcadDictionary);\n 51094    }\n 51095  \n .....\n 51237    HRESULT BindRunning()\n 51238    {\n 51239:     return BindToActive(CLSID_AcadXRecord);\n 51240    }\n 51241  \n .....\n 51363    HRESULT BindRunning()\n 51364    {\n 51365:     return BindToActive(CLSID_AcadRegisteredApplications);\n 51366    }\n 51367  \n .....\n 51481    HRESULT BindRunning()\n 51482    {\n 51483:     return BindToActive(CLSID_AcadRegisteredApplication);\n 51484    }\n 51485  \n .....\n 51599    HRESULT BindRunning()\n 51600    {\n 51601:     return BindToActive(CLSID_AcadTextStyles);\n 51602    }\n 51603  \n .....\n 51750    HRESULT BindRunning()\n 51751    {\n 51752:     return BindToActive(CLSID_AcadTextStyle);\n 51753    }\n 51754  \n .....\n 51903    HRESULT BindRunning()\n 51904    {\n 51905:     return BindToActive(CLSID_AcadUCSs);\n 51906    }\n 51907  \n .....\n 52034    HRESULT BindRunning()\n 52035    {\n 52036:     return BindToActive(CLSID_AcadUCS);\n 52037    }\n 52038  \n .....\n 52162    HRESULT BindRunning()\n 52163    {\n 52164:     return BindToActive(CLSID_AcadViews);\n 52165    }\n 52166  \n .....\n 52288    HRESULT BindRunning()\n 52289    {\n 52290:     return BindToActive(CLSID_AcadViewports);\n 52291    }\n 52292  \n .....\n 52475    HRESULT BindRunning()\n 52476    {\n 52477:     return BindToActive(CLSID_AcadViewport);\n 52478    }\n 52479  \n .....\n 52651    HRESULT BindRunning()\n 52652    {\n 52653:     return BindToActive(CLSID_AcadLayouts);\n 52654    }\n 52655  \n .....\n 52778    HRESULT BindRunning()\n 52779    {\n 52780:     return BindToActive(CLSID_AcadPlotConfigurations);\n 52781    }\n 52782  \n .....\n 53000    HRESULT BindRunning()\n 53001    {\n 53002:     return BindToActive(CLSID_AcadDatabasePreferences);\n 53003    }\n 53004  \n .....\n 53167    HRESULT BindRunning()\n 53168    {\n 53169:     return BindToActive(CLSID_AcadFileDependencies);\n 53170    }\n 53171  \n .....\n 53293    HRESULT BindRunning()\n 53294    {\n 53295:     return BindToActive(CLSID_AcadFileDependency);\n 53296    }\n 53297  \n .....\n 53436    HRESULT BindRunning()\n 53437    {\n 53438:     return BindToActive(CLSID_AcadSummaryInfo);\n 53439    }\n 53440  \n .....\n 53557    HRESULT BindRunning()\n 53558    {\n 53559:     return BindToActive(CLSID_AcadSectionManager);\n 53560    }\n 53561  \n .....\n 53685    HRESULT BindRunning()\n 53686    {\n 53687:     return BindToActive(CLSID_AcadMaterials);\n 53688    }\n 53689  \n .....\n 53807    HRESULT BindRunning()\n 53808    {\n 53809:     return BindToActive(CLSID_AcadMaterial);\n 53810    }\n 53811  \n .....\n 53923    HRESULT BindRunning()\n 53924    {\n 53925:     return BindToActive(CLSID_AcadSectionTypeSettings);\n 53926    }\n 53927  \n .....\n 54208    HRESULT BindRunning()\n 54209    {\n 54210:     return BindToActive(CLSID_AcadDynamicBlockReferenceProperty);\n 54211    }\n 54212  \n .....\n 54309    HRESULT BindRunning()\n 54310    {\n 54311:     return BindToActive(CLSID_AcadSortentsTable);\n 54312    }\n 54313  \n .....\n 54453    HRESULT BindRunning()\n 54454    {\n 54455:     return BindToActive(CLSID_AcadIdPair);\n 54456    }\n 54457  \n .....\n 54733    HRESULT BindRunning()\n 54734    {\n 54735:     return BindToActive(CLSID_AcadTableStyle);\n 54736    }\n 54737  \n .....\n 55213    HRESULT BindRunning()\n 55214    {\n 55215:     return BindToActive(CLSID_AcadMLeaderStyle);\n 55216    }\n 55217  \n .....\n 57304    HRESULT BindRunning()\n 57305    {\n 57306:     return BindToActive(CLSID_AcadAttributeReference);\n 57307    }\n 57308  \n .....\n 58730    HRESULT BindRunning()\n 58731    {\n 58732:     return BindToActive(CLSID_AcadSubEntity);\n 58733    }\n 58734  \n .....\n 58850    HRESULT BindRunning()\n 58851    {\n 58852:     return BindToActive(CLSID_AcadMLeaderLeader);\n 58853    }\n 58854  \n .....\n 63814    HRESULT BindRunning()\n 63815    {\n 63816:     return BindToActive(CLSID_AcadOle);\n 63817    }\n 63818  \n .....\n 64283    HRESULT BindRunning()\n 64284    {\n 64285:     return BindToActive(CLSID_AcadHelix);\n 64286    }\n 64287  \n .....\n 64722    HRESULT BindRunning()\n 64723    {\n 64724:     return BindToActive(CLSID_AcadSurface);\n 64725    }\n 64726  \n .....\n 65310    HRESULT BindRunning()\n 65311    {\n 65312:     return BindToActive(CLSID_AcadPlaneSurface);\n 65313    }\n 65314  \n .....\n 65911    HRESULT BindRunning()\n 65912    {\n 65913:     return BindToActive(CLSID_AcadExtrudedSurface);\n 65914    }\n 65915  \n .....\n 66541    HRESULT BindRunning()\n 66542    {\n 66543:     return BindToActive(CLSID_AcadRevolvedSurface);\n 66544    }\n 66545  \n .....\n 67180    HRESULT BindRunning()\n 67181    {\n 67182:     return BindToActive(CLSID_AcadSweptSurface);\n 67183    }\n 67184  \n .....\n 67860    HRESULT BindRunning()\n 67861    {\n 67862:     return BindToActive(CLSID_AcadLoftedSurface);\n 67863    }\n 67864  \n .....\n 68649    HRESULT BindRunning()\n 68650    {\n 68651:     return BindToActive(CLSID_AcadDwfUnderlay);\n 68652    }\n 68653  \n .....\n 69127    HRESULT BindRunning()\n 69128    {\n 69129:     return BindToActive(CLSID_AcadSubEntSolidFace);\n 69130    }\n 69131  \n .....\n 69222    HRESULT BindRunning()\n 69223    {\n 69224:     return BindToActive(CLSID_AcadSubEntSolidEdge);\n 69225    }\n 69226  \n .....\n 69313    HRESULT BindRunning()\n 69314    {\n 69315:     return BindToActive(CLSID_AcadSubEntSolidVertex);\n 69316    }\n 69317  \n .....\n 69404    HRESULT BindRunning()\n 69405    {\n 69406:     return BindToActive(CLSID_AcadSubEntSolidNode);\n 69407    }\n 69408  \n .....\n 69495    HRESULT BindRunning()\n 69496    {\n 69497:     return BindToActive(CLSID_AcadWipeout);\n 69498    }\n 69499  \n .....\n 69991    HRESULT BindRunning()\n 69992    {\n 69993:     return BindToActive(CLSID_AcadSubDMesh);\n 69994    }\n 69995  \n .....\n 70389    HRESULT BindRunning()\n 70390    {\n 70391:     return BindToActive(CLSID_AcadSubDMeshFace);\n 70392    }\n 70393  \n .....\n 70500    HRESULT BindRunning()\n 70501    {\n 70502:     return BindToActive(CLSID_AcadSubDMeshEdge);\n 70503    }\n 70504  \n .....\n 70610    HRESULT BindRunning()\n 70611    {\n 70612:     return BindToActive(CLSID_AcadSubDMeshVertex);\n 70613    }\n 70614  \n .....\n 70739    HRESULT BindRunning()\n 70740    {\n 70741:     return BindToActive(CLSID_AcadNurbSurface);\n 70742    }\n 70743  \n .....\n 75513    HRESULT BindRunning()\n 75514    {\n 75515:     return BindToActive(CLSID_AcadPointCloud);\n 75516    }\n 75517  \n .....\n 75763    HRESULT BindRunning()\n 75764    {\n 75765:     return BindToActive(CLSID_AcadSecurityParams);\n 75766    }\n 75767  \n .....\n 75883    HRESULT BindRunning()\n 75884    {\n 75885:     return BindToActive(CLSID_AcadLayerStateManager);\n 75886    }\n 75887  \n .....\n 76173    HRESULT BindRunning()\n 76174    {\n 76175:     return BindToActive(CLSID_AcadDocument);\n 76176    }\n 76177  \n .....\n 76493    HRESULT BindRunning()\n 76494    {\n 76495:     return BindToActive(CLSID_AcadPlot);\n 76496    }\n 76497  \n .....\n 76688    HRESULT BindRunning()\n 76689    {\n 76690:     return BindToActive(CLSID_AcadApplication);\n 76691    }\n 76692  \n .....\n 76889    HRESULT BindRunning()\n 76890    {\n 76891:     return BindToActive(CLSID_AcadPreferences);\n 76892    }\n 76893  \n .....\n 77129    HRESULT BindRunning()\n 77130    {\n 77131:     return BindToActive(CLSID_AcadPreferencesFiles);\n 77132    }\n 77133  \n .....\n 77470    HRESULT BindRunning()\n 77471    {\n 77472:     return BindToActive(CLSID_AcadPreferencesDisplay);\n 77473    }\n 77474  \n .....\n 77712    HRESULT BindRunning()\n 77713    {\n 77714:     return BindToActive(CLSID_AcadPreferencesOpenSave);\n 77715    }\n 77716  \n .....\n 77900    HRESULT BindRunning()\n 77901    {\n 77902:     return BindToActive(CLSID_AcadPreferencesOutput);\n 77903    }\n 77904  \n .....\n 78071    HRESULT BindRunning()\n 78072    {\n 78073:     return BindToActive(CLSID_AcadPreferencesSystem);\n 78074    }\n 78075  \n .....\n 78224    HRESULT BindRunning()\n 78225    {\n 78226:     return BindToActive(CLSID_AcadPreferencesUser);\n 78227    }\n 78228  \n .....\n 78397    HRESULT BindRunning()\n 78398    {\n 78399:     return BindToActive(CLSID_AcadPreferencesDrafting);\n 78400    }\n 78401  \n .....\n 78570    HRESULT BindRunning()\n 78571    {\n 78572:     return BindToActive(CLSID_AcadPreferencesSelection);\n 78573    }\n 78574  \n .....\n 78697    HRESULT BindRunning()\n 78698    {\n 78699:     return BindToActive(CLSID_AcadPreferencesProfiles);\n 78700    }\n 78701  \n .....\n 78797    HRESULT BindRunning()\n 78798    {\n 78799:     return BindToActive(CLSID_AcadMenuGroups);\n 78800    }\n 78801  \n .....\n 78909    HRESULT BindRunning()\n 78910    {\n 78911:     return BindToActive(CLSID_AcadMenuGroup);\n 78912    }\n 78913  \n .....\n 79020    HRESULT BindRunning()\n 79021    {\n 79022:     return BindToActive(CLSID_AcadPopupMenus);\n 79023    }\n 79024  \n .....\n 79151    HRESULT BindRunning()\n 79152    {\n 79153:     return BindToActive(CLSID_AcadPopupMenu);\n 79154    }\n 79155  \n .....\n 79313    HRESULT BindRunning()\n 79314    {\n 79315:     return BindToActive(CLSID_AcadPopupMenuItem);\n 79316    }\n 79317  \n .....\n 79450    HRESULT BindRunning()\n 79451    {\n 79452:     return BindToActive(CLSID_AcadToolbars);\n 79453    }\n 79454  \n .....\n 79609    HRESULT BindRunning()\n 79610    {\n 79611:     return BindToActive(CLSID_AcadToolbar);\n 79612    }\n 79613  \n .....\n 79785    HRESULT BindRunning()\n 79786    {\n 79787:     return BindToActive(CLSID_AcadToolbarItem);\n 79788    }\n 79789  \n .....\n 79906    HRESULT BindRunning()\n 79907    {\n 79908:     return BindToActive(CLSID_AcadMenuBar);\n 79909    }\n 79910  \n .....\n 80008    HRESULT BindRunning()\n 80009    {\n 80010:     return BindToActive(CLSID_AcadDocuments);\n 80011    }\n 80012  \n .....\n 80102    HRESULT BindRunning()\n 80103    {\n 80104:     return BindToActive(CLSID_AcadState);\n 80105    }\n 80106  \n .....\n 80188    HRESULT BindRunning()\n 80189    {\n 80190:     return BindToActive(CLSID_AcadSelectionSets);\n 80191    }\n 80192  \n .....\n 80304    HRESULT BindRunning()\n 80305    {\n 80306:     return BindToActive(CLSID_AcadSelectionSet);\n 80307    }\n 80308  \n .....\n 80514    HRESULT BindRunning()\n 80515    {\n 80516:     return BindToActive(CLSID_AcadUtility);\n 80517    }\n 80518  \n\n171 matches across 7 files\n",
			"settings":
			{
				"buffer_size": 138052,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/C/Program Files (x86)/Borland/CBuilder6/Include/Vcl/utilcls.h",
			"settings":
			{
				"buffer_size": 116603,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Program Files (x86)/Borland/CBuilder6/Include/oleauto.h",
			"settings":
			{
				"buffer_size": 47067,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AutoCADHelper.cpp",
			"settings":
			{
				"buffer_size": 69524,
				"line_ending": "Windows"
			}
		},
		{
			"file": "AutoCADHelper.h",
			"settings":
			{
				"buffer_size": 21049,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 157.0,
		"last_filter": "Package Control: ins",
		"selected_items":
		[
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"Package Control: Ins",
				"Package Control: Install Package"
			]
		],
		"width": 560.0
	},
	"console":
	{
		"height": 160.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/_DISTR/_ASUDOR/RSign"
	],
	"file_history":
	[
		"/D/_DISTR/_ASUDOR/RSign/AutoCADExportForm.h",
		"/D/_DISTR/_ASUDOR/RSign/Helpers.cpp",
		"/D/_DISTR/_ASUDOR/RSign/Helpers.h",
		"/D/_DISTR/_ASUDOR/RSign/MainUnit.cpp",
		"/D/_DISTR/_ASUDOR/RSign/AutoCADPrintForm.cpp",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Package Control/Package Control.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Package Control.sublime-settings",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Default/Default (Windows).sublime-keymap",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/D/_DISTR/_ASUDOR/RSign/AutoCADPrintForm.h",
		"/D/_DISTR/_ASUDOR/RSign/rsign.sublime-project",
		"/D/_DISTR/_ASUDOR/RSign/RoadMark.cpp",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
		"/C/Users/m/AppData/Roaming/Sublime Text 3/Packages/SublimeAStyleFormatter/Default (Windows).sublime-keymap",
		"/E/Projects/RSign/AutoCADExportHelper.cpp",
		"/E/Projects/RSign/AutoCADPrintForm.cpp",
		"/E/Projects/RSign/AutoCADPrintForm.h"
	],
	"find":
	{
		"height": 38.0
	},
	"find_in_files":
	{
		"height": 126.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"GetActiveObject",
			"BindToActive",
			"Poly->Points",
			";\n",
			"points",
			"GetCenterOnPolyline",
			"int",
			"DrawTextOverPoly",
			"GetAngle",
			"GetAngle2",
			",",
			" / 100",
			"step",
			"iStep",
			"DrawEmpty",
			"RowslEnd",
			"minS",
			"minE",
			"DrawVerticalText",
			"DrawRepeatVerticalTextInterval",
			"ExportSlope",
			"GetAngle2",
			"GetLength",
			"StringConvert",
			"StringConvertSignals",
			"StringConvertSignalsHelpr",
			"SignLabelParser",
			"compareSigns",
			"GetAngle",
			"spCount",
			"lessForVerticalLabels",
			"TRoadSign",
			"TRoadSignn",
			"package"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": true,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 8,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "acadexport.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 135462,
						"regions":
						{
						},
						"selection":
						[
							[
								5005,
								5005
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3696.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "AutoCADExportForm.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27924,
						"regions":
						{
						},
						"selection":
						[
							[
								12958,
								12958
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5016.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "AutoCADPrintForm.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25862,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 660.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/C/Program Files (x86)/Borland/CBuilder6/Imports/AutoCAD_TLB.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12601258,
						"regions":
						{
						},
						"selection":
						[
							[
								2877604,
								2877616
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1134728.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "acadexport.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9673,
						"regions":
						{
						},
						"selection":
						[
							[
								3787,
								3733
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2574.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "AcadExportThread.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40172,
						"regions":
						{
						},
						"selection":
						[
							[
								29527,
								29541
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 20907.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 6,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 138052,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										133,
										144
									],
									[
										490,
										501
									],
									[
										865,
										876
									],
									[
										1113,
										1124
									],
									[
										1197,
										1208
									],
									[
										1389,
										1400
									],
									[
										1520,
										1531
									],
									[
										1886,
										1897
									],
									[
										2280,
										2291
									],
									[
										2698,
										2709
									],
									[
										2990,
										3001
									],
									[
										3163,
										3174
									],
									[
										3365,
										3376
									],
									[
										3567,
										3578
									],
									[
										3737,
										3748
									],
									[
										3916,
										3927
									],
									[
										4092,
										4103
									],
									[
										4268,
										4279
									],
									[
										4440,
										4451
									],
									[
										4616,
										4627
									],
									[
										4774,
										4785
									],
									[
										4944,
										4955
									],
									[
										5121,
										5132
									],
									[
										5288,
										5299
									],
									[
										5472,
										5483
									],
									[
										5652,
										5663
									],
									[
										5828,
										5839
									],
									[
										6010,
										6021
									],
									[
										6193,
										6204
									],
									[
										6383,
										6394
									],
									[
										6548,
										6559
									],
									[
										6916,
										6946
									],
									[
										7207,
										7237
									],
									[
										7654,
										7684
									],
									[
										7946,
										7976
									],
									[
										8411,
										8441
									],
									[
										8728,
										8758
									],
									[
										8936,
										8966
									],
									[
										9213,
										9243
									],
									[
										9811,
										9827
									],
									[
										10133,
										10149
									],
									[
										10451,
										10467
									],
									[
										10774,
										10790
									],
									[
										11063,
										11079
									],
									[
										11385,
										11401
									],
									[
										11703,
										11719
									],
									[
										12026,
										12042
									],
									[
										12298,
										12314
									],
									[
										12416,
										12432
									],
									[
										12615,
										12631
									],
									[
										12716,
										12732
									],
									[
										12870,
										12886
									],
									[
										12973,
										12989
									],
									[
										13203,
										13219
									],
									[
										13321,
										13337
									],
									[
										13407,
										13423
									],
									[
										13556,
										13572
									],
									[
										13943,
										13959
									],
									[
										14534,
										14538
									],
									[
										14656,
										14660
									],
									[
										14926,
										14930
									],
									[
										15336,
										15340
									],
									[
										15679,
										15683
									],
									[
										15889,
										15893
									],
									[
										16018,
										16022
									],
									[
										16377,
										16381
									],
									[
										16844,
										16848
									],
									[
										17361,
										17365
									],
									[
										17704,
										17708
									],
									[
										17914,
										17918
									],
									[
										18043,
										18047
									],
									[
										18368,
										18372
									],
									[
										18854,
										18858
									],
									[
										19093,
										19097
									],
									[
										19431,
										19435
									],
									[
										19586,
										19590
									],
									[
										19886,
										19890
									],
									[
										20373,
										20377
									],
									[
										20825,
										20829
									],
									[
										21380,
										21384
									],
									[
										21712,
										21716
									],
									[
										22190,
										22194
									],
									[
										22768,
										22772
									],
									[
										23155,
										23159
									],
									[
										23473,
										23477
									],
									[
										23834,
										23838
									],
									[
										24029,
										24033
									],
									[
										24242,
										24246
									],
									[
										24490,
										24494
									],
									[
										24706,
										24710
									],
									[
										24941,
										24945
									],
									[
										25243,
										25247
									],
									[
										25554,
										25558
									],
									[
										25907,
										25911
									],
									[
										26294,
										26298
									],
									[
										26819,
										26823
									],
									[
										27393,
										27397
									],
									[
										27757,
										27761
									],
									[
										28013,
										28017
									],
									[
										28331,
										28335
									],
									[
										28651,
										28655
									],
									[
										28977,
										28981
									],
									[
										29303,
										29307
									],
									[
										29629,
										29633
									],
									[
										29955,
										29959
									],
									[
										30287,
										30291
									],
									[
										30633,
										30637
									],
									[
										30889,
										30893
									],
									[
										31177,
										31181
									],
									[
										31563,
										31567
									],
									[
										31886,
										31890
									],
									[
										32218,
										32222
									],
									[
										32587,
										32591
									],
									[
										32987,
										32991
									],
									[
										33260,
										33264
									],
									[
										33581,
										33585
									],
									[
										33999,
										34003
									],
									[
										34315,
										34319
									],
									[
										34750,
										34754
									],
									[
										35171,
										35175
									],
									[
										35410,
										35414
									],
									[
										35748,
										35752
									],
									[
										35903,
										35907
									],
									[
										36203,
										36207
									],
									[
										36690,
										36694
									],
									[
										37142,
										37146
									],
									[
										37697,
										37701
									],
									[
										38029,
										38033
									],
									[
										38507,
										38511
									],
									[
										39085,
										39089
									],
									[
										39472,
										39476
									],
									[
										39790,
										39794
									],
									[
										40151,
										40155
									],
									[
										40346,
										40350
									],
									[
										40559,
										40563
									],
									[
										40807,
										40811
									],
									[
										41023,
										41027
									],
									[
										41258,
										41262
									],
									[
										41560,
										41564
									],
									[
										41871,
										41875
									],
									[
										42224,
										42228
									],
									[
										42611,
										42615
									],
									[
										43136,
										43140
									],
									[
										43710,
										43714
									],
									[
										44074,
										44078
									],
									[
										44330,
										44334
									],
									[
										44648,
										44652
									],
									[
										44968,
										44972
									],
									[
										45294,
										45298
									],
									[
										45620,
										45624
									],
									[
										45946,
										45950
									],
									[
										46272,
										46276
									],
									[
										46604,
										46608
									],
									[
										46950,
										46954
									],
									[
										47206,
										47210
									],
									[
										47494,
										47498
									],
									[
										47880,
										47884
									],
									[
										48203,
										48207
									],
									[
										48535,
										48539
									],
									[
										48904,
										48908
									],
									[
										49304,
										49308
									],
									[
										49577,
										49581
									],
									[
										49898,
										49902
									],
									[
										50316,
										50320
									],
									[
										50632,
										50636
									],
									[
										51067,
										51071
									],
									[
										51493,
										51497
									],
									[
										51933,
										51937
									],
									[
										52373,
										52377
									],
									[
										52769,
										52773
									],
									[
										52891,
										52895
									],
									[
										53306,
										53310
									],
									[
										53458,
										53462
									],
									[
										53878,
										53886
									],
									[
										54085,
										54093
									],
									[
										54192,
										54200
									],
									[
										54303,
										54311
									],
									[
										54367,
										54375
									],
									[
										54455,
										54463
									],
									[
										54563,
										54571
									],
									[
										54627,
										54635
									],
									[
										54715,
										54723
									],
									[
										54807,
										54815
									],
									[
										54899,
										54907
									],
									[
										55050,
										55058
									],
									[
										55083,
										55091
									],
									[
										55213,
										55221
									],
									[
										55277,
										55285
									],
									[
										55437,
										55445
									],
									[
										55654,
										55662
									],
									[
										55814,
										55822
									],
									[
										55833,
										55841
									],
									[
										55866,
										55874
									],
									[
										56138,
										56146
									],
									[
										56331,
										56339
									],
									[
										56688,
										56697
									],
									[
										56919,
										56928
									],
									[
										57092,
										57101
									],
									[
										57262,
										57271
									],
									[
										57467,
										57476
									],
									[
										57737,
										57746
									],
									[
										58351,
										58356
									],
									[
										58619,
										58624
									],
									[
										58811,
										58816
									],
									[
										59003,
										59008
									],
									[
										59265,
										59270
									],
									[
										59376,
										59381
									],
									[
										59511,
										59516
									],
									[
										59535,
										59540
									],
									[
										59783,
										59788
									],
									[
										59806,
										59811
									],
									[
										60103,
										60108
									],
									[
										60396,
										60401
									],
									[
										60763,
										60768
									],
									[
										60942,
										60947
									],
									[
										61072,
										61077
									],
									[
										61252,
										61257
									],
									[
										61330,
										61335
									],
									[
										61449,
										61454
									],
									[
										61598,
										61603
									],
									[
										61827,
										61832
									],
									[
										61971,
										61976
									],
									[
										62091,
										62096
									],
									[
										62260,
										62265
									],
									[
										62347,
										62352
									],
									[
										62557,
										62562
									],
									[
										62957,
										62962
									],
									[
										63278,
										63283
									],
									[
										63461,
										63466
									],
									[
										63548,
										63553
									],
									[
										63841,
										63846
									],
									[
										64072,
										64077
									],
									[
										64374,
										64379
									],
									[
										64605,
										64610
									],
									[
										64925,
										64930
									],
									[
										65235,
										65240
									],
									[
										65466,
										65471
									],
									[
										65618,
										65623
									],
									[
										65859,
										65864
									],
									[
										66181,
										66186
									],
									[
										66499,
										66504
									],
									[
										66822,
										66827
									],
									[
										67111,
										67116
									],
									[
										67433,
										67438
									],
									[
										67751,
										67756
									],
									[
										68074,
										68079
									],
									[
										68337,
										68342
									],
									[
										68458,
										68463
									],
									[
										68625,
										68630
									],
									[
										68752,
										68757
									],
									[
										68940,
										68945
									],
									[
										69107,
										69112
									],
									[
										69276,
										69281
									],
									[
										69398,
										69403
									],
									[
										69565,
										69570
									],
									[
										69693,
										69698
									],
									[
										69880,
										69885
									],
									[
										70046,
										70051
									],
									[
										70335,
										70340
									],
									[
										70655,
										70660
									],
									[
										70827,
										70832
									],
									[
										70916,
										70921
									],
									[
										71241,
										71246
									],
									[
										71514,
										71519
									],
									[
										71742,
										71747
									],
									[
										72025,
										72030
									],
									[
										72237,
										72242
									],
									[
										72751,
										72760
									],
									[
										72932,
										72941
									],
									[
										73218,
										73227
									],
									[
										73478,
										73487
									],
									[
										74054,
										74063
									],
									[
										74235,
										74244
									],
									[
										74521,
										74530
									],
									[
										74874,
										74883
									],
									[
										75341,
										75357
									],
									[
										75673,
										75689
									],
									[
										75907,
										75923
									],
									[
										76079,
										76095
									],
									[
										76249,
										76265
									],
									[
										76500,
										76516
									],
									[
										77029,
										77041
									],
									[
										77091,
										77103
									],
									[
										77295,
										77307
									],
									[
										77361,
										77373
									],
									[
										77550,
										77562
									],
									[
										77604,
										77616
									],
									[
										77828,
										77840
									],
									[
										77882,
										77894
									],
									[
										78016,
										78028
									],
									[
										78074,
										78086
									],
									[
										78363,
										78375
									],
									[
										78409,
										78421
									],
									[
										78479,
										78491
									],
									[
										78503,
										78515
									],
									[
										78590,
										78602
									],
									[
										78650,
										78662
									],
									[
										78696,
										78708
									],
									[
										78753,
										78765
									],
									[
										78813,
										78825
									],
									[
										78859,
										78871
									],
									[
										78965,
										78977
									],
									[
										79062,
										79074
									],
									[
										79337,
										79349
									],
									[
										79598,
										79610
									],
									[
										79790,
										79802
									],
									[
										79807,
										79819
									],
									[
										80108,
										80120
									],
									[
										80137,
										80149
									],
									[
										80372,
										80384
									],
									[
										80401,
										80413
									],
									[
										80668,
										80680
									],
									[
										80809,
										80821
									],
									[
										81021,
										81033
									],
									[
										81349,
										81361
									],
									[
										81396,
										81408
									],
									[
										81409,
										81421
									],
									[
										81571,
										81583
									],
									[
										81591,
										81603
									],
									[
										81645,
										81657
									],
									[
										81697,
										81709
									],
									[
										81765,
										81777
									],
									[
										81817,
										81829
									],
									[
										81876,
										81888
									],
									[
										81901,
										81913
									],
									[
										82094,
										82106
									],
									[
										82249,
										82261
									],
									[
										82532,
										82544
									],
									[
										82553,
										82565
									],
									[
										82616,
										82628
									],
									[
										82641,
										82653
									],
									[
										82669,
										82681
									],
									[
										82727,
										82739
									],
									[
										82752,
										82764
									],
									[
										82780,
										82792
									],
									[
										82886,
										82898
									],
									[
										82903,
										82915
									],
									[
										82958,
										82970
									],
									[
										82979,
										82991
									],
									[
										82999,
										83011
									],
									[
										83053,
										83065
									],
									[
										83074,
										83086
									],
									[
										83094,
										83106
									],
									[
										83170,
										83182
									],
									[
										83399,
										83411
									],
									[
										83429,
										83441
									],
									[
										83536,
										83548
									],
									[
										83566,
										83578
									],
									[
										83668,
										83680
									],
									[
										83697,
										83709
									],
									[
										83771,
										83783
									],
									[
										83788,
										83800
									],
									[
										83866,
										83878
									],
									[
										83910,
										83922
									],
									[
										84019,
										84031
									],
									[
										84063,
										84075
									],
									[
										84179,
										84191
									],
									[
										84222,
										84234
									],
									[
										84310,
										84322
									],
									[
										84341,
										84353
									],
									[
										84481,
										84493
									],
									[
										84501,
										84513
									],
									[
										84559,
										84571
									],
									[
										84615,
										84627
									],
									[
										84691,
										84703
									],
									[
										84747,
										84759
									],
									[
										84978,
										84990
									],
									[
										84999,
										85011
									],
									[
										85213,
										85225
									],
									[
										85230,
										85242
									],
									[
										85464,
										85476
									],
									[
										85481,
										85493
									],
									[
										85778,
										85790
									],
									[
										85795,
										85807
									],
									[
										85864,
										85876
									],
									[
										85888,
										85900
									],
									[
										85944,
										85956
									],
									[
										85968,
										85980
									],
									[
										86275,
										86287
									],
									[
										86292,
										86304
									],
									[
										86638,
										86650
									],
									[
										86655,
										86667
									],
									[
										86896,
										86908
									],
									[
										86913,
										86925
									],
									[
										87167,
										87179
									],
									[
										87184,
										87196
									],
									[
										87438,
										87450
									],
									[
										87455,
										87467
									],
									[
										87777,
										87789
									],
									[
										87795,
										87807
									],
									[
										88016,
										88028
									],
									[
										88069,
										88081
									],
									[
										88229,
										88241
									],
									[
										88247,
										88259
									],
									[
										88475,
										88487
									],
									[
										88492,
										88504
									],
									[
										88901,
										88913
									],
									[
										88918,
										88930
									],
									[
										89238,
										89250
									],
									[
										89256,
										89268
									],
									[
										89456,
										89468
									],
									[
										89473,
										89485
									],
									[
										89568,
										89580
									],
									[
										89597,
										89609
									],
									[
										89850,
										89862
									],
									[
										89867,
										89879
									],
									[
										89962,
										89974
									],
									[
										89991,
										90003
									],
									[
										90186,
										90198
									],
									[
										90203,
										90215
									],
									[
										90298,
										90310
									],
									[
										90327,
										90339
									],
									[
										90589,
										90601
									],
									[
										90606,
										90618
									],
									[
										90701,
										90713
									],
									[
										90730,
										90742
									],
									[
										91013,
										91025
									],
									[
										91030,
										91042
									],
									[
										91125,
										91137
									],
									[
										91154,
										91166
									],
									[
										91441,
										91453
									],
									[
										91459,
										91471
									],
									[
										91670,
										91682
									],
									[
										91687,
										91699
									],
									[
										91780,
										91792
									],
									[
										91809,
										91821
									],
									[
										92003,
										92015
									],
									[
										92020,
										92032
									],
									[
										92113,
										92125
									],
									[
										92142,
										92154
									],
									[
										92321,
										92333
									],
									[
										92339,
										92351
									],
									[
										92549,
										92561
									],
									[
										92566,
										92578
									],
									[
										92659,
										92671
									],
									[
										92688,
										92700
									],
									[
										92909,
										92921
									],
									[
										92927,
										92939
									],
									[
										93285,
										93297
									],
									[
										93303,
										93315
									],
									[
										93607,
										93619
									],
									[
										93685,
										93697
									],
									[
										93926,
										93938
									],
									[
										93944,
										93956
									],
									[
										94259,
										94271
									],
									[
										94369,
										94381
									],
									[
										94387,
										94399
									],
									[
										94604,
										94616
									],
									[
										94633,
										94645
									],
									[
										94869,
										94881
									],
									[
										94915,
										94927
									],
									[
										94976,
										94988
									],
									[
										95252,
										95264
									],
									[
										95367,
										95379
									],
									[
										95387,
										95399
									],
									[
										95428,
										95440
									],
									[
										95465,
										95477
									],
									[
										95522,
										95534
									],
									[
										95559,
										95571
									],
									[
										95612,
										95624
									],
									[
										95632,
										95644
									],
									[
										95674,
										95686
									],
									[
										95714,
										95726
									],
									[
										95774,
										95786
									],
									[
										95814,
										95826
									],
									[
										95919,
										95931
									],
									[
										95956,
										95968
									],
									[
										95993,
										96005
									],
									[
										96030,
										96042
									],
									[
										96217,
										96229
									],
									[
										96375,
										96387
									],
									[
										96637,
										96649
									],
									[
										96958,
										96970
									],
									[
										97192,
										97204
									],
									[
										97221,
										97233
									],
									[
										97488,
										97500
									],
									[
										97512,
										97524
									],
									[
										97559,
										97571
									],
									[
										97583,
										97595
									],
									[
										97874,
										97886
									],
									[
										97897,
										97909
									],
									[
										97962,
										97974
									],
									[
										97985,
										97997
									],
									[
										98065,
										98077
									],
									[
										98202,
										98214
									],
									[
										98449,
										98461
									],
									[
										98478,
										98490
									],
									[
										98628,
										98640
									],
									[
										98665,
										98677
									],
									[
										98859,
										98871
									],
									[
										98956,
										98968
									],
									[
										99118,
										99130
									],
									[
										99147,
										99159
									],
									[
										99281,
										99293
									],
									[
										99378,
										99390
									],
									[
										99546,
										99558
									],
									[
										99563,
										99575
									],
									[
										99727,
										99739
									],
									[
										99756,
										99768
									],
									[
										100043,
										100055
									],
									[
										100221,
										100233
									],
									[
										100409,
										100421
									],
									[
										100641,
										100653
									],
									[
										100665,
										100677
									],
									[
										100733,
										100745
									],
									[
										100757,
										100769
									],
									[
										101031,
										101043
									],
									[
										101057,
										101069
									],
									[
										101126,
										101138
									],
									[
										101152,
										101164
									],
									[
										101221,
										101233
									],
									[
										101245,
										101257
									],
									[
										101314,
										101326
									],
									[
										101338,
										101350
									],
									[
										101627,
										101639
									],
									[
										101750,
										101762
									],
									[
										102038,
										102050
									],
									[
										102059,
										102071
									],
									[
										102323,
										102335
									],
									[
										102356,
										102368
									],
									[
										102467,
										102479
									],
									[
										102498,
										102510
									],
									[
										102717,
										102729
									],
									[
										102750,
										102762
									],
									[
										102861,
										102873
									],
									[
										102892,
										102904
									],
									[
										103122,
										103134
									],
									[
										103308,
										103320
									],
									[
										103608,
										103620
									],
									[
										103677,
										103689
									],
									[
										103718,
										103730
									],
									[
										103839,
										103851
									],
									[
										104012,
										104024
									],
									[
										104037,
										104049
									],
									[
										104089,
										104101
									],
									[
										104116,
										104128
									],
									[
										104207,
										104219
									],
									[
										104230,
										104242
									],
									[
										104424,
										104436
									],
									[
										104476,
										104488
									],
									[
										104524,
										104536
									],
									[
										104573,
										104585
									],
									[
										104785,
										104797
									],
									[
										104857,
										104869
									],
									[
										104915,
										104927
									],
									[
										104974,
										104986
									],
									[
										105050,
										105062
									],
									[
										105109,
										105121
									],
									[
										105159,
										105171
									],
									[
										105218,
										105230
									],
									[
										105268,
										105280
									],
									[
										105333,
										105345
									],
									[
										105591,
										105603
									],
									[
										105637,
										105649
									],
									[
										105778,
										105790
									],
									[
										105801,
										105813
									],
									[
										105857,
										105869
									],
									[
										105880,
										105892
									],
									[
										105931,
										105943
									],
									[
										105981,
										105993
									],
									[
										106136,
										106148
									],
									[
										106159,
										106171
									],
									[
										106215,
										106227
									],
									[
										106238,
										106250
									],
									[
										106289,
										106301
									],
									[
										106339,
										106351
									],
									[
										106486,
										106498
									],
									[
										106537,
										106549
									],
									[
										106656,
										106668
									],
									[
										106932,
										106944
									],
									[
										106955,
										106967
									],
									[
										107244,
										107256
									],
									[
										107299,
										107311
									],
									[
										107590,
										107602
									],
									[
										107613,
										107625
									],
									[
										107890,
										107902
									],
									[
										108151,
										108163
									],
									[
										108220,
										108232
									],
									[
										108261,
										108273
									],
									[
										108464,
										108476
									],
									[
										108494,
										108506
									],
									[
										108541,
										108553
									],
									[
										108571,
										108583
									],
									[
										108615,
										108627
									],
									[
										108697,
										108709
									],
									[
										108729,
										108741
									],
									[
										108783,
										108795
									],
									[
										108806,
										108818
									],
									[
										109077,
										109089
									],
									[
										109107,
										109119
									],
									[
										109159,
										109171
									],
									[
										109189,
										109201
									],
									[
										109238,
										109250
									],
									[
										109321,
										109333
									],
									[
										109353,
										109365
									],
									[
										109407,
										109419
									],
									[
										109437,
										109449
									],
									[
										109750,
										109762
									],
									[
										109782,
										109794
									],
									[
										109805,
										109817
									],
									[
										109863,
										109875
									],
									[
										109893,
										109905
									],
									[
										109934,
										109946
									],
									[
										109987,
										109999
									],
									[
										110019,
										110031
									],
									[
										110070,
										110082
									],
									[
										110100,
										110112
									],
									[
										110128,
										110140
									],
									[
										110155,
										110167
									],
									[
										110204,
										110216
									],
									[
										110234,
										110246
									],
									[
										110307,
										110319
									],
									[
										110337,
										110349
									],
									[
										110365,
										110377
									],
									[
										110392,
										110404
									],
									[
										110441,
										110453
									],
									[
										110471,
										110483
									],
									[
										110534,
										110546
									],
									[
										110580,
										110592
									],
									[
										110601,
										110613
									],
									[
										110866,
										110878
									],
									[
										111088,
										111100
									],
									[
										111109,
										111121
									],
									[
										111388,
										111400
									],
									[
										111529,
										111541
									],
									[
										111547,
										111559
									],
									[
										111592,
										111604
									],
									[
										111610,
										111622
									],
									[
										111877,
										111889
									],
									[
										112087,
										112099
									],
									[
										112217,
										112229
									],
									[
										112391,
										112403
									],
									[
										112589,
										112601
									],
									[
										112803,
										112815
									],
									[
										113117,
										113129
									],
									[
										113381,
										113393
									],
									[
										113401,
										113413
									],
									[
										113699,
										113711
									],
									[
										113961,
										113973
									],
									[
										113981,
										113993
									],
									[
										114281,
										114293
									],
									[
										114527,
										114539
									],
									[
										114637,
										114649
									],
									[
										114934,
										114946
									],
									[
										115069,
										115081
									],
									[
										115149,
										115161
									],
									[
										115341,
										115353
									],
									[
										115624,
										115636
									],
									[
										115759,
										115771
									],
									[
										115839,
										115851
									],
									[
										116031,
										116043
									],
									[
										116202,
										116214
									],
									[
										116361,
										116373
									],
									[
										116535,
										116547
									],
									[
										116689,
										116701
									],
									[
										116835,
										116847
									],
									[
										116993,
										117005
									],
									[
										117244,
										117256
									],
									[
										117266,
										117278
									],
									[
										117326,
										117338
									],
									[
										117348,
										117360
									],
									[
										117439,
										117451
									],
									[
										117461,
										117473
									],
									[
										117521,
										117533
									],
									[
										117543,
										117555
									],
									[
										117848,
										117860
									],
									[
										118157,
										118169
									],
									[
										118540,
										118552
									],
									[
										118753,
										118765
									],
									[
										118873,
										118885
									],
									[
										118989,
										119001
									],
									[
										119108,
										119120
									],
									[
										119225,
										119237
									],
									[
										119345,
										119357
									],
									[
										119463,
										119475
									],
									[
										119641,
										119653
									],
									[
										119764,
										119776
									],
									[
										119889,
										119901
									],
									[
										120016,
										120028
									],
									[
										120138,
										120150
									],
									[
										120261,
										120273
									],
									[
										120387,
										120399
									],
									[
										120514,
										120526
									],
									[
										120640,
										120652
									],
									[
										120763,
										120775
									],
									[
										120891,
										120903
									],
									[
										121018,
										121030
									],
									[
										121138,
										121150
									],
									[
										121264,
										121276
									],
									[
										121388,
										121400
									],
									[
										121511,
										121523
									],
									[
										121634,
										121646
									],
									[
										121761,
										121773
									],
									[
										121887,
										121899
									],
									[
										122014,
										122026
									],
									[
										122143,
										122155
									],
									[
										122270,
										122282
									],
									[
										122398,
										122410
									],
									[
										122524,
										122536
									],
									[
										122648,
										122660
									],
									[
										122771,
										122783
									],
									[
										122893,
										122905
									],
									[
										123015,
										123027
									],
									[
										123142,
										123154
									],
									[
										123267,
										123279
									],
									[
										123387,
										123399
									],
									[
										123509,
										123521
									],
									[
										123631,
										123643
									],
									[
										123754,
										123766
									],
									[
										123875,
										123887
									],
									[
										124001,
										124013
									],
									[
										124123,
										124135
									],
									[
										124245,
										124257
									],
									[
										124376,
										124388
									],
									[
										124498,
										124510
									],
									[
										124626,
										124638
									],
									[
										124747,
										124759
									],
									[
										124870,
										124882
									],
									[
										125004,
										125016
									],
									[
										125133,
										125145
									],
									[
										125262,
										125274
									],
									[
										125384,
										125396
									],
									[
										125517,
										125529
									],
									[
										125651,
										125663
									],
									[
										125773,
										125785
									],
									[
										125902,
										125914
									],
									[
										126033,
										126045
									],
									[
										126157,
										126169
									],
									[
										126289,
										126301
									],
									[
										126413,
										126425
									],
									[
										126540,
										126552
									],
									[
										126666,
										126678
									],
									[
										126787,
										126799
									],
									[
										126910,
										126922
									],
									[
										127033,
										127045
									],
									[
										127155,
										127167
									],
									[
										127281,
										127293
									],
									[
										127406,
										127418
									],
									[
										127529,
										127541
									],
									[
										127651,
										127663
									],
									[
										127777,
										127789
									],
									[
										127902,
										127914
									],
									[
										128031,
										128043
									],
									[
										128158,
										128170
									],
									[
										128282,
										128294
									],
									[
										128421,
										128433
									],
									[
										128559,
										128571
									],
									[
										128686,
										128698
									],
									[
										128812,
										128824
									],
									[
										128933,
										128945
									],
									[
										129053,
										129065
									],
									[
										129175,
										129187
									],
									[
										129301,
										129313
									],
									[
										129426,
										129438
									],
									[
										129550,
										129562
									],
									[
										129685,
										129697
									],
									[
										129821,
										129833
									],
									[
										129954,
										129966
									],
									[
										130085,
										130097
									],
									[
										130213,
										130225
									],
									[
										130344,
										130356
									],
									[
										130470,
										130482
									],
									[
										130595,
										130607
									],
									[
										130731,
										130743
									],
									[
										130877,
										130889
									],
									[
										131007,
										131019
									],
									[
										131130,
										131142
									],
									[
										131257,
										131269
									],
									[
										131386,
										131398
									],
									[
										131521,
										131533
									],
									[
										131647,
										131659
									],
									[
										131777,
										131789
									],
									[
										131897,
										131909
									],
									[
										132019,
										132031
									],
									[
										132143,
										132155
									],
									[
										132272,
										132284
									],
									[
										132404,
										132416
									],
									[
										132536,
										132548
									],
									[
										132665,
										132677
									],
									[
										132795,
										132807
									],
									[
										132923,
										132935
									],
									[
										133055,
										133067
									],
									[
										133187,
										133199
									],
									[
										133321,
										133333
									],
									[
										133453,
										133465
									],
									[
										133577,
										133589
									],
									[
										133702,
										133714
									],
									[
										133831,
										133843
									],
									[
										133960,
										133972
									],
									[
										134091,
										134103
									],
									[
										134219,
										134231
									],
									[
										134346,
										134358
									],
									[
										134477,
										134489
									],
									[
										134611,
										134623
									],
									[
										134736,
										134748
									],
									[
										134857,
										134869
									],
									[
										134985,
										134997
									],
									[
										135113,
										135125
									],
									[
										135246,
										135258
									],
									[
										135381,
										135393
									],
									[
										135517,
										135529
									],
									[
										135651,
										135663
									],
									[
										135785,
										135797
									],
									[
										135917,
										135929
									],
									[
										136053,
										136065
									],
									[
										136190,
										136202
									],
									[
										136326,
										136338
									],
									[
										136453,
										136465
									],
									[
										136579,
										136591
									],
									[
										136706,
										136718
									],
									[
										136832,
										136844
									],
									[
										136962,
										136974
									],
									[
										137087,
										137099
									],
									[
										137211,
										137223
									],
									[
										137339,
										137351
									],
									[
										137463,
										137475
									],
									[
										137589,
										137601
									],
									[
										137711,
										137723
									],
									[
										137841,
										137853
									],
									[
										137970,
										137982
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								117683,
								117683
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 14,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 56906.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/C/Program Files (x86)/Borland/CBuilder6/Include/Vcl/utilcls.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 116603,
						"regions":
						{
						},
						"selection":
						[
							[
								110170,
								110185
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/C/Program Files (x86)/Borland/CBuilder6/Include/oleauto.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47067,
						"regions":
						{
						},
						"selection":
						[
							[
								42667,
								42682
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 20645.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "AutoCADHelper.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 69524,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3696.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "AutoCADHelper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21049,
						"regions":
						{
						},
						"selection":
						[
							[
								8981,
								8981
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4884.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 36.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.CppYCM.2":
	{
		"height": 0.0
	},
	"output.astyle_error_message":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "rsign.sublime-project",
	"replace":
	{
		"height": 68.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 625.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 475.0
	},
	"select_symbol":
	{
		"height": 297.0,
		"last_filter": "pause",
		"selected_items":
		[
			[
				"pause",
				"PauseLastFramePrint"
			],
			[
				"Paus",
				"PauseLastFramePrint"
			],
			[
				"Last",
				"PauseLastFramePrint"
			]
		],
		"width": 490.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 339.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
